<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux文件IO</title>
    <url>/1f3f638f.html</url>
    <content><![CDATA[<p>在Linux中，对文件进行I/O操作是指对文件执行输入（Input）和输出（Output）操作。这些操作包括打开文件、读取文件内容、写入数据到文件、关闭文件等。文件I/O操作是通过系统调用实现的，这些系统调用提供了一组标准接口，使得程序可以与操作系统交互，进行文件操作。</p>
<span id="more"></span>

<h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>read, write, lseek, perror, strerror, truncate(截断), ftruncate(截断), fcntl(文件描述符操作)</p>
<p>ioctl(一般用于操作特殊文件或硬件外设，后期介绍)</p>
<p>linux中0，1，2表示标准输入、标准输出和标准错误，文件分配符fd不会取到这三个值</p>
<p>详情可使用<code>man 2 read/write/lseek...</code>查看</p>
<h2 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h2><p><code>errno</code>表示错误对应的标号需要<code>#include &lt;errno.h&gt;</code></p>
<p><code>strerr(errno)</code>打印出错误信息</p>
<p><code>perror()</code>直接打印</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>多次open()和dup()复制的区别</p>
<ol>
<li><p>多次open()</p>
<img src="/1f3f638f/image-20240624230432725.png" class="">
</li>
<li><p>dup(), dup2()复制</p>
<img src="/1f3f638f/image-20240624230350781.png" class=""></li>
</ol>
<p>可以看出多次open()的fd会指向不同的文件表，不同文件表指向同一个inode节点，而dup(), dup2()指向一个文件表</p>
<h3 id="三种实现方法"><a href="#三种实现方法" class="headerlink" title="三种实现方法"></a>三种实现方法</h3><ol>
<li><p>同一个进程中多次调用 open 函数打开同一个文件</p>
<img src="/1f3f638f/image-20240624231735907.png" class="" title="image-20240624231735907">
</li>
<li><p>不同进程中分别使用 open 函数打开同一个文件</p>
<img src="/1f3f638f/image-20240624231752361.png" class="" title="image-20240624231752361">
</li>
<li><p>同一个进程中通过 dup(dup2)函数对文件描述符进行复制</p>
<img src="/1f3f638f/image-20240624231804747.png" class="" title="image-20240624231804747"></li>
</ol>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ol>
<li><p><strong>O_APPEND</strong></p>
<p>open时加入该标志</p>
</li>
<li><p><strong>pread()<strong>和</strong>pwrite()</strong></p>
<p><code>man 2 pread</code>查看</p>
</li>
<li><p><strong>O_EXCL</strong></p>
<p>避免创建文件出现问题</p>
</li>
</ol>
<h1 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h1><p>标准 I/O 是对文件 I/O 进行了封装。标准 I/O 会处理很多细节，譬如分配 stdio 缓冲区、以优</p>
<p>化的块长度执行 I/O 等，这些处理使用户不必担心如何选择使用正确的块长度。</p>
<h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><p>文件：fopen, fclose, fseek, fread, fwrite</p>
<p>错误：feof, ferror, clearerr</p>
<p>详情使用<code>man 3 fopen/fclose...</code>来查看</p>
<h1 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h1><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">// 本质：write(1, format, size)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">// 本质：read(0, format, size)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="文件描述符和FILE指针相互转换"><a href="#文件描述符和FILE指针相互转换" class="headerlink" title="文件描述符和FILE指针相互转换"></a>文件描述符和FILE指针相互转换</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>; <span class="comment">// FILE* -&gt; fd</span></span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>; <span class="comment">// fd -&gt; FILE*</span></span><br></pre></td></tr></tbody></table></figure>



<h1 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a>IO缓冲</h1><img src="/1f3f638f/image-20240625115550593.png" class="" title="image-20240625115550593">

<p>可以看出：文件IO比标准IO要快</p>
<h2 id="文件IO缓冲"><a href="#文件IO缓冲" class="headerlink" title="文件IO缓冲"></a>文件IO缓冲</h2><p>刷新缓冲区：fsync, fdatasync, sync</p>
<p><code>man 3 sync</code>查看</p>
<p>fsync: 文件内数据和元数据</p>
<p>fdatasync: 文件内容数据</p>
<p>sync: 所有</p>
<h3 id="绕过IO缓冲"><a href="#绕过IO缓冲" class="headerlink" title="绕过IO缓冲"></a>绕过IO缓冲</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">// 需要定义宏</span></span></span><br><span class="line">fd = open(filepath, O_WRONLY | O_DIRECT);</span><br></pre></td></tr></tbody></table></figure>

<p>限制：</p>
<ul>
<li>应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐；</li>
<li>写文件时，文件的位置偏移量必须是块大小的整数倍；</li>
<li>写入到文件的数据大小必须是块大小的整数倍。</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 查看blocksize</span></span><br><span class="line"><span class="built_in">df</span> -h <span class="comment"># 查看根目录在哪</span></span><br><span class="line">tune2fs -l /dev/sda? | grep <span class="string">"Block size"</span></span><br></pre></td></tr></tbody></table></figure>

<p>内存起始地址对齐</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">8192</span>] __attribute__((aligned(<span class="number">4096</span>)));</span><br></pre></td></tr></tbody></table></figure>

<p>写入块大小整数倍</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret = write(fd, buf, <span class="number">4096</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="标准IO缓冲"><a href="#标准IO缓冲" class="headerlink" title="标准IO缓冲"></a>标准IO缓冲</h2><p>对stdio缓冲设置</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>man 3</code>查看文档</p>
<h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>使用stat，fstat, lstat查看文件（目录）属性，stat返回一个<code>struct stat</code>结构体</p>
<p>可使用<code>man 2</code>查看，fstat可通过fd来查看属性，lstat可以看链接文件属性</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="type">dev_t</span> st_dev; <span class="comment">/* 文件所在设备的 ID */</span></span><br><span class="line"> <span class="type">ino_t</span> st_ino; <span class="comment">/* 文件对应 inode 节点编号 */</span></span><br><span class="line"> <span class="type">mode_t</span> st_mode; <span class="comment">/* 文件对应的模式 */</span></span><br><span class="line"> <span class="type">nlink_t</span> st_nlink; <span class="comment">/* 文件的链接数 */</span></span><br><span class="line"> <span class="type">uid_t</span> st_uid; <span class="comment">/* 文件所有者的用户 ID */</span></span><br><span class="line"> <span class="type">gid_t</span> st_gid; <span class="comment">/* 文件所有者的组 ID */</span></span><br><span class="line"> <span class="type">dev_t</span> st_rdev; <span class="comment">/* 设备号（指针对设备文件） */</span></span><br><span class="line"> <span class="type">off_t</span> st_size; <span class="comment">/* 文件大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">blksize_t</span> st_blksize; <span class="comment">/* 文件内容存储的块大小 */</span></span><br><span class="line"> <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* 文件内容所占块数 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span> <span class="comment">/* 文件最后被访问的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span> <span class="comment">/* 文件内容最后被修改的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span> <span class="comment">/* 文件状态最后被改变的时间 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="归属"><a href="#归属" class="headerlink" title="归属"></a>归属</h2><p>使用chown, fchown, lchown来更改文件所属，三者区别上同</p>
<p>PS：进程相关联ID</p>
<img src="/1f3f638f/image-20240626092456008.png" class="">

<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>修改时间属性utime, utimes(精度区别)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> {</span></span><br><span class="line">	<span class="type">time_t</span> actime; <span class="comment">/* 访问时间 */</span></span><br><span class="line">	<span class="type">time_t</span> modtime; <span class="comment">/* 内容修改时间 */</span></span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> <span class="title function_">utimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> {</span></span><br><span class="line"> <span class="type">long</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"> <span class="type">long</span> tv_usec; <span class="comment">/* 微秒 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>还有futimens()和 utimensat()，区别是：</p>
<ul>
<li>可按纳秒级精度设置时间戳。</li>
<li>可单独设置某一时间戳。</li>
<li>可独立将任一时间戳设置为当前时间。</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>通过<code>link</code>设置硬连接，<code>symlink</code>设置软连接，<code>readlink</code>读取链接文件</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>unlink</code>删除文件</p>
<p><code>man 2</code>查看</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>存储形式</p>
<img src="/1f3f638f/image-20240626105646448.png" class="">

<p>常用操作：mkdir, rmdir, opendir, readdir, rewinddir, closedir, getcwd, chdir, fchdir</p>
<p><code>man 2</code>查看</p>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统信息与资源</title>
    <url>/8c131bee.html</url>
    <content><![CDATA[<p>在应用程序当中，有时往往需要去获取到一些系统相关的信息，譬如时间、日期、以及其它一些系统相关信息，本章将向大家介绍如何通过 Linux 系统调用或 C 库函数获取系统信息，譬如获取系统时间、日期以及设置系统时间、日期等；除此之外，还会向大家介绍 Linux 系统下的/proc 虚拟文件系统，包括/proc 文件系统是什么以及如何从/proc 文件系统中读取系统、进程有关信息。也会提及到信号相关的问题。</p>
<span id="more"></span>

<h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h1><p>常用函数：uname, sysinfo, gethostname, sysconf</p>
<p><code>man 2</code>查看文档</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">os_info</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = uname(&amp;os_info);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ret)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"uname"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sysname: %s\n"</span>, os_info.sysname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nodename: %s\n"</span>, os_info.nodename);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"release: %s\n"</span>, os_info.release);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"version: %s\n"</span>, os_info.version);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"machine: %s\n"</span>, os_info.machine);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sys_info</span>;</span></span><br><span class="line">    <span class="comment">/* 获取信息 */</span></span><br><span class="line">    ret = sysinfo(&amp;sys_info);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"sysinfo error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">    <span class="comment">/* 打印信息 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uptime: %ld\n"</span>, sys_info.uptime);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"totalram: %lu\n"</span>, sys_info.totalram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"freeram: %lu\n"</span>, sys_info.freeram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"procs: %u\n"</span>, sys_info.procs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gethostname</span></span><br><span class="line">    <span class="type">char</span> hostname[<span class="number">256</span>];</span><br><span class="line">    ret = gethostname(hostname, <span class="keyword">sizeof</span>(hostname));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"gethostname"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hostname: %s\n"</span>, hostname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"每个用户的最大并发进程数: %ld\n"</span>, sysconf(_SC_CHILD_MAX));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"系统节拍率: %ld\n"</span>, sysconf(_SC_CLK_TCK));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"系统页大小: %ld\n"</span>, sysconf(_SC_PAGESIZE));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大文件数: %ld\n"</span>, sysconf(_SC_OPEN_MAX));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h1><p>​	<img src="/8c131bee/image-20240626135355304.png" class=""></p>
<p>​	Linux 系统在开机启动之后首先会读取 RTC 硬件获取实时时钟作为系统时钟的初始值，之后内核便开始维护自己的系统时钟。实时时钟一般由 RTC 时钟芯片提供，RTC 芯片有相应的电池为其供电，以保证系统在关机情况下 RTC 能够继续工作、继续计时。</p>
<p>​	内核使用 jiffies 来记录系统从启动以来的系统节拍数，全局变量 jiffies 在系统开机启动时会设置一个初始值，RTC 实时时钟会在系统开机启动时读取一次，目的是用于对系统时钟进行初始化，这里说的初始化其实指的就是对内核的 jiffies 变量进行初始化操作。</p>
<p><strong>获取时间函数：</strong>time，gettimeofday(返回自 1970-01-01 00:00:00 +0000 (UTC)以来的时间值)</p>
<p><strong>时间转换函数：</strong>ctime, localtime_r(均是C库函数)</p>
<p><strong>设置时间</strong>：settimeofday</p>
<h1 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h1><ol>
<li><p>times</p>
<p>除以<code> sysconf(_SC_CLK_TCK)</code>，返回的是用户CPU时间和内核CPU时间</p>
</li>
<li><p>clock</p>
<p>C库函数，除以<code>CLOCKS_PER_SEC</code>, 返回的是总的CPU时间</p>
</li>
</ol>
<h1 id="Proc"><a href="#Proc" class="headerlink" title="Proc"></a>Proc</h1><p>proc 文件系统是一个虚拟文件系统，它以文件系统的方式为应用层访问系统内核数据提供了接口，用</p>
<p>户和应用程序可以通过 proc 文件系统得到系统信息和进程相关信息，对 proc 文件系统的读写作为与内核</p>
<p>进行通信的一种手段。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /proc</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></tbody></table></figure>

<img src="/8c131bee/image-20240627094516424.png" class="">

<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>不可靠信号：信号可能丢失（非实时信号）序号为1~31</p>
<p>当排队时，不可靠信号等待是集合，当相同信号再次传来的时候就会丢弃</p>
<h2 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h2><table>
<thead>
<tr>
<th>信号名称</th>
<th>编号</th>
<th>描述</th>
<th>系统默认操作</th>
</tr>
</thead>
<tbody><tr>
<td>SIGINT</td>
<td>2</td>
<td>终端中断符</td>
<td>term</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>终端退出符</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>非法硬件指令</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>异常终止（abort）</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>7</td>
<td>内存访问错误</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>算术异常</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>终极终止信号</td>
<td>term</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>10</td>
<td>用户自定义信号 1</td>
<td>term</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>无效的内存引用</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>12</td>
<td>用户自定义信号 2</td>
<td>term</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>管道关闭</td>
<td>term</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>定时器超时（alarm）</td>
<td>term</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>终止进程</td>
<td>term</td>
</tr>
<tr>
<td>SIGCHLD/SIGCLD</td>
<td>17</td>
<td>子进程终止或停止</td>
<td>ignore</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>18</td>
<td>使停止状态的进程继续运行</td>
<td>cont</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>19</td>
<td>停止进程</td>
<td>stop</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>20</td>
<td>终端停止符</td>
<td>stop</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>24</td>
<td>超过 CPU 限制</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>26</td>
<td>虚拟定时器超时</td>
<td>term</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>28</td>
<td>终端窗口尺寸发生变化</td>
<td>term</td>
</tr>
<tr>
<td>SIGPOLL/SIGIO</td>
<td>29</td>
<td>异步 I/O</td>
<td>term/ignore</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>31</td>
<td>无效系统调用</td>
<td>term+core</td>
</tr>
</tbody></table>
<p>tips: term 表示终止进程；core 表示生成核心转储文件；ignore 表示忽略信号；cont 表示继续运行进程；stop 表示停止进程（注意停止不等于终止，而是暂停）</p>
<p><strong>进程对信号处理：</strong>signal和sigaction函数</p>
<p><strong>发送信号：</strong>kill和raise函数，kill发送任一进程，raise发送自身</p>
<p><strong>定时和休眠：</strong>alarm和pause函数</p>
<p><strong>信号集相关函数</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">// 空信号集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">// 捕获所有信号</span></span><br><span class="line"><span class="comment">// 添加信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 是否在信号集中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 查看是否信号是否等待并存入信号集中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="信号掩码"><a href="#信号掩码" class="headerlink" title="信号掩码"></a>信号掩码</h2><p>内核为每一个进程维护了一个信号掩码（其实就是一个信号集），即一组信号。当进程接收到一个属于信号掩码中定义的信号时，该信号将会被阻塞、无法传递给进程进行处理，那么内核会将其阻塞，直到该信号从信号掩码中移除，内核才会把该信号传递给进程从而得到处理。</p>
<ul>
<li>当应用程序调用 signal()或 sigaction()函数为某一个信号设置处理方式时，进程会自动将该信号添加</li>
</ul>
<p>到信号掩码中，这样保证了在处理一个给定的信号时，如果此信号再次发生，那么它将会被阻塞；</p>
<p>当然对于 sigaction()而言，是否会如此，需要根据 sigaction()函数是否设置了 SA_NODEFER 标志</p>
<p>而定；当信号处理函数结束返回后，会自动将该信号从信号掩码中移除。</p>
<ul>
<li>使用 sigaction()函数为信号设置处理方式时，可以额外指定一组信号，当调用信号处理函数时将该</li>
</ul>
<p>组信号自动添加到信号掩码中，当信号处理函数结束返回后，再将这组信号从信号掩码中移除；通</p>
<p>过 sa_mask 参数进行设置。</p>
<ul>
<li>除了以上两种方式之外，还可以使用<code>sigprocmask()</code>系统调用，随时可以显式地向信号掩码中添加或</li>
</ul>
<p>移除信号。使用<code>man2</code>查看使用教程</p>
<h2 id="实时信号"><a href="#实时信号" class="headerlink" title="实时信号"></a>实时信号</h2><p>可靠信号（32~64）队列处理</p>
<p>可以在<code>/usr/include/asm-generic/signal.h</code>进行查看</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _NSIG		64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These should not be considered constants from userland.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGRTMIN	32</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIGRTMAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGRTMAX	_NSIG</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>对于可靠信号需要使用<code>sigqueue</code>来传递信号</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>忽略信号</strong></p>
<p><code>SIG_IGN</code></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略中断信号</span></span><br><span class="line"><span class="comment">// 忽略 SIGINT 信号 (通常是 Ctrl+C)</span></span><br><span class="line">signal(SIGINT, SIG_IGN);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>异常退出</strong></p>
<p><code>abort</code></p>
<p>无论阻塞或忽略 SIGABRT 信号，abort()调用均不收到影响，总会成功终止进程</p>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux线程</title>
    <url>/918f81df.html</url>
    <content><![CDATA[<p>线程是程序最基本的运行单位，而进程不能运行，真正运行的是进程中的线程。当启动应用程序后，系统就创建了一个进程，可以认为进程仅仅是一个容器，它包含了线程运行所需的数据结构、环境变量等信息。</p>
<span id="more"></span>

<h1 id="线程特点"><a href="#线程特点" class="headerlink" title="线程特点"></a>线程特点</h1><ul>
<li>线程不单独存在、而是包含在进程中；</li>
<li>线程是参与系统调度的基本单位；</li>
<li>可并发执行。同一进程的多个线程之间可并发执行，在宏观上实现同时运行的效果；</li>
<li>共享进程资源。</li>
</ul>
<p><strong>串行，并行，并发区别</strong></p>
<p>串行</p>
<img src="/918f81df/image-20240703220319726.png" class="">

<p>并行</p>
<img src="/918f81df/image-20240703220348407.png" class="">

<p>并发</p>
<img src="/918f81df/image-20240703220412134.png" class="">

<h1 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 线程ID</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程 attr: 定义了线程的各种属性 arg: 传入start_routine的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程终止 retval返回值可由pthread_join()获取</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收线程</span></span><br><span class="line"><span class="comment">// 调用 pthread_join()函数将会以阻塞的形式等待指定的线程终止，如果该线程已经终止，则 pthread_join()</span></span><br><span class="line"><span class="comment">// 立刻返回。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，线程是响应其它线程发送过来的取消请求的，响应请求然后退出线程。当然，线程可以选</span></span><br><span class="line"><span class="comment">// 择不被取消或者控制如何被取消</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程清理，需要一一对应</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="取消点"><a href="#取消点" class="headerlink" title="取消点"></a>取消点</h1><p>取消点其实就是一系列函数，当执行到这些函数的时候，才会真正响应取消请求，这些函数就是取消点；在没有出现取消点时，取消请求是无法得到处理的。</p>
<p>可作为取消点的函数</p>
<img src="/918f81df/image-20240704223904340.png" class="">

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 设置取消状态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于type项</span></span><br><span class="line"><span class="comment">PTHREAD_CANCEL_DEFERRED：取消请求到来时，线程还是继续运行，取消请求被挂起，直</span></span><br><span class="line"><span class="comment">到线程到达某个取消点</span></span><br><span class="line"><span class="comment">PTHREAD_CANCEL_ASYNCHRONOUS：可能会在任何时间点（也许是立即取消，但不一定）</span></span><br><span class="line"><span class="comment">取消线程（应用较少）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生一个取消点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_testcancel</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化和销毁属性</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>每个线程都有自己的栈空间，pthread_attr_t 数据结构中定义了栈的起始地址以及栈大小</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 设置和获取栈位置和大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstack</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr, <span class="type">size_t</span> *stacksize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstackaddr</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstackaddr</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>pthread_attr_t也可以设置detach属性</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程同步是为了对共享资源的访问进行保护。</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>仅列出API</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// init mutex</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock and unlock</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; <span class="comment">// 若无法上锁，会阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; <span class="comment">// 不会阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy mutex</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>互斥锁属性</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化和销毁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_settype</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>互斥锁的类型属性控制着互斥锁的锁定特性，一共有 4 中类型：</p>
<p><strong>PTHREAD_MUTEX_NORMAL</strong>：一种标准的互斥锁类型，不做任何的错误检查或死锁检测。如果线程试图对已经由自己锁定的互斥锁再次进行加锁，则发生死锁；互斥锁处于未锁定状态，或者已由其它线程锁定，对其解锁会导致不确定结果。</p>
<p><strong>PTHREAD_MUTEX_ERRORCHECK</strong>：此类互斥锁会提供错误检查。譬如这三种情况都会导致返回错误：线程试图对已经由自己锁定的互斥锁再次进行加锁（同一线程对同一互斥锁加锁两次），返回错误；线程对由其它线程锁定的互斥锁进行解锁，返回错误；线程对处于未锁定状态的互斥锁进行解锁，返回错误。这类互斥锁运行起来比较慢，因为它需要做错误检查，不过可将其作为调试工具，以发现程序哪里违反了互斥锁使用的基本原则。</p>
<p><strong>PTHREAD_MUTEX_RECURSIVE</strong>：此类互斥锁允许同一线程在互斥锁解锁之前对该互斥锁进行多次加锁，然后维护互斥锁加锁的次数，把这种互斥锁称为递归互斥锁，但是如果解锁次数不等于加速次数，则是不会释放锁的；所以，如果对一个递归互斥锁加锁两次，然后解锁一次，那么这个互斥锁依然处于锁定状态，对它再次进行解锁之前不会释放该锁。</p>
<p> <strong>PTHREAD_MUTEX_DEFAULT</strong>：此类互斥锁提供默认的行为和特性。使用宏PTHREAD_MUTEX_INITIALIZER初始化的互斥锁， 或者调用参数arg为NULL的pthread_mutexattr_init()函数所创建的互斥锁，都属于此类型。此类锁意在为互斥锁的实现保留最大灵活性，Linux 上， PTHREAD_MUTEX_DEFAULT类型互斥锁的行为与PTHREAD_MUTEX_NORMAL 类型相仿。</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量是线程可用的另一种同步机制。条件变量用于自动阻塞线程，知道某个特定事件发生或某个条件满足为止，通常情况下，条件变量是和互斥锁一起搭配使用的。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 条件变量初始化</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>在使用条件变量之前必须对条件变量进行初始化操作，使用 PTHREAD_COND_INITIALIZER 宏或者函数 pthread_cond_init()都行；</li>
<li>对已经初始化的条件变量再次进行初始化，将可能会导致未定义行为；</li>
<li>对没有进行初始化的条件变量进行销毁，也将可能会导致未定义行为；</li>
<li>对某个条件变量而言，仅当没有任何线程等待它时，将其销毁才是最安全的；</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁与互斥锁很相似，从本质上说也是一把锁，在访问共享资源之前对自旋锁进行上锁，在访问完成后释放自旋锁（解锁）；事实上，从实现方式上来说，互斥锁是基于自旋锁来实现的，所以自旋锁相较于互斥锁更加底层。</p>
<p>自旋锁与互斥锁相似，但是互斥锁在无法获取到锁时会让线程陷入阻塞等待状态；而自旋锁在无法获取到锁时，将会在原地“自旋”等待。“自旋”其实就是调用者一直在循环查看该自旋锁的持有者是否已经释放了锁。</p>
<p>自旋锁的不足之处在于：自旋锁一直占用的 CPU，它在未获得锁的情况下，一直处于运行状态（自旋），所以占着 CPU，如果不能在很短的时间内获取锁，这无疑会使 CPU 效率降低。（一般在内核中使用，中断….）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// init and destroy</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_destroy</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_init</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> pshared 表示自旋锁的进程共享属性</span></span><br><span class="line"><span class="comment"> PTHREAD_PROCESS_SHARED：共享自旋锁。该自旋锁可以在多个进程中的线程之间共享；</span></span><br><span class="line"><span class="comment"> PTHREAD_PROCESS_PRIVATE：私有自旋锁。只有本进程内的线程才能够使用该自旋锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// So easy, no need to explain</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_lock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_trylock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_unlock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁有3 种状态：读模式下的加锁状态（以下简称读加锁状态）、写模式下的加锁状态（以下简称写加锁状态）和不加锁状态（见），一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。</p>
<img src="/918f81df/image-20240705230905164.png" class="">

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// init and destroy</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>; <span class="comment">// 读模式上锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>; <span class="comment">// 写模式上锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>; <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_destroy</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_init</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr, <span class="type">int</span> *pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_setpshared</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> pshared 表示自旋锁的进程共享属性</span></span><br><span class="line"><span class="comment"> PTHREAD_PROCESS_SHARED：共享自旋锁。该自旋锁可以在多个进程中的线程之间共享；</span></span><br><span class="line"><span class="comment"> PTHREAD_PROCESS_PRIVATE：私有自旋锁。只有本进程内的线程才能够使用该自旋锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全函数"><a href="#线程安全函数" class="headerlink" title="线程安全函数"></a>线程安全函数</h2><p><strong>可重入函数</strong>：如果一个函数被同一进程的多个不同的执行流同时调用，每次函数调用总是能产生正确的结果（或者叫产生预期的结果），把这样的函数就称为可重入函数。</p>
<p>分类：</p>
<ol>
<li><strong>绝对的可重入函数：</strong>所谓绝对，指的是该函数不管如何调用，都刚断言它是可重入的，都能得到预期的结果。</li>
<li><strong>带条件的可重入函数：</strong>指的是在满足某个/某些条件的情况下，可以断言该函数是可重入的，不管怎么调用都能得到预期的结果。</li>
</ol>
<p>绝对可重入函数的特点：</p>
<ul>
<li><p>函数内所使用到的变量均为局部变量，换句话说，该函数内的操作的内存地址均为本地栈地址；</p>
</li>
<li><p>函数参数和返回值均是值类型；</p>
</li>
<li><p>函数内调用的其它函数也均是绝对可重入函数。</p>
</li>
</ul>
<p><strong>线程安全函数</strong>：一个函数被多个线程（其实也是多个执行流，但是不包括由信号处理函数所产生的执行流）同时用时，它总会一直产生正确的结果，把这样的函数称为线程安全函数。线程安全函数包括可重入函数，可重入函数是线程安全函数的一个真子集，也就是说可重入函数一定是线程安全函数，但线程安全函数不一定是可重入函数。</p>
<img src="/918f81df/image-20240706223032854.png" class="">

<p>POSIX.1-2001 和 POSIX.1-2008 标准中规定的所有函数都必须是线程安全函数，但以下函数除外：</p>
<img src="/918f81df/image-20240706223328484.png" class="">

<h2 id="线程特有数据"><a href="#线程特有数据" class="headerlink" title="线程特有数据"></a>线程特有数据</h2><p><strong>一次性初始化</strong>：在多线程编程环境下，有些代码段只需要执行一次，譬如一些初始化相关的代码段。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>在多线程编程环境下，尽管 pthread_once()调用会出现在多个线程中，但该函数会保证 init_routine()函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。</p>
<p><strong>线程特有数据</strong></p>
<p>很多库函数都会返回一个字符串指针，譬如 asctime()、ctime()、localtime()等，返回出来的字符串可以被调用线程直接使用，但该字符串缓冲区通常是这些函数内部所维护的静态数组或者是某个全局数组。被多个线程同时调用时，返回的字符串中的数据可能是混乱的，因为某一线程调用它时，缓冲区中的数据可能被另一个调用线程修改了。</p>
<p>线程特有数据的核心思想其实非常简单，就是为每一个调用线程（调用某函数的线程，该函数就是我们要通过线程特有数据将其实现为线程安全的函数）分配属于该线程的私有数据区，为每个调用线程分别维护一份变量的副本。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建键值对</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键值对，对应的value就是要复制的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br><span class="line"><span class="comment">// 返回复制值的内存地址</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>或者也可以使用<code>__thread</code>，也可以达成特有数据的效果</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> __thread <span class="type">char</span> buf[MAX_ERROR_LEN];</span><br></pre></td></tr></tbody></table></figure>

<h1 id="线程与信号"><a href="#线程与信号" class="headerlink" title="线程与信号"></a>线程与信号</h1><ul>
<li>信号的系统默认行为是属于进程层面。</li>
<li>信号处理函数属于进程层面。</li>
<li>信号的发送既可针对整个进程，也可针对某个特定的线程。在满足以下三个条件中的任意一个时，信号的发送针对的是某个线程：<ol>
<li>产生了硬件异常相关信号，譬如 SIGBUS、SIGFPE、SIGILL 和 SIGSEGV 信号；</li>
<li>当线程试图对已断开的管道进行写操作时所产生的 SIGPIPE 信号；</li>
<li>由函数 pthread_kill()或 pthread_sigqueue()所发出的信号</li>
</ol>
</li>
<li>当一个多线程进程接收到一个信号时，且该信号绑定了信号处理函数时，内核会任选一个线程来接收这个信号</li>
<li>信号掩码其实是属于线程层面的，<code> pthread_sigmask()</code>函数来设置各自线程的信号掩码</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 设置线程掩码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">// 向线程发送信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>异步信号安全函数</strong>：指的是可以在信号处理函数中可以被安全调用的线程安全函数，可重入函数一定是异步信号安全函数。</p>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程</title>
    <url>/87698413.html</url>
    <content><![CDATA[<p>进程在Linux系统中扮演着至关重要的角色。它不仅是系统资源管理和任务调度的基本单位，还直接影响着系统的性能和稳定性。本文将详细探讨Linux中的进程，包括其概念、生命周期、内核数据结构、以及与进程管理相关的常用API函数，以便读者更深入地理解进程在Linux中的重要性和实现机制。</p>
<span id="more"></span>

<h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后，它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。</p>
<p>Linux系统下的所有进程都是由其父进程创建而来，譬如在 shell 终端通过命令的方式执行一个程序./app，那么 app进程就是由 shell 终端进程创建出来的，shell 终端就是该进程的父进程。init 进程，它是 Linux 系统启动之后运行的第一个进程，它管理着系统上所有其它进程，init 进程是由内核启动，因此理论上说它没有父进程。</p>
<p>程序结束其实就是进程终止，进程终止的方式通常有多种，大体上分为正常终止和异常终止，正常终止</p>
<p>包括：</p>
<ul>
<li><p>main()函数中通过 return 语句返回来终止进程；</p>
</li>
<li><p>应用程序中调用 exit()函数终止进程；</p>
</li>
<li><p>应用程序中调用<code>_exit()</code>终止进程；</p>
</li>
</ul>
<p>异常终止包括：</p>
<ul>
<li>应用程序中调用 abort()函数终止进程；</li>
<li>进程接收到一个信号，譬如 SIGKILL 信号。</li>
</ul>
<p><strong>exit和_exit的区别：</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> = atexit + _exit;</span><br><span class="line"><span class="comment">// atexit: 调用终止处理+刷新IO（注册,最后exit执行按先进后出顺序来）</span></span><br><span class="line"><span class="comment">// _exit: 进入内核执行清理工作</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>exit和return的区别：</strong></p>
<p>exit会进入内核，而return只是一个返回，把指挥权交给上层调用，return也会调用终止处理函数并刷新缓冲</p>
<h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><img src="/87698413/image-20240702212909754.png" class="">

<p>进程中相关属性</p>
<ol>
<li><p>pid</p>
<p>每个进程都有自己唯一的标识：进程号（进程 ID、PID）。</p>
</li>
<li><p>pgid</p>
<p>每个进程除了有一个进程 ID、父进程 ID 之外，还有一个进程组 ID，用于标识该进程属于哪一个进程组，进程组是一个或多个进程的集合。每一个进程组有一个组长进程，组长进程的 ID 就等于进程组 ID；组长进程不能再创建新的进程组；只要进程组中还存在一个进程，则该进程组就存在，这与其组长进程是否终止无关。</p>
</li>
<li><p>sid</p>
<p>会话是一个或多个进程组的集合，其与进程组、进程之间的关系如</p>
<p>下图所示：</p>
<img src="/87698413/image-20240702213346684.png" class="">

<p>一个会话可以有控制终端、也可没有控制终端，在有控制终端的情况下也只能连接一个控制终端。</p>
<p>对于会话来说，会话的首领进程的进程组 ID 将作为该会话的标识，也就是会话 ID（sid），在默认情况下，新创建的进程会继承父进程的会话 ID。</p>
</li>
</ol>
<p>相关操作</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>



<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>获取进程中的环境变量</p>
<ol>
<li><p>environ变量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 代码中使用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ; <span class="comment">// 申明外部全局变量 environ</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>getenv()函数</p>
<p><code>man 3</code> 查看使用</p>
</li>
<li><p>通过main函数参数获取</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span> <span class="comment">// 不推荐，有些系统不支持</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>程序启动时可设置环境变量<code>NAME=value ./app</code></p>
<p>常用操作</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// man 3 查看使用</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 设置环境变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>; <span class="comment">// 修改string会修改环境变量</span></span><br><span class="line"><span class="comment">// 修改name和value不会修改环境变量，创建了一个缓冲区指向他们</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clearenv</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">clearenv()函数内部的做法其实就是将environ赋值为NULL。在某些情况下，使用setenv()函数和clearenv()</span></span><br><span class="line"><span class="comment">函数可能会导致程序内存泄漏。setenv()函数会为环境变量分配一块内存缓冲区，随之称为进程的一部分；而调用 clearenv()函数时没有释放该缓冲区（clearenv()调用并不知晓该缓冲区的存在，故而也无法将其释放）</span></span><br><span class="line"><span class="comment">反复调用者两个函数的程序，会不断产生内存泄漏。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><img src="/87698413/image-20240701181207013.png" class="">

<h1 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h1><p><code>fork</code>函数</p>
<ol>
<li>一次fork两个返回值，0为子进程，大于0为父进程</li>
<li>fork进程创建了与原来进程几乎完全相同的进程（复制父进程的代码段，堆，栈）</li>
<li>子进程从fork调用后开始执行</li>
</ol>
<p><code>vfork</code>函数：与父进程共有代码段，堆，栈</p>
<p>ps: 创建的子进程退出需要使用_exit而不是exit</p>
<p>对文件的共享</p>
<img src="/87698413/image-20240701202424640.png" class="">

<p>父子进程fd指向同一个文件表</p>
<p>fork 后子进程会继承父进程绑定的信号处理函数，若调用 exec 加载新程序后，就不会在继承这个信号处理函数了fork 后子进程会继承父进程的信号掩码，执行 exec 后仍会继承这个信号掩码</p>
<h1 id="监视子进程"><a href="#监视子进程" class="headerlink" title="监视子进程"></a>监视子进程</h1><p><strong>孤儿进程：</strong>父进程先死且未回收子进程，子进程的父进程会交给init进程（图形化界面不一样）</p>
<p><strong>僵尸进程：</strong>子进程先死但父进程未回收，此时使用kill也无法杀死</p>
<p>SIGCHLD 信号发送条件：</p>
<ul>
<li>当父进程的某个子进程终止时，父进程会收到 SIGCHLD 信号；</li>
<li>当父进程的某个子进程因收到信号而停止（暂停运行）或恢复时，内核也可能向父进程发送该信号。</li>
</ul>
<p>监视子进程函数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值是回收的子进程的pid号, man查看</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>; <span class="comment">// 只能阻塞等待</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>; <span class="comment">// 可非阻塞</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h1><p><code>man</code>进行查看</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">// 以下都是对execve的封装，path表示路径，file表示若本目录没找到会在PATH里找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>守护进程（Daemon）也称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些事情的发生，主要表现为以下两个特点：</p>
<ol>
<li>长期运行</li>
<li>与控制终端分离</li>
</ol>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><img src="/87698413/image-20240702222117113.png" class="">

<ul>
<li><p>UNIX IPC：管道、FIFO、信号；</p>
</li>
<li><p>System V IPC：信号量、消息队列、共享内存；</p>
</li>
<li><p>POSIX IPC：信号量、消息队列、共享内存（最快）；</p>
</li>
<li><p>Socket IPC：基于 Socket 进程间通信。（网络）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux高级IO</title>
    <url>/1fd3d10d.html</url>
    <content><![CDATA[<p>本文再次回到文件 I/O 相关话题的讨论，将会介绍文件 I/O 当中的一些高级用法，以应对不同应用场合的需求，主要包括：非阻塞 I/O、I/O 多路复用、异步 I/O、存储映射 I/O 以及文件锁，</p>
<span id="more"></span>

<h1 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h1><p>本小节我们将分别演示使用阻塞式 I/O 和非阻塞式 I/O 对文件进行读操作，在调用 open()函数打开文件时，为参数 flags 指定 O_NONBLOCK 标志，open()调用成功后，后续的 I/O 操作将以非阻塞式方式进行；这就是非阻塞 I/O 的打开方式，如果未指定 O_NONBLOCK 标志，则默认使用阻塞式 I/O 进行操作。</p>
<p>当对文件进行读取操作时，如果文件当前无数据可读，那么阻塞式 I/O 会将调用者应用程序挂起、进入休眠阻塞状态，直到有数据可读时才会解除阻塞；而对于非阻塞 I/O，应用程序不会被挂起，而是会立即返回，它要么一直轮训等待，直到数据可读，要么直接放弃！</p>
<p>所以阻塞式 I/O 的优点在于能够提升 CPU 的处理效率，当自身条件不满足时，进入阻塞状态，交出 CPU资源，将 CPU 资源让给别人使用；而非阻塞式则是抓紧利用 CPU 资源，譬如不断地去轮训，这样就会导致该程序占用了非常高的 CPU 使用率！</p>
<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>I/O 多路复用（IO multiplexing）它通过一种机制，可以监视多个文件描述符，一旦某个文件描述符（也就是某个文件）可以执行 I/O 操作时，能够通知应用程序进行相应的读写操作。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 select()会一直阻塞，直到某一个或多个文件描述符成为就绪态（可以读或写）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>对于fds，都是 fd_set 类型指针，指向一个 fd_set 类型对象，fd_set 数据类型是一个文件描述符的集合体。本质是bitmap</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>缺点：</p>
<ol>
<li>bitmap位数有限</li>
<li>fd_set不可重用</li>
<li>用户态到内核态切换有开销</li>
<li>O(n)遍历哪一个被置位</li>
</ol>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> {</span></span><br><span class="line"> <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line"> <span class="type">short</span> events; <span class="comment">/* requested events */</span></span><br><span class="line"> <span class="type">short</span> revents; <span class="comment">/* returned events */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>每次恢复revents就行了，不需要重置整个bitmap</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">新建epoll描述符==epoll_create()</span><br><span class="line">epoll_ctrl(epoll描述符，添加或者删除所有待监控的连接)</span><br><span class="line">返回的活跃连接 ==epoll_wait（ epoll描述符 ）</span><br></pre></td></tr></tbody></table></figure>

<p>epoll是通过内核与用户空间mmap同一块内存实现的。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，减少了用户态和内核态之间的数据交换。</p>
<p>epoll_wait会返回改动文件的数，并将其置于epoll的前列（红黑树），所以只需遍历前几个就行了</p>
<h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><p>O_ASYNC 标志可用于使能文件描述符的异步 I/O 事件，当文件描述符可执行 I/O 操作时，内核会向异步 I/O 事件的接收进程发送 SIGIO 信号。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 只能使用fcntl设置异步IO</span></span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line">flag = fcntl(fd, F_GETFL); <span class="comment">//先获取原来的 flag</span></span><br><span class="line">flag |= O_ASYNC; <span class="comment">//将 O_ASYNC 标志添加到 flag</span></span><br><span class="line">fcntl(fd, F_SETFL, flag); <span class="comment">//重新设置 flag</span></span><br><span class="line"><span class="comment">// 设置异步 I/O 事件的接收进程</span></span><br><span class="line">fcntl(fd, F_SETOWN, getpid());</span><br></pre></td></tr></tbody></table></figure>

<p><strong>优化</strong></p>
<p>默认的SIGIO是非可靠信号，使用</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">fcntl(fd, F_SETSIG, SIGRTMIN);</span><br></pre></td></tr></tbody></table></figure>

<p>将其设为可靠信号。</p>
<h1 id="存储映射IO"><a href="#存储映射IO" class="headerlink" title="存储映射IO"></a>存储映射IO</h1><p>存储映射 I/O（memory-mapped I/O）是一种基于内存区域的高级 I/O 操作，它能将一个文件映射到进程地址空间中的一块内存区域中，当从这段内存中读数据时，就相当于读文件中的数据（对文件进行 read 操作），将数据写入这段内存时，则相当于将数据直接写入文件中（对文件进行 write 操作）。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></tbody></table></figure>

<img src="/1fd3d10d/image-20240715222704115.png" class="">

<h1 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h1><ol>
<li><p>建议性锁</p>
<p>建议性锁本质上是一种协议，程序访问文件之前，先对文件上锁，上锁成功之后再访问文件，这是建议性锁的一种用法；但是如果你的程序不管三七二十一，在没有对文件上锁的情况下直接访问文件，也是可以访问的，并非无法访问文件；如果是这样，那么建议性锁就没有起到任何作用，如果要使得建议性锁起作用，那么大家就要遵守协议，访问文件之前先对文件上锁。</p>
</li>
<li><p>强制性锁</p>
<p>如果进程对文件上了强制性锁，其它的进程在没有获取到文件锁的情况下是无法对文件进行访问的。其本质原因在于，强制性锁会让内核检查每一个 I/O 操作（譬如 read()、write()），验证调用进程是否是该文件锁的拥有者，如果不是将无法访问文件。</p>
</li>
</ol>
<p><strong>flock</strong></p>
<ol>
<li>同一进程对文件多次加锁不会导致死锁。</li>
<li>文件关闭的时候，会自动解锁。</li>
<li>一个进程不可以对另一个进程持有的文件锁进行解锁。</li>
<li>由 fork()创建的子进程不会继承父进程所创建的锁。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 建议性锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">flock</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> operation)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>fcntl</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 功能很强大，目前只谈论文件锁功能</span></span><br><span class="line"><span class="comment">// cmd: F_GETLK, F_SETLK, F_SETLKW(阻塞版)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct flock {</span></span><br><span class="line"><span class="comment"> ...</span></span><br><span class="line"><span class="comment"> short l_type; // Type of lock: F_RDLCK,F_WRLCK, F_UNLCK</span></span><br><span class="line"><span class="comment"> short l_whence; // How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END</span></span><br><span class="line"><span class="comment"> off_t l_start; // Starting offset for lock</span></span><br><span class="line"><span class="comment"> off_t l_len; // Number of bytes to lock</span></span><br><span class="line"><span class="comment"> pid_t l_pid; // PID of process blocking our lock(set by F_GETLK and F_OFD_GETLK)</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* struct flock *flockptr */</span> )</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>fcntl()可以对文件的某个区域（某部分内容）进行加锁解锁，可以精确到某一个字节数据。</li>
<li>fcntl()可支持建议性锁和强制性锁两种类型</li>
</ul>
<img src="/1fd3d10d/image-20240715225728423.png" class="">

<p>如果要开启强制性锁机制，需要设置文件的 Set-GroupID（S_ISGID）位为 1，并且禁止文件的组用户执行权限（S_IXGRP），也就是将其设置为 0。</p>
<p>有些发行版不支持。</p>
<p><strong>lockf</strong>：对fcntl的封装</p>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>RM装甲板识别</title>
    <url>/158223f0.html</url>
    <content><![CDATA[<p>在Robomaster比赛中，装甲板是机器人得分的主要目标。识别并攻击装甲板可以帮助机器人按照比赛规则得分，同时避免攻击非装甲部位，减少无效攻击和违规行为。通过装甲板识别技术，机器人可以准确地检测并定位敌方机器人，从而进行有效的瞄准和攻击。装甲板通常是对方机器人的关键部位，通过识别这些部位可以提高攻击的命中率。</p>
<span id="more"></span>

<p><strong>装甲板示例图</strong></p>
<img src="/158223f0/test1.png" class="">

<p>config.py中，is_video=0表示是图片识别反之则是视频识别</p>
<p>is_debug=1时显示中间debug文件</p>
<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><ol>
<li>使用语言：Python</li>
<li>项目流程管理：git, docker</li>
<li>训练模型使用的框架：pytorch</li>
<li>识别基本思路：通过装甲板两边的灯条来定位装甲板，再通过数字检测再进行筛选最后得到装甲板的位置（传统识别+深度学习）</li>
</ol>
<p>项目目录</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">│  .gitignore</span><br><span class="line">|  Dockerfile <span class="comment"># 构建镜像</span></span><br><span class="line">|  requirements.txt <span class="comment"># 所需要的包</span></span><br><span class="line">|  test.py <span class="comment"># 测试文件</span></span><br><span class="line">│  config.py <span class="comment"># 配置</span></span><br><span class="line">│  detect.py <span class="comment"># 识别模块</span></span><br><span class="line">│  main.py <span class="comment"># 主程序入口</span></span><br><span class="line">│  readme.md <span class="comment"># 文档</span></span><br><span class="line">│  train.py <span class="comment"># 训练文件</span></span><br><span class="line">│</span><br><span class="line">├─cfg <span class="comment"># 模型文件</span></span><br><span class="line">│</span><br><span class="line">├─datasets <span class="comment"># 数据集</span></span><br><span class="line">│</span><br><span class="line">├─image <span class="comment"># readme图片</span></span><br><span class="line">│</span><br><span class="line">├─testdata 测试数据集</span><br></pre></td></tr></tbody></table></figure>

<h1 id="识别具体实现"><a href="#识别具体实现" class="headerlink" title="识别具体实现"></a>识别具体实现</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>位于config.py中，模型，是否debug，一些参数，类的定义均存在里面</p>
<h2 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h2><p>通过cvtColor和threshold将图片转为二值图片，将目标从背景中分离出来。</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">def preProcess(rgb_img):</span><br><span class="line">    gray = cv.cvtColor(rgb_img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    _, binary = cv.threshold(gray, settings.binary_thres, 255, cv.THRESH_BINARY) #_是阈值 忽略</span><br><span class="line">    return binary</span><br></pre></td></tr></tbody></table></figure>

<h2 id="寻找灯条"><a href="#寻找灯条" class="headerlink" title="寻找灯条"></a>寻找灯条</h2><p>通过 findContours 得到轮廓</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">contours, hierarchy = cv.findContours(binary_img, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></tbody></table></figure>

<p>将轮廓点数小于5的排除掉</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">for contour in contours:</span><br><span class="line">        if len(contour) &lt; 5:</span><br><span class="line">            continue</span><br></pre></td></tr></tbody></table></figure>

<p>对轮廓进行外接矩形并且判定是否是灯条</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">	r_rect = cv.minAreaRect(contour)</span><br><span class="line">        light = Light(r_rect)</span><br><span class="line"></span><br><span class="line">        if is_light(light):</span><br><span class="line"># Light的定义(一小部分)</span><br><span class="line">class Light:</span><br><span class="line">    def __init__(self, box=None):</span><br><span class="line">	self.center = box[0]</span><br><span class="line">        self.size = box[1]</span><br><span class="line">        self.angle = box[2]</span><br><span class="line"></span><br><span class="line">        points = cv.boxPoints(box)</span><br><span class="line">        points = sorted(points, key=lambda p: p[1])</span><br><span class="line"></span><br><span class="line">        self.top = (points[0] + points[1]) / 2</span><br><span class="line">        self.bottom = (points[2] + points[3]) / 2</span><br><span class="line"></span><br><span class="line">        self.length = np.linalg.norm(self.top - self.bottom)</span><br><span class="line">        self.width = np.linalg.norm(points[0] - points[1])</span><br><span class="line"></span><br><span class="line">        self.tilt_angle = atan2(abs(self.top[0] - self.bottom[0]), abs(self.top[1] - self.bottom[1]))</span><br><span class="line">        self.tilt_angle = self.tilt_angle / pi * 180</span><br><span class="line">        self.color = None</span><br></pre></td></tr></tbody></table></figure>

<p>通过统计在给定轮廓内的红色和蓝色像素值的总和，来判断该区域主要的颜色是红色还是蓝色。使用 <code>cv.pointPolygonTest</code>来确保只统计轮廓内部的像素值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sum_r, sum_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">   roi = rbg_img[rect[<span class="number">1</span>]:rect[<span class="number">1</span>]+rect[<span class="number">3</span>], rect[<span class="number">0</span>]:rect[<span class="number">0</span>]+rect[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(roi.shape[<span class="number">0</span>]):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(roi.shape[<span class="number">1</span>]):</span><br><span class="line">   <span class="keyword">if</span> cv.pointPolygonTest(contour, (j + rect[<span class="number">0</span>], i + rect[<span class="number">1</span>]), <span class="literal">False</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">   	sum_b += roi[i, j, <span class="number">0</span>]</span><br><span class="line">   	sum_r += roi[i, j, <span class="number">2</span>]</span><br><span class="line">	light.color = <span class="string">'RED'</span> <span class="keyword">if</span> sum_r &gt; sum_b <span class="keyword">else</span> <span class="string">'BLUE'</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="配对灯条"><a href="#配对灯条" class="headerlink" title="配对灯条"></a>配对灯条</h2><p>根据 <code>detect_color</code> 选择对应颜色的灯条进行两两配对，首先筛除掉两条灯条中间包含另一个灯条的情况，然后根据两灯条的长度之比、两灯条中心的距离、配对出装甲板的倾斜角度来筛选掉条件不满足的结果，得到形状符合装甲板特征的灯条配对（数据根据官方和测量得出）。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">def <span class="title function_">containLight</span><span class="params">(light_1, light_2, lights)</span>:</span><br><span class="line">    # 获取两个光条的顶点和底点坐标</span><br><span class="line">    points = np.<span class="built_in">array</span>([light_1.top, light_1.bottom, light_2.top, light_2.bottom])</span><br><span class="line">    bounding_rect = cv.boundingRect(points)</span><br><span class="line"></span><br><span class="line">    # 遍历所有光条，检查是否有光条被包含在两个光条之间</span><br><span class="line">    <span class="keyword">for</span> test_light in lights:</span><br><span class="line">        <span class="keyword">if</span> np.array_equal(test_light.center, light_1.center) or np.array_equal(test_light.center, light_2.center):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cv.pointPolygonTest(points, (test_light.top[<span class="number">0</span>], test_light.top[<span class="number">1</span>]), False) &gt;= <span class="number">0</span> or</span><br><span class="line">            cv.pointPolygonTest(points, (test_light.bottom[<span class="number">0</span>], test_light.bottom[<span class="number">1</span>]), False) &gt;= <span class="number">0</span> or</span><br><span class="line">            cv.pointPolygonTest(points, (test_light.center[<span class="number">0</span>], test_light.center[<span class="number">1</span>]), False) &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> True</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line">def isArmor(light_1, light_2):</span><br><span class="line">    # 比较两个光条的长度比例（短边 / 长边）</span><br><span class="line">    light_length_ratio = min(light_1.length, light_2.length) / max(light_1.length, light_2.length)</span><br><span class="line">    light_ratio_ok = light_length_ratio &gt; settings.amin_light_ratio</span><br><span class="line"></span><br><span class="line">    # 计算两个光条中心的距离（以光条长度为单位）</span><br><span class="line">    avg_light_length = (light_1.length + light_2.length) / <span class="number">2</span></span><br><span class="line">    center_distance = np.linalg.norm(np.<span class="built_in">array</span>(light_1.center) - np.<span class="built_in">array</span>(light_2.center)) / avg_light_length</span><br><span class="line">    center_distance_ok = (settings.amin_small_center_distance &lt;= center_distance &lt; settings.amax_small_center_distance) or \</span><br><span class="line">                         (settings.amin_large_center_distance &lt;= center_distance &lt; settings.amax_large_center_distance)</span><br><span class="line"></span><br><span class="line">    # 计算光条中心连接线的角度</span><br><span class="line">    diff = np.<span class="built_in">array</span>(light_1.center) - np.<span class="built_in">array</span>(light_2.center)</span><br><span class="line">    angle = degrees(<span class="built_in">abs</span>(<span class="built_in">atan2</span>(diff[<span class="number">1</span>], diff[<span class="number">0</span>])))</span><br><span class="line">    angle_ok = angle &lt; settings.amax_angle</span><br><span class="line"></span><br><span class="line">    # 综合判断是否为装甲板</span><br><span class="line">    is_armor = light_ratio_ok and center_distance_ok and angle_ok</span><br><span class="line"></span><br><span class="line">    # 判断装甲板类型</span><br><span class="line">    <span class="keyword">if</span> is_armor:</span><br><span class="line">        type = <span class="string">'LARGE'</span> <span class="keyword">if</span> center_distance &gt; settings.amin_large_center_distance <span class="keyword">else</span> <span class="string">'SMALL'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        type = <span class="string">'INVALID'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type</span><br></pre></td></tr></tbody></table></figure>

<h2 id="提取数字"><a href="#提取数字" class="headerlink" title="提取数字"></a>提取数字</h2><p>设置好roi，根据灯条的坐标获得装甲板大致的位置，然后使用透视变换截取出数字部分</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">lights_vertices = np.array([armor.left_light.bottom, armor.left_light.top,</span><br><span class="line">                                       armor.right_light.top, armor.right_light.bottom], dtype=np.float32)</span><br><span class="line">           <span class="comment"># 计算变换后图像中灯条顶部和底部的y坐标</span></span><br><span class="line">           top_light_y = (warp_height - light_length) // <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">           bottom_light_y = top_light_y + light_length</span><br><span class="line">           <span class="comment"># 根据装甲板类型确定变换后的图像宽度</span></span><br><span class="line">           warp_width = small_armor_width <span class="keyword">if</span> armor.<span class="built_in">type</span> == <span class="string">'SMALL'</span> <span class="keyword">else</span> large_armor_width</span><br><span class="line">           <span class="comment"># 设置变换后图像的目标顶点位置</span></span><br><span class="line">           target_vertices = np.array([[<span class="number">0</span>, bottom_light_y],</span><br><span class="line">                                       [<span class="number">0</span>, top_light_y],</span><br><span class="line">                                       [warp_width - <span class="number">1</span>, top_light_y],</span><br><span class="line">                                       [warp_width - <span class="number">1</span>, bottom_light_y]], dtype=np.float32)</span><br><span class="line">           <span class="comment"># 计算透视变换矩阵</span></span><br><span class="line">           rotation_matrix = cv.getPerspectiveTransform(lights_vertices, target_vertices)</span><br><span class="line">           <span class="comment"># 应用透视变换，将源图像中的装甲板区域变换到目标顶点位置</span></span><br><span class="line">           number_image = cv.warpPerspective(src, rotation_matrix, (warp_width, warp_height))</span><br><span class="line">           <span class="comment"># 从变换后的图像中提取感兴趣区域（ROI）</span></span><br><span class="line">           x_start = (warp_width - roi_size[<span class="number">0</span>]) // <span class="number">2</span></span><br><span class="line">           x_end = x_start + roi_size[<span class="number">0</span>]</span><br><span class="line">           number_image = number_image[<span class="number">0</span>:roi_size[<span class="number">1</span>], x_start:x_end]</span><br><span class="line">           <span class="comment"># 将图像转换为灰度图像</span></span><br><span class="line">           number_image = cv.cvtColor(number_image, cv.COLOR_RGB2GRAY)</span><br><span class="line">           <span class="comment"># 对灰度图像应用二值化处理</span></span><br><span class="line">           _, number_image = cv.threshold(number_image, <span class="number">0</span>, <span class="number">255</span>, cv.THRESH_BINARY | cv.THRESH_OTSU)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><p>由于MiniPC的性能限制，只是设计了简单的mlp网络用于数字分类</p>
<img src="/158223f0/image-20240626144621090.png" class="">

<p>在训练前对训练集进行处理</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dataset = torchvision.datasets.ImageFolder(</span><br><span class="line">    root=os.path.join(os.path.dirname(__file__), <span class="string">'datasets'</span>),</span><br><span class="line">    transform=torchvision.transforms.Compose([</span><br><span class="line">        torchvision.transforms.Grayscale(num_output_channels=<span class="number">1</span>), <span class="comment"># 灰度化</span></span><br><span class="line">        torchvision.transforms.RandomAffine(</span><br><span class="line">            degrees=(-<span class="number">5</span>, <span class="number">5</span>), translate=(<span class="number">0.08</span>, <span class="number">0.08</span>), scale=(<span class="number">0.9</span>, <span class="number">1.1</span>)), <span class="comment"># 旋转，平移，放缩</span></span><br><span class="line">        torchvision.transforms.ToTensor(),</span><br><span class="line">        torchvision.transforms.RandomErasing(</span><br><span class="line">            scale=(<span class="number">0.02</span>, <span class="number">0.02</span>))</span><br><span class="line">    ]))<span class="comment"># 擦除</span></span><br><span class="line"><span class="comment"># 用ImageFolder表示文件夹为标签名</span></span><br></pre></td></tr></tbody></table></figure>

<p>数据集分为两部分（4:1）训练集和测试集</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">train_dataset, test_dataset = torch.utils.data.random_split(</span><br><span class="line">    dataset, [<span class="built_in">int</span>(<span class="built_in">len</span>(dataset) * <span class="number">0.8</span>), <span class="built_in">len</span>(dataset) - <span class="built_in">int</span>(<span class="built_in">len</span>(dataset) * <span class="number">0.8</span>)])</span><br></pre></td></tr></tbody></table></figure>

<p>损失函数和优化器</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">1e-3</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>训练评估</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        correct = <span class="number">0</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> test_loader:</span><br><span class="line">            x, y = x.to(device), y.to(device)  <span class="comment"># Move data to the device</span></span><br><span class="line">            y_pred = model(x)</span><br><span class="line">            loss = loss_fn(y_pred, y)</span><br><span class="line">            running_val_loss += loss.item()</span><br><span class="line"></span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(y_pred.data, <span class="number">1</span>)</span><br><span class="line">            total += y.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == y).<span class="built_in">sum</span>().item()</span><br><span class="line">        avg_val_loss = running_val_loss / <span class="built_in">len</span>(test_loader)</span><br><span class="line">        accuracy = <span class="number">100</span> * correct / total</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'Epoch: <span class="subst">{epoch + <span class="number">1</span>}</span>, Accuracy: <span class="subst">{accuracy}</span>%'</span>)</span><br><span class="line">        writer.add_scalar(<span class="string">'Accuracy/test'</span>, accuracy, epoch)</span><br><span class="line">        writer.add_scalar(<span class="string">'Loss/val'</span>, avg_val_loss, epoch)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="模型部署"><a href="#模型部署" class="headerlink" title="模型部署"></a>模型部署</h2><p>使用opencv的dnn模块, softmax转换为概率，argmax转换为对应的类别（0 - 5）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">blob = cv.dnn.blobFromImage(image)</span><br><span class="line">self.net.setInput(blob)</span><br><span class="line">outputs = self.net.forward()</span><br><span class="line">outputs = outputs.flatten()</span><br><span class="line">exp_outputs = np.exp(outputs - np.<span class="built_in">max</span>(outputs))</span><br><span class="line">softmax_prob = exp_outputs / np.<span class="built_in">sum</span>(exp_outputs)</span><br><span class="line">confidence = np.<span class="built_in">max</span>(softmax_prob)</span><br><span class="line">label_id = np.argmax(softmax_prob)</span><br><span class="line"></span><br><span class="line">armor.confidence = confidence</span><br><span class="line">armor.number = self.class_names[label_id]</span><br><span class="line"></span><br><span class="line">armor.classification_result = <span class="string">f"<span class="subst">{armor.number}</span>: <span class="subst">{armor.confidence * <span class="number">100.0</span>:<span class="number">.1</span>f}</span>%"</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">docker build -t my-python-image .</span><br><span class="line">docker run -it \</span><br><span class="line">    --name my-python-container \</span><br><span class="line">    --<span class="built_in">env</span>=<span class="string">"DISPLAY"</span> \</span><br><span class="line">    --volume=<span class="string">"/tmp/.X11-unix:/tmp/.X11-unix:rw"</span> \</span><br><span class="line">    --volume=<span class="string">"<span class="subst">$(pwd)</span>:/app"</span> \</span><br><span class="line">    my-python-image</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用前记得</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">xhost +</span><br></pre></td></tr></tbody></table></figure>

<h1 id="PIP安装"><a href="#PIP安装" class="headerlink" title="PIP安装"></a>PIP安装</h1><p>如果不想使用docker部署可以使用</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></tbody></table></figure>

<p>安装所需要的包</p>
<p><strong>PS:</strong></p>
<p>项目基础是从rm_vision改过来的纯Python版本，同时也有ROS C++版的，详见<a href="https://github.com/langou0115/RoboDetect">here</a></p>
]]></content>
      <categories>
        <category>Robomaster</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>


<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>图论</title>
    <url>/10f14ed7.html</url>
    <content><![CDATA[<p>第二难的一个…..</p>
<span id="more"></span>

<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">组合</a></p>
<p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">分割</a></p>
<p><a href="https://leetcode.cn/problems/subsets-ii/description/">子集</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1219">应用</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(...)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(){</span><br><span class="line">       <span class="comment">// 递归终止 </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(){</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(...)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><a href="https://www.luogu.com.cn/problem/P1443">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">bfs</span>(<span class="type">int</span> x, <span class="type">int</span> y){</span><br><span class="line">    queue&lt;Point&gt; que;</span><br><span class="line">    Point s = <span class="built_in">Point</span>(x, y, <span class="number">0</span>);</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()){</span><br><span class="line">        s = que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="keyword">for</span>(...){</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span>(...){</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">Point</span>(s.x, s.y, s.step+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="图的储存"><a href="#图的储存" class="headerlink" title="图的储存"></a>图的储存</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>过于简单….省略</p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p><strong>第一种写法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = ....; <span class="comment">//最大点的数量</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存一个from-&gt;to边的实例</span></span><br><span class="line">cin &gt;&gt; from &gt;&gt; to;</span><br><span class="line">G[from].<span class="built_in">push_back</span>(to);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>第二种写法 链式前向星</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>{</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">} edge[MAXM];</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    edge[++cnt].to = to;</span><br><span class="line">    edge[cnt].val = val;</span><br><span class="line">    edge[cnt].next = head[from];</span><br><span class="line">    head[from] = cnt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="连通问题"><a href="#连通问题" class="headerlink" title="连通问题"></a>连通问题</h1><h2 id="Tarjan求强连通分量"><a href="#Tarjan求强连通分量" class="headerlink" title="Tarjan求强连通分量"></a>Tarjan求强连通分量</h2><p><a href="https://www.luogu.com.cn/problem/P2863">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN]; <span class="comment">// 存储好的图</span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN]; <span class="comment">// dfn为遍历到x点的时间，low表示x点可以回溯到的时间最小的起点</span></span><br><span class="line"><span class="type">int</span> instack[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> tim = <span class="number">1</span>;</span><br><span class="line">    st.<span class="built_in">push</span>(x);</span><br><span class="line">    instack[x] = <span class="number">1</span>;</span><br><span class="line">    dfn[x] = low[n] = tim++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++){</span><br><span class="line">        <span class="type">int</span> j = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j]){</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[j]);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(instack[j]){</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[x] == low[x]){</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">do</span>{</span><br><span class="line">            tmp = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            instack[tmp] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// todo</span></span><br><span class="line">        }<span class="keyword">while</span>(tmp != x);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="利用Tarjan进行缩点"><a href="#利用Tarjan进行缩点" class="headerlink" title="利用Tarjan进行缩点"></a>利用Tarjan进行缩点</h2><p><a href="https://www.luogu.com.cn/problem/P3387">模板</a></p>
<p>将强连通分量缩成一个点，变成有向无环图（DAG）</p>
<p><strong>template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> degree[MAXN]; <span class="comment">// 有向无环图每个点的入度</span></span><br><span class="line"><span class="type">int</span> tb[MAXN], tb_a[MAXN], cnt = <span class="number">1</span>, times = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// tb记录原来的点映射到新的点是什么， tb_a记录新的点所花费的时间, cnt记录新点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	dfn[x] = low[x] = times++;</span><br><span class="line">	instack[x] = <span class="number">1</span>;</span><br><span class="line">	s.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++){</span><br><span class="line">		<span class="type">int</span> y = G[x][i];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y]){</span><br><span class="line">			<span class="built_in">tarjan</span>(y);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(instack[y]){</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	 <span class="comment">// 重点在此</span></span><br><span class="line">	<span class="keyword">if</span>(dfn[x] == low[x]){</span><br><span class="line">		<span class="type">int</span> tmp;</span><br><span class="line">		<span class="keyword">do</span>{</span><br><span class="line">			tmp = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">			instack[tmp] = <span class="number">0</span>;</span><br><span class="line">			tb[tmp] = cnt;</span><br><span class="line">			tb_a[cnt] += a[tmp];</span><br><span class="line">		}<span class="keyword">while</span>(tmp != x);</span><br><span class="line">		dp[cnt] = tb_a[cnt];</span><br><span class="line">		cnt++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); j++){</span><br><span class="line">			<span class="type">int</span> y = G[i][j];</span><br><span class="line">			<span class="keyword">if</span>(tb[i] != tb[y]){ <span class="comment">// 映射点相同不做处理</span></span><br><span class="line">				TG[tb[i]].<span class="built_in">push_back</span>(tb[y]);</span><br><span class="line">				indegree[tb[y]]++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Tarjan求割点和桥"><a href="#Tarjan求割点和桥" class="headerlink" title="Tarjan求割点和桥"></a>Tarjan求割点和桥</h2><p><a href="https://www.luogu.com.cn/problem/P3388">模板割点</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1656">模板桥</a></p>
<blockquote>
<p><strong>ps: 无向图中不考虑儿子到父亲的边</strong></p>
</blockquote>
<p><strong>割点</strong>：去除后图不能连通的点</p>
<p><strong>桥</strong>：去除后图不能连通的边</p>
<p><strong>割点条件</strong>：</p>
<ol>
<li>非root点 &amp;&amp; 有儿子 &amp;&amp; low[x儿子] &gt;= dfn[x]</li>
<li>root点 &amp;&amp; 有两个及以上的儿子</li>
</ol>
<p><strong>x-&gt;y是桥条件</strong>：</p>
<p>low[y] &gt; dfn[x]</p>
<p><strong>template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], root, ans[MAXN], fa[MAXN]; <span class="comment">// fa[x]为0时, x为根节点</span></span><br><span class="line"><span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dfn[x] = low[x] = time++;</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++){</span><br><span class="line">        <span class="type">int</span> y = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y]){</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            child++;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(!fa[x] &amp;&amp; child &gt;= <span class="number">2</span>) ans[x] = <span class="number">1</span>; <span class="comment">// 割点条件一，会重复运行这一句</span></span><br><span class="line">            <span class="keyword">if</span>(fa[x] &amp;&amp; low[y] &gt;= dfn[x]) ans[x] = <span class="number">1</span>; <span class="comment">// 割点条件二，会重复运行这一句</span></span><br><span class="line">            <span class="keyword">if</span>(low[y] &gt; dfn[x]) ... <span class="comment">// 桥的条件</span></span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(fa[x] != y){</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]){</span><br><span class="line">        <span class="built_in">tarjan</span>(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><a href="https://www.luogu.com.cn/problem/P4779">模板</a></p>
<p><strong>本质还是贪心算法</strong></p>
<p>储存使用<strong>链式前向星</strong></p>
<p>适用于<strong>非负权边图</strong>，求最短路径</p>
<p>一定要使用<strong>优先队列</strong>！！！！</p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>{</span><br><span class="line">	<span class="type">int</span> to, val, next;</span><br><span class="line">}edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	edge[++cnt] = {to, val, head[from]};</span><br><span class="line">	head[from] = cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>{</span><br><span class="line">	<span class="type">int</span> pos;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; node) <span class="type">const</span>{</span><br><span class="line">		<span class="keyword">return</span> d &gt; node.d;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="comment">// int vis[MAXN];</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>({s, <span class="number">0</span>});</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">		Node x = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> pos = x.pos;</span><br><span class="line">		<span class="keyword">if</span>(dis[pos] &lt; x.d) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = head[pos]; i; i = edge[i].next){</span><br><span class="line">			<span class="type">int</span> y = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[y] &gt; dis[pos] + edge[i].val){</span><br><span class="line">				dis[y] = dis[pos] + edge[i].val;</span><br><span class="line">				q.<span class="built_in">push</span>({y, dis[y]});</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="type">int</span> from, to, val;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">		<span class="built_in">add_edge</span>(from, to, val);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dijkstra</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cout &lt;&lt; dis[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p><a href="https://www.luogu.com.cn/problem/B3647">模板</a></p>
<p><strong>求多源最短路径</strong></p>
<p>存储使用<strong>邻接矩阵</strong></p>
<p>不适用图中<strong>带负边的环</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">105</span>; </span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> G[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++){</span><br><span class="line">			<span class="keyword">if</span>(i != j) G[i][j] = INF;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> from, to, val;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">		G[from][to] = <span class="built_in">min</span>(G[from][to], val);</span><br><span class="line">		G[to][from] = <span class="built_in">min</span>(G[to][from], val);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++){</span><br><span class="line">				<span class="keyword">if</span>(G[i][k] &lt; INF &amp;&amp; G[k][j] &lt; INF)</span><br><span class="line">					G[i][j] = <span class="built_in">min</span>(G[i][j], G[i][k] + G[k][j]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;= n; j++){</span><br><span class="line">			cout &lt;&lt; G[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman Ford算法"></a>Bellman Ford算法</h2><p><strong>求单源最短路径</strong></p>
<p>使用<strong>三元组</strong>来储存图（存边）</p>
<p>可用于负权边图，但不适用负环路图</p>
<p>可检测负环路图</p>
<p>时间复杂度不如Dijkstra算法好</p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> u[MAXM], v[MAXM], w[MAXM];</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++){</span><br><span class="line">		<span class="type">int</span> check = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++){</span><br><span class="line">			<span class="keyword">if</span>(dis[v[j]] &gt;= dis[u[j]] + w[j]){</span><br><span class="line">				dis[v[j]] = dis[u[j]] + w[j];</span><br><span class="line">				check = <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!check) <span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">// 再进行一次循环，若有更新就可以判断有负权边</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i] = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bellman_ford</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cout &lt;&lt; dis[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p><a href="https://www.luogu.com.cn/problem/P3385">模板</a></p>
<p>是Bellman Ford算法的优化</p>
<p>可用来判断图中是否有负环</p>
<p>使用<strong>链式前向星</strong>来储存图</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>, M = <span class="number">6e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>{</span><br><span class="line">	<span class="type">int</span> to, val, next;</span><br><span class="line">}edge[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	edge[++tot] = {to, val, head[from]};</span><br><span class="line">	head[from] = tot;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N], vis[N], cnt[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edge[i].next){</span><br><span class="line">			<span class="type">int</span> y = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[y] &gt; dis[x] + edge[i].val){</span><br><span class="line">				dis[y] = dis[x] + edge[i].val;</span><br><span class="line">				cnt[y] = cnt[x] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(cnt[y] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span>(!vis[y]){</span><br><span class="line">					q.<span class="built_in">push</span>(y);</span><br><span class="line">					vis[y] = <span class="number">1</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--){</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		tot = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">			<span class="type">int</span> from, to, val;</span><br><span class="line">			cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">			<span class="built_in">add_edge</span>(from, to, val);</span><br><span class="line">			<span class="keyword">if</span>(val &gt;= <span class="number">0</span>) <span class="built_in">add_edge</span>(to, from, val); </span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="type">bool</span> res = <span class="built_in">SPFA</span>();</span><br><span class="line">		<span class="keyword">if</span>(res) cout &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><a href="https://www.luogu.com.cn/problem/P3367">模板</a></p>
<p>将不同的元素放在同一个集合进行区分</p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(fa[x] == x){</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">		<span class="keyword">return</span> fa[x];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">	fa[y] = x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		<span class="type">int</span> z, x, y;</span><br><span class="line">		cin &gt;&gt; z &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="comment">// z为1表示合并，z为2表示查询是否在一个集合</span></span><br><span class="line">		<span class="keyword">if</span>(z == <span class="number">1</span>){</span><br><span class="line">			<span class="built_in">join</span>(x, y);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(z == <span class="number">2</span>){</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) cout &lt;&lt; <span class="string">"Y\n"</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">"N\n"</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><a href="https://www.luogu.com.cn/problem/P3366">模板</a></p>
<p>n个点，n-1条边，边的权值和最小</p>
<h2 id="Kruscal算法"><a href="#Kruscal算法" class="headerlink" title="Kruscal算法"></a>Kruscal算法</h2><p>适用于无向图，将边按小到大进行排列，依次选择，成环就丢弃，直到边的数量为n - 1条</p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>, M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>{</span><br><span class="line">	<span class="type">int</span> u, v, z; </span><br><span class="line">}edge[M];</span><br><span class="line"><span class="type">int</span> n, m, fa[N], cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 并查集操作 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(fa[x] == x){</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">		<span class="keyword">return</span> fa[x];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> f_x = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> f_y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(f_x == f_y) <span class="keyword">return</span>;</span><br><span class="line">	fa[f_x] = f_y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruscal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">sort</span>(edge, edge + m, [](Edge e1, Edge e2){</span><br><span class="line">		<span class="keyword">return</span> e1.z &lt; e2.z;</span><br><span class="line">	});</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> u = edge[i].u, v = edge[i].v;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(u) == <span class="built_in">find</span>(v)) <span class="keyword">continue</span>; <span class="comment">// 成环就丢弃</span></span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">join</span>(u, v);</span><br><span class="line">			ans += edge[i].z;</span><br><span class="line">			cnt++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].z;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kruscal</span>();</span><br><span class="line">	<span class="keyword">if</span>(cnt == n - <span class="number">1</span>) cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">"orz"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>update….</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法</title>
    <url>/2cc2fa98.html</url>
    <content><![CDATA[<p>蓝桥杯之前进行的一些算法小总结，本文只写了一些简单的算法，图论，树论，动态规划，排序请看该站算法目录下的…..</p>
<span id="more"></span>


<h1 id="C-小技巧"><a href="#C-小技巧" class="headerlink" title="C++小技巧"></a>C++小技巧</h1><h2 id="重定义比较器"><a href="#重定义比较器" class="headerlink" title="重定义比较器"></a>重定义比较器</h2><ul>
<li><strong>lambda变量</strong><br><strong>[=]捕获变量值</strong><br><strong>[&amp;]捕获变量引用</strong></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> {</span><br><span class="line"> &nbsp; &nbsp;std::string name;</span><br><span class="line"> &nbsp; &nbsp;<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"> &nbsp; &nbsp;<span class="built_in">Person</span>(std::string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) {}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> &nbsp; &nbsp;<span class="function">Person <span class="title">alice</span><span class="params">(<span class="string">"Alice"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"> &nbsp; &nbsp;<span class="function">Person <span class="title">bob</span><span class="params">(<span class="string">"Bob"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> &nbsp; &nbsp;<span class="comment">// 使用 lambda 表达式比较两个 Person 对象的年龄</span></span><br><span class="line"> &nbsp; &nbsp;Person older = std::<span class="built_in">max</span>(alice, bob, [](<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line"> &nbsp;  });</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>比较器</strong></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> {</span><br><span class="line">  std::string name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Person</span>(std::string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较器函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareByAge</span><span class="params">(<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="function">Person <span class="title">alice</span><span class="params">(<span class="string">"Alice"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">bob</span><span class="params">(<span class="string">"Bob"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用比较器函数</span></span><br><span class="line">  Person older = std::<span class="built_in">max</span>(alice, bob, compareByAge);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><strong>优先队列（堆）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{</span><br><span class="line">            <span class="comment">// 注意这里！！！！！</span></span><br><span class="line">    	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 对于类 重写 bool operator&lt;(const Node&amp;) const{}即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> weigh; </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; apples;</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">8</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"> &nbsp; &nbsp; <span class="comment">// output: 1 2 3 4 8 9</span></span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>对于pair&lt;int,int&gt; 优先比较first</strong></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><table>
<thead>
<tr>
<th><strong>常用</strong></th>
<th><strong>map</strong></th>
<th><strong>multiply_map</strong></th>
<th><strong>unordered_map</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层原理</strong></td>
<td><strong>红黑树</strong></td>
<td><strong>红黑树</strong></td>
<td><strong>哈希表</strong></td>
</tr>
<tr>
<td><strong>时间复杂度（查找）</strong></td>
<td><strong>O(logn)</strong></td>
<td><strong>O(logn)</strong></td>
<td><strong>O(1)</strong></td>
</tr>
<tr>
<td><strong>是否有序</strong></td>
<td><strong>有序</strong></td>
<td><strong>有序</strong></td>
<td><strong>无序</strong></td>
</tr>
</tbody></table>
<p><strong>一般使用unordere_map</strong></p>
<h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p><strong>去重</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">unique</span>(a, a + n); <span class="comment">// 返回去重后数组的最后一个元素的后一个迭代器</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + k, vec.<span class="built_in">end</span>() <span class="comment">/*, lamda*/</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>将数组中第k + 1大的元素放到vec[k]的位置上</strong></p>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用欧几里得算法计算最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">while</span> (b != <span class="number">0</span>) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;a %= b;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="built_in">swap</span>(a, b);</span><br><span class="line"> &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>容斥原理</strong>：<ul>
<li>计算小于等于<code>x</code> 的丑数的数量，即可以被 <code>a</code> 或 <code>b</code> 或 <code>c</code> 整除的数的数量。</li>
<li>这可以通过以下公式计算：<br>count= 𝑥 / 𝑎+𝑥 / 𝑏+𝑥 / 𝑐−𝑥 / lcm(𝑎,𝑏)−𝑥 / lcm(𝑎,𝑐)−𝑥 / lcm(𝑏,𝑐)+𝑥 / lcm(𝑎,𝑏,𝑐)</li>
<li>其中，<code>lcm</code> 表示最小公倍数。</li>
</ul>
</li>
</ol>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Question:</span></span><br><span class="line"><span class="comment">// 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> &nbsp; &nbsp;<span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;height.<span class="built_in">insert</span>(height.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;height.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()]){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> tmp = st.<span class="built_in">top</span>();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st.<span class="built_in">pop</span>();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">if</span>(!st.<span class="built_in">empty</span>()){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> h = <span class="built_in">min</span>(height[st.<span class="built_in">top</span>()], height[i]) - height[tmp];</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans += h * w;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st.<span class="built_in">push</span>(i);</span><br><span class="line"> &nbsp; &nbsp; &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">return</span> ans;</span><br><span class="line"> &nbsp;  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p><a href="https://www.luogu.com.cn/problem/P1886">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; maxq;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; minq;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> arr[N], min_ans[N], max_ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(!maxq.<span class="built_in">empty</span>() &amp;&amp; maxq.<span class="built_in">back</span>() &lt; x){</span><br><span class="line">		maxq.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">    maxq.<span class="built_in">push_back</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!minq.<span class="built_in">empty</span>() &amp;&amp; minq.<span class="built_in">back</span>() &gt; x){</span><br><span class="line">        minq.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">    minq.<span class="built_in">push_back</span>(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(maxq.<span class="built_in">front</span>() == x) maxq.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">if</span>(minq.<span class="built_in">front</span>() == x) minq.<span class="built_in">pop_front</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_min</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> minq.<span class="built_in">front</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> maxq.<span class="built_in">front</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++){</span><br><span class="line">    	<span class="built_in">push</span>(arr[i]);</span><br><span class="line">    }</span><br><span class="line">    min_ans[<span class="number">0</span>] = <span class="built_in">get_min</span>();</span><br><span class="line">    max_ans[<span class="number">0</span>] = <span class="built_in">get_max</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = k;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n){</span><br><span class="line">        <span class="built_in">pop</span>(arr[i++]);</span><br><span class="line">        <span class="built_in">push</span>(arr[j++]);</span><br><span class="line">        min_ans[i] = <span class="built_in">get_min</span>();</span><br><span class="line">        max_ans[i] = <span class="built_in">get_max</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - k; i++){</span><br><span class="line">    	cout &lt;&lt; min_ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - k; i++){</span><br><span class="line">    	cout &lt;&lt; max_ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h1><p><a href="https://www.luogu.com.cn/problem/P2249">二分查找模板</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2678">二分答案模板</a></p>
<p><strong>upper_bound 找到首个大于的迭代器</strong></p>
<p><strong>lower_bound 找到首个不小于的迭代器</strong></p>
<p><strong>最小的….的最大….一般想到用二分答案</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right){</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">judge</span>(mid)){</span><br><span class="line">        ans = mid;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p><a href="https://www.luogu.com.cn/problem/P8218">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 保证数组第一个元素为0，即arr[0] = 0, prefix[0] = 0</span></span><br><span class="line">arr[<span class="number">10000</span>]; <span class="comment">//数据</span></span><br><span class="line">prefix[<span class="number">10000</span>]; <span class="comment">//前缀和</span></span><br><span class="line">prefix[i] = prefix[i - <span class="number">1</span>] + arr[i]; <span class="comment">// 初始化前缀和数组</span></span><br><span class="line"><span class="comment">// l - r的前缀和即为</span></span><br><span class="line">ans = prefix[r] - prefix[l - <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure>

<h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><p><a href="https://www.luogu.com.cn/problem/P2367">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>.....</span><br><span class="line">	d[i] = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 假设a - b段arr加1</span></span><br><span class="line">d[a]++; <span class="comment">// a后面所有都受到了影响...</span></span><br><span class="line">d[b+<span class="number">1</span>]--; <span class="comment">// 终止b+1后面受到的影响...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将加1使用到arr上</span></span><br><span class="line"><span class="keyword">for</span>.....</span><br><span class="line">	arr[i] = d[i] + arr[i - <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure>

<p><strong>扩展(二维模式)</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 可以画一个图看一下</span></span><br><span class="line"><span class="comment">// (x1, y1) - (x2, y2)进行了操作</span></span><br><span class="line">d[x][y1]++; <span class="comment">// x从x1到x2</span></span><br><span class="line">d[x][y2 + <span class="number">1</span>]--; <span class="comment">// x上同</span></span><br><span class="line"></span><br><span class="line">mmap[x][y] = mmap[x][y - <span class="number">1</span>] + d[x][y]; <span class="comment">//按行扫描 </span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p><strong>应用范围: 数组空间无限大，只关注相对距离的问题</strong></p>
<p><strong>template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 范围为1 ~ 10^9，但只用到了10^5个数</span></span><br><span class="line">a[<span class="number">10005</span>]; <span class="comment">// 存储下标</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(a, a + n) - a; <span class="comment">//去重并获得新的去重数组的长度</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p><a href="https://www.luogu.com.cn/problem/P3375">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">string s1, s2;</span><br><span class="line"><span class="type">int</span> nxt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nxt</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s2.<span class="built_in">size</span>(); i++){</span><br><span class="line">		<span class="keyword">while</span>(s2[j] != s2[i] &amp;&amp; j &gt; <span class="number">0</span>){</span><br><span class="line">			j = nxt[j - <span class="number">1</span>];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(s2[i] == s2[j]) j++;</span><br><span class="line">		nxt[i] = j;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">	<span class="built_in">get_nxt</span>();</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; s1.<span class="built_in">size</span>()){</span><br><span class="line">		<span class="keyword">if</span>(s1[i] == s2[j]){</span><br><span class="line">			i++, j++;</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			<span class="keyword">if</span>(j &gt; <span class="number">0</span>) j = nxt[j - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) i++;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(j == s2.<span class="built_in">size</span>()){</span><br><span class="line">			cout &lt;&lt; i - s2.<span class="built_in">size</span>() + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">			j = nxt[j - <span class="number">1</span>];</span><br><span class="line">		} </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s2.<span class="built_in">size</span>(); i++){</span><br><span class="line">		cout &lt;&lt; nxt[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<p>Update: 水了个国二😆</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树论</title>
    <url>/b8c50a86.html</url>
    <content><![CDATA[<p>最难的一集…..</p>
<span id="more"></span>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p><a href="https://www.luogu.com.cn/problem/P3374">模板1</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3368">模板2</a></p>
<p><strong>对于单点改变的题目，求动态区间和</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int n, m, tree[N];</span><br><span class="line"></span><br><span class="line">int lowbit(int x){</span><br><span class="line">	return x &amp; (-x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void update(int loc, int k){</span><br><span class="line">	while(loc &lt;= n){</span><br><span class="line">		tree[loc] += k;</span><br><span class="line">		loc += lowbit(loc);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int query(int loc){</span><br><span class="line">	int ans = 0;</span><br><span class="line">	while(loc){</span><br><span class="line">		ans += tree[loc];</span><br><span class="line">		loc -= lowbit(loc);</span><br><span class="line">	}</span><br><span class="line">	return ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现差分数组</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	}</span><br><span class="line">	for(int i = 1; i &lt;= m; i++){</span><br><span class="line">		int a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		if(a == 1){</span><br><span class="line">			int x, y, k;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">			update(x, k);</span><br><span class="line">			update(y + 1, -k);</span><br><span class="line">		}</span><br><span class="line">		if(a == 2){</span><br><span class="line">			int x;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			cout &lt;&lt; arr[x] + query(x) &lt;&lt; '\n';</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><p><a href="https://www.luogu.com.cn/problem/P3379">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 5e5 + 5;</span><br><span class="line">int n, m, s;</span><br><span class="line"></span><br><span class="line">int dep[N];</span><br><span class="line">int jump[N][20];</span><br><span class="line">vector&lt;int&gt; G[N];</span><br><span class="line">void dfs(int x, int fa)</span><br><span class="line">{</span><br><span class="line">	jump[x][0] = fa;</span><br><span class="line">	dep[x] = dep[fa] + 1;</span><br><span class="line">	for(int i = 1; i &lt; 20; i++){</span><br><span class="line">		jump[x][i] = jump[jump[x][i - 1]][i - 1];</span><br><span class="line">	}</span><br><span class="line">	for(int i = 0; i &lt; G[x].size(); i++){</span><br><span class="line">		int y = G[x][i];</span><br><span class="line">		if(y != fa){</span><br><span class="line">			dfs(y, x);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">int LCA(int x, int y){</span><br><span class="line">	if(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">	while(dep[x] &gt; dep[y]){</span><br><span class="line">		x = jump[x][(int)log2(dep[x] - dep[y])];</span><br><span class="line">	}</span><br><span class="line">	if(x == y) return x;</span><br><span class="line">	for(int i = log2(dep[x]); i &gt;= 0; i--){</span><br><span class="line">		if(jump[x][i] != jump[y][i]){</span><br><span class="line">			x = jump[x][i];</span><br><span class="line">			y = jump[y][i];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	return jump[x][0];</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	int x, y;</span><br><span class="line">	for(int i = 0; i &lt; n - 1; i++){</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		G[x].push_back(y);</span><br><span class="line">		G[y].push_back(x);</span><br><span class="line">	}</span><br><span class="line">	dfs(s, 0);</span><br><span class="line">	for(int i = 0; i &lt; m; i++){</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		int ans = LCA(x, y);</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; '\n';</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p><strong>两次dfs，但是好像还是有点问题，待更正……</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5 + 5;</span><br><span class="line">struct Edge{</span><br><span class="line">	int v, w, next;</span><br><span class="line">}edge[N];</span><br><span class="line"></span><br><span class="line">// 链式前向星 </span><br><span class="line">int head[N];</span><br><span class="line">int cnt;</span><br><span class="line">void add_edge(int u, int v, int w){</span><br><span class="line">	edge[++cnt].v = v;</span><br><span class="line">	edge[cnt].w = w;</span><br><span class="line">	edge[cnt].next = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int n, vis[N], fa[N];</span><br><span class="line">ll dis[N];</span><br><span class="line">void dfs(int x, int d, int&amp; fnode){</span><br><span class="line">	vis[x] = 1;</span><br><span class="line">	dis[x] = d;</span><br><span class="line">	for(int i = head[x]; i; i = edge[i].next){</span><br><span class="line">		int y = edge[i].v;</span><br><span class="line">		int w = edge[i].w;</span><br><span class="line">		if(!vis[y]){</span><br><span class="line">			fa[y] = x;</span><br><span class="line">			dfs(y, d + w, fnode);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	if(d &gt; dis[fnode]){</span><br><span class="line">		fnode = x;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int u, v, w;</span><br><span class="line">	for(int i = 1; i &lt;= n - 1; i++){</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		add_edge(u, v, w);</span><br><span class="line">		add_edge(v, u, w);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	int fnode = 1;</span><br><span class="line">	dfs(1, 0, fnode);</span><br><span class="line"></span><br><span class="line">	int o_fnode = fnode;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	dfs(fnode, 0, o_fnode);</span><br><span class="line"></span><br><span class="line">	ll diameter = dis[o_fnode];</span><br><span class="line">	cout &lt;&lt; diameter &lt;&lt; '\n';</span><br><span class="line"></span><br><span class="line">	// 记录路径上的边</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int node = o_fnode;</span><br><span class="line">    while (node != fnode) {</span><br><span class="line">        node = fa[node];</span><br><span class="line">        cnt++;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; cnt - 1;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>update….</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/b2626942.html</url>
    <content><![CDATA[<p>背包九讲经典问题！！！</p>
<span id="more"></span>

<p><strong>DP做题顺序</strong></p>
<ol>
<li><strong>确定dp数组（dp table）以及下标的含义</strong></li>
<li><strong>确定递推公式</strong></li>
<li><strong>dp数组如何初始化</strong></li>
<li><strong>确定遍历顺序</strong></li>
<li><strong>举例推导dp数组</strong></li>
</ol>
<blockquote>
<p><strong>以下背包均用一维数组来完成</strong></p>
<p><strong>多少种方法</strong> <code>dp[j] += dp[j - num[i]]</code></p>
</blockquote>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h2><p><a href="https://www.acwing.com/problem/content/2/">模板</a></p>
<p><strong>二维数组推算公式</strong> <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动数组法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">int</span> w[<span class="number">10000</span>], v[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10000</span>]; <span class="comment">// 0 - n</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 先遍历物品，再遍历容量，容量要倒序遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= w[i]; --j){</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p><a href="https://www.acwing.com/problem/content/3/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line">ll w[<span class="number">10000</span>], v[<span class="number">10000</span>];</span><br><span class="line">ll dp[<span class="number">10000</span>]; <span class="comment">// 0 - n</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 与01背包问题不同，容量按照正序遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = w[i]; j &lt;= n; ++j){</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p><a href="https://www.luogu.com.cn/problem/P1776">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, MAXW = <span class="number">4e4</span> + <span class="number">5</span>; <span class="comment">// 开大一点建议....</span></span><br><span class="line"><span class="type">int</span> n, W;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[MAXW];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; W;</span><br><span class="line">	<span class="type">int</span> v_val, w_val, m_val;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; v_val &gt;&gt; w_val &gt;&gt; m_val;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m_val; k &lt;&lt;= <span class="number">1</span>){</span><br><span class="line">            <span class="comment">// 二进制优化</span></span><br><span class="line">			v[++cnt] = k * v_val;</span><br><span class="line">			w[cnt] = k * w_val;</span><br><span class="line">			m_val -= k;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(m_val &gt; <span class="number">0</span>){</span><br><span class="line">			v[++cnt] = m_val * v_val;</span><br><span class="line">			w[cnt] = m_val * w_val;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = W; j &gt;= w[i]; j--){</span><br><span class="line">				dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[W];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="有依赖背包问题"><a href="#有依赖背包问题" class="headerlink" title="有依赖背包问题"></a>有依赖背包问题</h2><p><a href="https://www.luogu.com.cn/problem/P1064">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3.2e4</span> + <span class="number">5</span>, M = <span class="number">65</span>;</span><br><span class="line"><span class="type">int</span> cost[M], val[M], king[M], fans[M];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; follow;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	follow.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> v, belong;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; cost[i] &gt;&gt; v &gt;&gt; belong;</span><br><span class="line">		val[i] = v * cost[i];</span><br><span class="line">		<span class="keyword">if</span>(belong == <span class="number">0</span>) king[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			fans[belong]++;</span><br><span class="line">			follow[belong].<span class="built_in">push_back</span>(i);</span><br><span class="line">		} </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, fan1, fan2; i &lt;= m; i++){</span><br><span class="line">		<span class="keyword">if</span>(king[i]){</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= cost[i]; j--){</span><br><span class="line">					dp[j] = <span class="built_in">max</span>(dp[j - cost[i]] + val[i], dp[j]);</span><br><span class="line">					fan1 = fans[i] &gt;= <span class="number">1</span>? follow[i][<span class="number">0</span>]: <span class="number">-1</span>;</span><br><span class="line">					fan2 = fans[i] &gt;= <span class="number">2</span>? follow[i][<span class="number">1</span>]: <span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">if</span>(fan1 != <span class="number">-1</span> &amp;&amp; j &gt;= cost[i] + cost[fan1]){</span><br><span class="line">						dp[j] = <span class="built_in">max</span>(dp[j - cost[i] - cost[fan1]] + val[i] + val[fan1], dp[j]);</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">if</span>(fan1 != <span class="number">-1</span> &amp;&amp; j &gt;= cost[i] + cost[fan2]){</span><br><span class="line">						dp[j] = <span class="built_in">max</span>(dp[j - cost[i] - cost[fan2]] + val[i] + val[fan2], dp[j]);</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">if</span>(fan1 != <span class="number">-1</span> &amp;&amp; fan2 != <span class="number">-1</span> &amp;&amp; j &gt;= cost[i] + cost[fan1] + cost[fan2]){</span><br><span class="line">						dp[j] = <span class="built_in">max</span>(dp[j - cost[i] - cost[fan1] - cost[fan2]] + val[i] + val[fan1] + val[fan2], dp[j]);</span><br><span class="line">					}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><p><a href="https://www.luogu.com.cn/problem/P1757">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, M = <span class="number">1005</span>;</span><br><span class="line">ll dp[M];</span><br><span class="line"><span class="type">int</span> w[N], v[N], t[N]; <span class="comment">// t--&gt;分组 </span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; t[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">1</span>, end = <span class="number">2</span>; start &lt;= n; ){</span><br><span class="line">		<span class="keyword">while</span>(t[end] == t[end - <span class="number">1</span>] &amp;&amp; end &lt;= n){</span><br><span class="line">			end++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--){</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = start; k &lt; end; k++){</span><br><span class="line">				<span class="keyword">if</span>(j - w[k] &gt;= <span class="number">0</span>) dp[j] = <span class="built_in">max</span>(dp[j - w[k]] + v[k], dp[j]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		start = end++;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; dp[m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><p><a href="https://www.acwing.com/problem/content/7/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, V = <span class="number">1e5</span> + <span class="number">5</span>; <span class="comment">//要开大一点.....</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[V];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="type">int</span> a, b, s;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span>(s == <span class="number">-1</span>) s = <span class="number">1</span>; <span class="comment">// 01转换为多重</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">0</span>) s = m / a; <span class="comment">// 完全转换为多重...</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k *= <span class="number">2</span>){</span><br><span class="line">			v[++cnt] = k * a;</span><br><span class="line">			w[cnt] = k * b;</span><br><span class="line">			s -= k;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(s &gt; <span class="number">0</span>){</span><br><span class="line">			v[++cnt] = s * a;</span><br><span class="line">			w[cnt] = s * b;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--){</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; dp[m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><p><a href="https://www.acwing.com/problem/content/8/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, V = <span class="number">105</span>, M = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> v[N], m[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[V][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> a, b, c;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++){</span><br><span class="line">		cin &gt;&gt; v[i] &gt;&gt; m[i] &gt;&gt; w[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = b; j &gt;= v[i]; j--){</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = c; k &gt;= m[i]; k--){</span><br><span class="line">				dp[j][k] = <span class="built_in">max</span>(dp[j][k], dp[j - v[i]][k - m[i]] + w[i]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[b][c];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/a444b428.html</url>
    <content><![CDATA[<p>排序算法中的一些思想可以用于解决一些题目，例如逆序对等….</p>
<span id="more"></span>

<h1 id="归并排序-分治算法"><a href="#归并排序-分治算法" class="headerlink" title="归并排序(分治算法)"></a>归并排序(分治算法)</h1><p><a href="https://www.luogu.com.cn/problem/P1908">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span></span>{</span><br><span class="line">	<span class="type">int</span> n1 = mid - l + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> n2 = r - mid;</span><br><span class="line">	<span class="type">int</span> larr[n1], rarr[n2];</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n1; i++){</span><br><span class="line">		larr[i] = arr[i + l];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n2; j++){</span><br><span class="line">		rarr[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">	}</span><br><span class="line">	i = <span class="number">0</span>, j = <span class="number">0</span>, k = l;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2){</span><br><span class="line">		<span class="keyword">if</span>(larr[i] &gt; rarr[j]){</span><br><span class="line">			arr[k++] = rarr[j++];</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			arr[k++] = larr[i++];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n1) arr[k++] = larr[i++];</span><br><span class="line">	<span class="keyword">while</span>(j &lt; n2) arr[k++] = rarr[j++];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(l &lt; r){</span><br><span class="line">		<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mergesort</span>(l, mid);</span><br><span class="line">		<span class="built_in">mergesort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">merge</span>(l, mid, r);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">mergesort</span>(<span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>update….</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
