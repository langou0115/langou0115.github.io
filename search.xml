<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux文件IO</title>
    <url>/1f3f638f.html</url>
    <content><![CDATA[<p>在Linux中，对文件进行I/O操作是指对文件执行输入（Input）和输出（Output）操作。这些操作包括打开文件、读取文件内容、写入数据到文件、关闭文件等。文件I/O操作是通过系统调用实现的，这些系统调用提供了一组标准接口，使得程序可以与操作系统交互，进行文件操作。</p>
<span id="more"></span>

<h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>read, write, lseek, perror, strerror, truncate(截断), ftruncate(截断), fcntl(文件描述符操作)</p>
<p>ioctl(一般用于操作特殊文件或硬件外设，后期介绍)</p>
<p>linux中0，1，2表示标准输入、标准输出和标准错误，文件分配符fd不会取到这三个值</p>
<p>详情可使用<code>man 2 read/write/lseek...</code>查看</p>
<h2 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h2><p><code>errno</code>表示错误对应的标号需要<code>#include &lt;errno.h&gt;</code></p>
<p><code>strerr(errno)</code>打印出错误信息</p>
<p><code>perror()</code>直接打印</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>多次open()和dup()复制的区别</p>
<ol>
<li><p>多次open()</p>
<img src="/1f3f638f/image-20240624230432725.png" class="">
</li>
<li><p>dup(), dup2()复制</p>
<img src="/1f3f638f/image-20240624230350781.png" class=""></li>
</ol>
<p>可以看出多次open()的fd会指向不同的文件表，不同文件表指向同一个inode节点，而dup(), dup2()指向一个文件表</p>
<h3 id="三种实现方法"><a href="#三种实现方法" class="headerlink" title="三种实现方法"></a>三种实现方法</h3><ol>
<li><p>同一个进程中多次调用 open 函数打开同一个文件</p>
<img src="/1f3f638f/image-20240624231735907.png" class="" title="image-20240624231735907">
</li>
<li><p>不同进程中分别使用 open 函数打开同一个文件</p>
<img src="/1f3f638f/image-20240624231752361.png" class="" title="image-20240624231752361">
</li>
<li><p>同一个进程中通过 dup(dup2)函数对文件描述符进行复制</p>
<img src="/1f3f638f/image-20240624231804747.png" class="" title="image-20240624231804747"></li>
</ol>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ol>
<li><p><strong>O_APPEND</strong></p>
<p>open时加入该标志</p>
</li>
<li><p><strong>pread()<strong>和</strong>pwrite()</strong></p>
<p><code>man 2 pread</code>查看</p>
</li>
<li><p><strong>O_EXCL</strong></p>
<p>避免创建文件出现问题</p>
</li>
</ol>
<h1 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h1><p>标准 I/O 是对文件 I/O 进行了封装。标准 I/O 会处理很多细节，譬如分配 stdio 缓冲区、以优</p>
<p>化的块长度执行 I/O 等，这些处理使用户不必担心如何选择使用正确的块长度。</p>
<h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><p>文件：fopen, fclose, fseek, fread, fwrite</p>
<p>错误：feof, ferror, clearerr</p>
<p>详情使用<code>man 3 fopen/fclose...</code>来查看</p>
<h1 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h1><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">// 本质：write(1, format, size)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">// 本质：read(0, format, size)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="文件描述符和FILE指针相互转换"><a href="#文件描述符和FILE指针相互转换" class="headerlink" title="文件描述符和FILE指针相互转换"></a>文件描述符和FILE指针相互转换</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>; <span class="comment">// FILE* -&gt; fd</span></span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>; <span class="comment">// fd -&gt; FILE*</span></span><br></pre></td></tr></tbody></table></figure>



<h1 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a>IO缓冲</h1><img src="/1f3f638f/image-20240625115550593.png" class="" title="image-20240625115550593">

<p>可以看出：文件IO比标准IO要快</p>
<h2 id="文件IO缓冲"><a href="#文件IO缓冲" class="headerlink" title="文件IO缓冲"></a>文件IO缓冲</h2><p>刷新缓冲区：fsync, fdatasync, sync</p>
<p><code>man 3 sync</code>查看</p>
<p>fsync: 文件内数据和元数据</p>
<p>fdatasync: 文件内容数据</p>
<p>sync: 所有</p>
<h3 id="绕过IO缓冲"><a href="#绕过IO缓冲" class="headerlink" title="绕过IO缓冲"></a>绕过IO缓冲</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">// 需要定义宏</span></span></span><br><span class="line">fd = open(filepath, O_WRONLY | O_DIRECT);</span><br></pre></td></tr></tbody></table></figure>

<p>限制：</p>
<ul>
<li>应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐；</li>
<li>写文件时，文件的位置偏移量必须是块大小的整数倍；</li>
<li>写入到文件的数据大小必须是块大小的整数倍。</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 查看blocksize</span></span><br><span class="line"><span class="built_in">df</span> -h <span class="comment"># 查看根目录在哪</span></span><br><span class="line">tune2fs -l /dev/sda? | grep <span class="string">"Block size"</span></span><br></pre></td></tr></tbody></table></figure>

<p>内存起始地址对齐</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">8192</span>] __attribute__((aligned(<span class="number">4096</span>)));</span><br></pre></td></tr></tbody></table></figure>

<p>写入块大小整数倍</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret = write(fd, buf, <span class="number">4096</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="标准IO缓冲"><a href="#标准IO缓冲" class="headerlink" title="标准IO缓冲"></a>标准IO缓冲</h2><p>对stdio缓冲设置</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>man 3</code>查看文档</p>
<h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>使用stat，fstat, lstat查看文件（目录）属性，stat返回一个<code>struct stat</code>结构体</p>
<p>可使用<code>man 2</code>查看，fstat可通过fd来查看属性，lstat可以看链接文件属性</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="type">dev_t</span> st_dev; <span class="comment">/* 文件所在设备的 ID */</span></span><br><span class="line"> <span class="type">ino_t</span> st_ino; <span class="comment">/* 文件对应 inode 节点编号 */</span></span><br><span class="line"> <span class="type">mode_t</span> st_mode; <span class="comment">/* 文件对应的模式 */</span></span><br><span class="line"> <span class="type">nlink_t</span> st_nlink; <span class="comment">/* 文件的链接数 */</span></span><br><span class="line"> <span class="type">uid_t</span> st_uid; <span class="comment">/* 文件所有者的用户 ID */</span></span><br><span class="line"> <span class="type">gid_t</span> st_gid; <span class="comment">/* 文件所有者的组 ID */</span></span><br><span class="line"> <span class="type">dev_t</span> st_rdev; <span class="comment">/* 设备号（指针对设备文件） */</span></span><br><span class="line"> <span class="type">off_t</span> st_size; <span class="comment">/* 文件大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">blksize_t</span> st_blksize; <span class="comment">/* 文件内容存储的块大小 */</span></span><br><span class="line"> <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* 文件内容所占块数 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span> <span class="comment">/* 文件最后被访问的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span> <span class="comment">/* 文件内容最后被修改的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span> <span class="comment">/* 文件状态最后被改变的时间 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="归属"><a href="#归属" class="headerlink" title="归属"></a>归属</h2><p>使用chown, fchown, lchown来更改文件所属，三者区别上同</p>
<p>PS：进程相关联ID</p>
<img src="/1f3f638f/image-20240626092456008.png" class="">

<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>修改时间属性utime, utimes(精度区别)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> {</span></span><br><span class="line">	<span class="type">time_t</span> actime; <span class="comment">/* 访问时间 */</span></span><br><span class="line">	<span class="type">time_t</span> modtime; <span class="comment">/* 内容修改时间 */</span></span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> <span class="title function_">utimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> {</span></span><br><span class="line"> <span class="type">long</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"> <span class="type">long</span> tv_usec; <span class="comment">/* 微秒 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>还有futimens()和 utimensat()，区别是：</p>
<ul>
<li>可按纳秒级精度设置时间戳。</li>
<li>可单独设置某一时间戳。</li>
<li>可独立将任一时间戳设置为当前时间。</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>通过<code>link</code>设置硬连接，<code>symlink</code>设置软连接，<code>readlink</code>读取链接文件</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>unlink</code>删除文件</p>
<p><code>man 2</code>查看</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>存储形式</p>
<img src="/1f3f638f/image-20240626105646448.png" class="">

<p>常用操作：mkdir, rmdir, opendir, readdir, rewinddir, closedir, getcwd, chdir, fchdir</p>
<p><code>man 2</code>查看</p>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>RM装甲板识别</title>
    <url>/158223f0.html</url>
    <content><![CDATA[<p>在Robomaster比赛中，装甲板是机器人得分的主要目标。识别并攻击装甲板可以帮助机器人按照比赛规则得分，同时避免攻击非装甲部位，减少无效攻击和违规行为。通过装甲板识别技术，机器人可以准确地检测并定位敌方机器人，从而进行有效的瞄准和攻击。装甲板通常是对方机器人的关键部位，通过识别这些部位可以提高攻击的命中率。</p>
<span id="more"></span>

<p><strong>装甲板示例图</strong></p>
<img src="/158223f0/test1.png" class="">

<p>config.py中，is_video=0表示是图片识别反之则是视频识别</p>
<p>is_debug=1时显示中间debug文件</p>
<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><ol>
<li>使用语言：Python</li>
<li>项目流程管理：git, docker</li>
<li>训练模型使用的框架：pytorch</li>
<li>识别基本思路：通过装甲板两边的灯条来定位装甲板，再通过数字检测再进行筛选最后得到装甲板的位置（传统识别+深度学习）</li>
</ol>
<p>项目目录</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">│  .gitignore</span><br><span class="line">|  Dockerfile <span class="comment"># 构建镜像</span></span><br><span class="line">|  requirements.txt <span class="comment"># 所需要的包</span></span><br><span class="line">|  test.py <span class="comment"># 测试文件</span></span><br><span class="line">│  config.py <span class="comment"># 配置</span></span><br><span class="line">│  detect.py <span class="comment"># 识别模块</span></span><br><span class="line">│  main.py <span class="comment"># 主程序入口</span></span><br><span class="line">│  readme.md <span class="comment"># 文档</span></span><br><span class="line">│  train.py <span class="comment"># 训练文件</span></span><br><span class="line">│</span><br><span class="line">├─cfg <span class="comment"># 模型文件</span></span><br><span class="line">│</span><br><span class="line">├─datasets <span class="comment"># 数据集</span></span><br><span class="line">│</span><br><span class="line">├─image <span class="comment"># readme图片</span></span><br><span class="line">│</span><br><span class="line">├─testdata 测试数据集</span><br></pre></td></tr></tbody></table></figure>

<h1 id="识别具体实现"><a href="#识别具体实现" class="headerlink" title="识别具体实现"></a>识别具体实现</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>位于config.py中，模型，是否debug，一些参数，类的定义均存在里面</p>
<h2 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h2><p>通过cvtColor和threshold将图片转为二值图片，将目标从背景中分离出来。</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">def preProcess(rgb_img):</span><br><span class="line">    gray = cv.cvtColor(rgb_img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    _, binary = cv.threshold(gray, settings.binary_thres, 255, cv.THRESH_BINARY) #_是阈值 忽略</span><br><span class="line">    return binary</span><br></pre></td></tr></tbody></table></figure>

<h2 id="寻找灯条"><a href="#寻找灯条" class="headerlink" title="寻找灯条"></a>寻找灯条</h2><p>通过 findContours 得到轮廓</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">contours, hierarchy = cv.findContours(binary_img, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></tbody></table></figure>

<p>将轮廓点数小于5的排除掉</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">for contour in contours:</span><br><span class="line">        if len(contour) &lt; 5:</span><br><span class="line">            continue</span><br></pre></td></tr></tbody></table></figure>

<p>对轮廓进行外接矩形并且判定是否是灯条</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">	r_rect = cv.minAreaRect(contour)</span><br><span class="line">        light = Light(r_rect)</span><br><span class="line"></span><br><span class="line">        if is_light(light):</span><br><span class="line"># Light的定义(一小部分)</span><br><span class="line">class Light:</span><br><span class="line">    def __init__(self, box=None):</span><br><span class="line">	self.center = box[0]</span><br><span class="line">        self.size = box[1]</span><br><span class="line">        self.angle = box[2]</span><br><span class="line"></span><br><span class="line">        points = cv.boxPoints(box)</span><br><span class="line">        points = sorted(points, key=lambda p: p[1])</span><br><span class="line"></span><br><span class="line">        self.top = (points[0] + points[1]) / 2</span><br><span class="line">        self.bottom = (points[2] + points[3]) / 2</span><br><span class="line"></span><br><span class="line">        self.length = np.linalg.norm(self.top - self.bottom)</span><br><span class="line">        self.width = np.linalg.norm(points[0] - points[1])</span><br><span class="line"></span><br><span class="line">        self.tilt_angle = atan2(abs(self.top[0] - self.bottom[0]), abs(self.top[1] - self.bottom[1]))</span><br><span class="line">        self.tilt_angle = self.tilt_angle / pi * 180</span><br><span class="line">        self.color = None</span><br></pre></td></tr></tbody></table></figure>

<p>通过统计在给定轮廓内的红色和蓝色像素值的总和，来判断该区域主要的颜色是红色还是蓝色。使用 <code>cv.pointPolygonTest</code>来确保只统计轮廓内部的像素值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sum_r, sum_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">   roi = rbg_img[rect[<span class="number">1</span>]:rect[<span class="number">1</span>]+rect[<span class="number">3</span>], rect[<span class="number">0</span>]:rect[<span class="number">0</span>]+rect[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(roi.shape[<span class="number">0</span>]):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(roi.shape[<span class="number">1</span>]):</span><br><span class="line">   <span class="keyword">if</span> cv.pointPolygonTest(contour, (j + rect[<span class="number">0</span>], i + rect[<span class="number">1</span>]), <span class="literal">False</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">   	sum_b += roi[i, j, <span class="number">0</span>]</span><br><span class="line">   	sum_r += roi[i, j, <span class="number">2</span>]</span><br><span class="line">	light.color = <span class="string">'RED'</span> <span class="keyword">if</span> sum_r &gt; sum_b <span class="keyword">else</span> <span class="string">'BLUE'</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="配对灯条"><a href="#配对灯条" class="headerlink" title="配对灯条"></a>配对灯条</h2><p>根据 <code>detect_color</code> 选择对应颜色的灯条进行两两配对，首先筛除掉两条灯条中间包含另一个灯条的情况，然后根据两灯条的长度之比、两灯条中心的距离、配对出装甲板的倾斜角度来筛选掉条件不满足的结果，得到形状符合装甲板特征的灯条配对（数据根据官方和测量得出）。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">def <span class="title function_">containLight</span><span class="params">(light_1, light_2, lights)</span>:</span><br><span class="line">    # 获取两个光条的顶点和底点坐标</span><br><span class="line">    points = np.<span class="built_in">array</span>([light_1.top, light_1.bottom, light_2.top, light_2.bottom])</span><br><span class="line">    bounding_rect = cv.boundingRect(points)</span><br><span class="line"></span><br><span class="line">    # 遍历所有光条，检查是否有光条被包含在两个光条之间</span><br><span class="line">    <span class="keyword">for</span> test_light in lights:</span><br><span class="line">        <span class="keyword">if</span> np.array_equal(test_light.center, light_1.center) or np.array_equal(test_light.center, light_2.center):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cv.pointPolygonTest(points, (test_light.top[<span class="number">0</span>], test_light.top[<span class="number">1</span>]), False) &gt;= <span class="number">0</span> or</span><br><span class="line">            cv.pointPolygonTest(points, (test_light.bottom[<span class="number">0</span>], test_light.bottom[<span class="number">1</span>]), False) &gt;= <span class="number">0</span> or</span><br><span class="line">            cv.pointPolygonTest(points, (test_light.center[<span class="number">0</span>], test_light.center[<span class="number">1</span>]), False) &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> True</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line">def isArmor(light_1, light_2):</span><br><span class="line">    # 比较两个光条的长度比例（短边 / 长边）</span><br><span class="line">    light_length_ratio = min(light_1.length, light_2.length) / max(light_1.length, light_2.length)</span><br><span class="line">    light_ratio_ok = light_length_ratio &gt; settings.amin_light_ratio</span><br><span class="line"></span><br><span class="line">    # 计算两个光条中心的距离（以光条长度为单位）</span><br><span class="line">    avg_light_length = (light_1.length + light_2.length) / <span class="number">2</span></span><br><span class="line">    center_distance = np.linalg.norm(np.<span class="built_in">array</span>(light_1.center) - np.<span class="built_in">array</span>(light_2.center)) / avg_light_length</span><br><span class="line">    center_distance_ok = (settings.amin_small_center_distance &lt;= center_distance &lt; settings.amax_small_center_distance) or \</span><br><span class="line">                         (settings.amin_large_center_distance &lt;= center_distance &lt; settings.amax_large_center_distance)</span><br><span class="line"></span><br><span class="line">    # 计算光条中心连接线的角度</span><br><span class="line">    diff = np.<span class="built_in">array</span>(light_1.center) - np.<span class="built_in">array</span>(light_2.center)</span><br><span class="line">    angle = degrees(<span class="built_in">abs</span>(<span class="built_in">atan2</span>(diff[<span class="number">1</span>], diff[<span class="number">0</span>])))</span><br><span class="line">    angle_ok = angle &lt; settings.amax_angle</span><br><span class="line"></span><br><span class="line">    # 综合判断是否为装甲板</span><br><span class="line">    is_armor = light_ratio_ok and center_distance_ok and angle_ok</span><br><span class="line"></span><br><span class="line">    # 判断装甲板类型</span><br><span class="line">    <span class="keyword">if</span> is_armor:</span><br><span class="line">        type = <span class="string">'LARGE'</span> <span class="keyword">if</span> center_distance &gt; settings.amin_large_center_distance <span class="keyword">else</span> <span class="string">'SMALL'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        type = <span class="string">'INVALID'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type</span><br></pre></td></tr></tbody></table></figure>

<h2 id="提取数字"><a href="#提取数字" class="headerlink" title="提取数字"></a>提取数字</h2><p>设置好roi，根据灯条的坐标获得装甲板大致的位置，然后使用透视变换截取出数字部分</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">lights_vertices = np.array([armor.left_light.bottom, armor.left_light.top,</span><br><span class="line">                                       armor.right_light.top, armor.right_light.bottom], dtype=np.float32)</span><br><span class="line">           <span class="comment"># 计算变换后图像中灯条顶部和底部的y坐标</span></span><br><span class="line">           top_light_y = (warp_height - light_length) // <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">           bottom_light_y = top_light_y + light_length</span><br><span class="line">           <span class="comment"># 根据装甲板类型确定变换后的图像宽度</span></span><br><span class="line">           warp_width = small_armor_width <span class="keyword">if</span> armor.<span class="built_in">type</span> == <span class="string">'SMALL'</span> <span class="keyword">else</span> large_armor_width</span><br><span class="line">           <span class="comment"># 设置变换后图像的目标顶点位置</span></span><br><span class="line">           target_vertices = np.array([[<span class="number">0</span>, bottom_light_y],</span><br><span class="line">                                       [<span class="number">0</span>, top_light_y],</span><br><span class="line">                                       [warp_width - <span class="number">1</span>, top_light_y],</span><br><span class="line">                                       [warp_width - <span class="number">1</span>, bottom_light_y]], dtype=np.float32)</span><br><span class="line">           <span class="comment"># 计算透视变换矩阵</span></span><br><span class="line">           rotation_matrix = cv.getPerspectiveTransform(lights_vertices, target_vertices)</span><br><span class="line">           <span class="comment"># 应用透视变换，将源图像中的装甲板区域变换到目标顶点位置</span></span><br><span class="line">           number_image = cv.warpPerspective(src, rotation_matrix, (warp_width, warp_height))</span><br><span class="line">           <span class="comment"># 从变换后的图像中提取感兴趣区域（ROI）</span></span><br><span class="line">           x_start = (warp_width - roi_size[<span class="number">0</span>]) // <span class="number">2</span></span><br><span class="line">           x_end = x_start + roi_size[<span class="number">0</span>]</span><br><span class="line">           number_image = number_image[<span class="number">0</span>:roi_size[<span class="number">1</span>], x_start:x_end]</span><br><span class="line">           <span class="comment"># 将图像转换为灰度图像</span></span><br><span class="line">           number_image = cv.cvtColor(number_image, cv.COLOR_RGB2GRAY)</span><br><span class="line">           <span class="comment"># 对灰度图像应用二值化处理</span></span><br><span class="line">           _, number_image = cv.threshold(number_image, <span class="number">0</span>, <span class="number">255</span>, cv.THRESH_BINARY | cv.THRESH_OTSU)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><p>由于MiniPC的性能限制，只是设计了简单的mlp网络用于数字分类</p>
<img src="/158223f0/image-20240626144621090.png" class="">

<p>在训练前对训练集进行处理</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dataset = torchvision.datasets.ImageFolder(</span><br><span class="line">    root=os.path.join(os.path.dirname(__file__), <span class="string">'datasets'</span>),</span><br><span class="line">    transform=torchvision.transforms.Compose([</span><br><span class="line">        torchvision.transforms.Grayscale(num_output_channels=<span class="number">1</span>), <span class="comment"># 灰度化</span></span><br><span class="line">        torchvision.transforms.RandomAffine(</span><br><span class="line">            degrees=(-<span class="number">5</span>, <span class="number">5</span>), translate=(<span class="number">0.08</span>, <span class="number">0.08</span>), scale=(<span class="number">0.9</span>, <span class="number">1.1</span>)), <span class="comment"># 旋转，平移，放缩</span></span><br><span class="line">        torchvision.transforms.ToTensor(),</span><br><span class="line">        torchvision.transforms.RandomErasing(</span><br><span class="line">            scale=(<span class="number">0.02</span>, <span class="number">0.02</span>))</span><br><span class="line">    ]))<span class="comment"># 擦除</span></span><br><span class="line"><span class="comment"># 用ImageFolder表示文件夹为标签名</span></span><br></pre></td></tr></tbody></table></figure>

<p>数据集分为两部分（4:1）训练集和测试集</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">train_dataset, test_dataset = torch.utils.data.random_split(</span><br><span class="line">    dataset, [<span class="built_in">int</span>(<span class="built_in">len</span>(dataset) * <span class="number">0.8</span>), <span class="built_in">len</span>(dataset) - <span class="built_in">int</span>(<span class="built_in">len</span>(dataset) * <span class="number">0.8</span>)])</span><br></pre></td></tr></tbody></table></figure>

<p>损失函数和优化器</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">1e-3</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>训练评估</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        correct = <span class="number">0</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> test_loader:</span><br><span class="line">            x, y = x.to(device), y.to(device)  <span class="comment"># Move data to the device</span></span><br><span class="line">            y_pred = model(x)</span><br><span class="line">            loss = loss_fn(y_pred, y)</span><br><span class="line">            running_val_loss += loss.item()</span><br><span class="line"></span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(y_pred.data, <span class="number">1</span>)</span><br><span class="line">            total += y.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == y).<span class="built_in">sum</span>().item()</span><br><span class="line">        avg_val_loss = running_val_loss / <span class="built_in">len</span>(test_loader)</span><br><span class="line">        accuracy = <span class="number">100</span> * correct / total</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'Epoch: <span class="subst">{epoch + <span class="number">1</span>}</span>, Accuracy: <span class="subst">{accuracy}</span>%'</span>)</span><br><span class="line">        writer.add_scalar(<span class="string">'Accuracy/test'</span>, accuracy, epoch)</span><br><span class="line">        writer.add_scalar(<span class="string">'Loss/val'</span>, avg_val_loss, epoch)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="模型部署"><a href="#模型部署" class="headerlink" title="模型部署"></a>模型部署</h2><p>使用opencv的dnn模块, softmax转换为概率，argmax转换为对应的类别（0 - 5）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">blob = cv.dnn.blobFromImage(image)</span><br><span class="line">self.net.setInput(blob)</span><br><span class="line">outputs = self.net.forward()</span><br><span class="line">outputs = outputs.flatten()</span><br><span class="line">exp_outputs = np.exp(outputs - np.<span class="built_in">max</span>(outputs))</span><br><span class="line">softmax_prob = exp_outputs / np.<span class="built_in">sum</span>(exp_outputs)</span><br><span class="line">confidence = np.<span class="built_in">max</span>(softmax_prob)</span><br><span class="line">label_id = np.argmax(softmax_prob)</span><br><span class="line"></span><br><span class="line">armor.confidence = confidence</span><br><span class="line">armor.number = self.class_names[label_id]</span><br><span class="line"></span><br><span class="line">armor.classification_result = <span class="string">f"<span class="subst">{armor.number}</span>: <span class="subst">{armor.confidence * <span class="number">100.0</span>:<span class="number">.1</span>f}</span>%"</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">docker build -t my-python-image .</span><br><span class="line">docker run -it \</span><br><span class="line">    --name my-python-container \</span><br><span class="line">    --<span class="built_in">env</span>=<span class="string">"DISPLAY"</span> \</span><br><span class="line">    --volume=<span class="string">"/tmp/.X11-unix:/tmp/.X11-unix:rw"</span> \</span><br><span class="line">    --volume=<span class="string">"<span class="subst">$(pwd)</span>:/app"</span> \</span><br><span class="line">    my-python-image</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用前记得</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">xhost +</span><br></pre></td></tr></tbody></table></figure>

<h1 id="PIP安装"><a href="#PIP安装" class="headerlink" title="PIP安装"></a>PIP安装</h1><p>如果不想使用docker部署可以使用</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></tbody></table></figure>

<p>安装所需要的包</p>
<p><strong>PS:</strong></p>
<p>项目基础是从rm_vision改过来的纯Python版本，同时也有ROS C++版的，详见<a href="https://github.com/langou0115/RoboDetect">here</a></p>
]]></content>
      <categories>
        <category>Robomaster</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统信息与资源</title>
    <url>/8c131bee.html</url>
    <content><![CDATA[<p>在应用程序当中，有时往往需要去获取到一些系统相关的信息，譬如时间、日期、以及其它一些系统相关信息，本章将向大家介绍如何通过 Linux 系统调用或 C 库函数获取系统信息，譬如获取系统时间、日期以及设置系统时间、日期等；除此之外，还会向大家介绍 Linux 系统下的/proc 虚拟文件系统，包括/proc 文件系统是什么以及如何从/proc 文件系统中读取系统、进程有关信息。也会提及到信号相关的问题。</p>
<span id="more"></span>

<h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h1><p>常用函数：uname, sysinfo, gethostname, sysconf</p>
<p><code>man 2</code>查看文档</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">os_info</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = uname(&amp;os_info);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ret)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"uname"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sysname: %s\n"</span>, os_info.sysname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nodename: %s\n"</span>, os_info.nodename);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"release: %s\n"</span>, os_info.release);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"version: %s\n"</span>, os_info.version);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"machine: %s\n"</span>, os_info.machine);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sys_info</span>;</span></span><br><span class="line">    <span class="comment">/* 获取信息 */</span></span><br><span class="line">    ret = sysinfo(&amp;sys_info);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"sysinfo error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">    <span class="comment">/* 打印信息 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uptime: %ld\n"</span>, sys_info.uptime);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"totalram: %lu\n"</span>, sys_info.totalram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"freeram: %lu\n"</span>, sys_info.freeram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"procs: %u\n"</span>, sys_info.procs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gethostname</span></span><br><span class="line">    <span class="type">char</span> hostname[<span class="number">256</span>];</span><br><span class="line">    ret = gethostname(hostname, <span class="keyword">sizeof</span>(hostname));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"gethostname"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hostname: %s\n"</span>, hostname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"每个用户的最大并发进程数: %ld\n"</span>, sysconf(_SC_CHILD_MAX));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"系统节拍率: %ld\n"</span>, sysconf(_SC_CLK_TCK));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"系统页大小: %ld\n"</span>, sysconf(_SC_PAGESIZE));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大文件数: %ld\n"</span>, sysconf(_SC_OPEN_MAX));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h1><p>​	<img src="/8c131bee/image-20240626135355304.png" class=""></p>
<p>​	Linux 系统在开机启动之后首先会读取 RTC 硬件获取实时时钟作为系统时钟的初始值，之后内核便开始维护自己的系统时钟。实时时钟一般由 RTC 时钟芯片提供，RTC 芯片有相应的电池为其供电，以保证系统在关机情况下 RTC 能够继续工作、继续计时。</p>
<p>​	内核使用 jiffies 来记录系统从启动以来的系统节拍数，全局变量 jiffies 在系统开机启动时会设置一个初始值，RTC 实时时钟会在系统开机启动时读取一次，目的是用于对系统时钟进行初始化，这里说的初始化其实指的就是对内核的 jiffies 变量进行初始化操作。</p>
<p><strong>获取时间函数：</strong>time，gettimeofday(返回自 1970-01-01 00:00:00 +0000 (UTC)以来的时间值)</p>
<p><strong>时间转换函数：</strong>ctime, localtime_r(均是C库函数)</p>
<p><strong>设置时间</strong>：settimeofday</p>
<h1 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h1><ol>
<li><p>times</p>
<p>除以<code> sysconf(_SC_CLK_TCK)</code>，返回的是用户CPU时间和内核CPU时间</p>
</li>
<li><p>clock</p>
<p>C库函数，除以<code>CLOCKS_PER_SEC</code>, 返回的是总的CPU时间</p>
</li>
</ol>
<h1 id="Proc"><a href="#Proc" class="headerlink" title="Proc"></a>Proc</h1><p>proc 文件系统是一个虚拟文件系统，它以文件系统的方式为应用层访问系统内核数据提供了接口，用</p>
<p>户和应用程序可以通过 proc 文件系统得到系统信息和进程相关信息，对 proc 文件系统的读写作为与内核</p>
<p>进行通信的一种手段。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /proc</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></tbody></table></figure>

<img src="/8c131bee/image-20240627094516424.png" class="">

<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>不可靠信号：信号可能丢失（非实时信号）序号为1~31</p>
<p>当排队时，不可靠信号等待是集合，当相同信号再次传来的时候就会丢弃</p>
<h2 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h2><table>
<thead>
<tr>
<th>信号名称</th>
<th>编号</th>
<th>描述</th>
<th>系统默认操作</th>
</tr>
</thead>
<tbody><tr>
<td>SIGINT</td>
<td>2</td>
<td>终端中断符</td>
<td>term</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>终端退出符</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>非法硬件指令</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>异常终止（abort）</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>7</td>
<td>内存访问错误</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>算术异常</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>终极终止信号</td>
<td>term</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>10</td>
<td>用户自定义信号 1</td>
<td>term</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>无效的内存引用</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>12</td>
<td>用户自定义信号 2</td>
<td>term</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>管道关闭</td>
<td>term</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>定时器超时（alarm）</td>
<td>term</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>终止进程</td>
<td>term</td>
</tr>
<tr>
<td>SIGCHLD/SIGCLD</td>
<td>17</td>
<td>子进程终止或停止</td>
<td>ignore</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>18</td>
<td>使停止状态的进程继续运行</td>
<td>cont</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>19</td>
<td>停止进程</td>
<td>stop</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>20</td>
<td>终端停止符</td>
<td>stop</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>24</td>
<td>超过 CPU 限制</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>26</td>
<td>虚拟定时器超时</td>
<td>term</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>28</td>
<td>终端窗口尺寸发生变化</td>
<td>term</td>
</tr>
<tr>
<td>SIGPOLL/SIGIO</td>
<td>29</td>
<td>异步 I/O</td>
<td>term/ignore</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>31</td>
<td>无效系统调用</td>
<td>term+core</td>
</tr>
</tbody></table>
<p>tips: term 表示终止进程；core 表示生成核心转储文件；ignore 表示忽略信号；cont 表示继续运行进程；stop 表示停止进程（注意停止不等于终止，而是暂停）</p>
<p><strong>进程对信号处理：</strong>signal和sigaction函数</p>
<p><strong>发送信号：</strong>kill和raise函数，kill发送任一进程，raise发送自身</p>
<p><strong>定时和休眠：</strong>alarm和pause函数</p>
<p><strong>信号集相关函数</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">// 空信号集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">// 捕获所有信号</span></span><br><span class="line"><span class="comment">// 添加信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 是否在信号集中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 查看是否信号是否等待并存入信号集中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="信号掩码"><a href="#信号掩码" class="headerlink" title="信号掩码"></a>信号掩码</h2><p>内核为每一个进程维护了一个信号掩码（其实就是一个信号集），即一组信号。当进程接收到一个属于信号掩码中定义的信号时，该信号将会被阻塞、无法传递给进程进行处理，那么内核会将其阻塞，直到该信号从信号掩码中移除，内核才会把该信号传递给进程从而得到处理。</p>
<ul>
<li>当应用程序调用 signal()或 sigaction()函数为某一个信号设置处理方式时，进程会自动将该信号添加</li>
</ul>
<p>到信号掩码中，这样保证了在处理一个给定的信号时，如果此信号再次发生，那么它将会被阻塞；</p>
<p>当然对于 sigaction()而言，是否会如此，需要根据 sigaction()函数是否设置了 SA_NODEFER 标志</p>
<p>而定；当信号处理函数结束返回后，会自动将该信号从信号掩码中移除。</p>
<ul>
<li>使用 sigaction()函数为信号设置处理方式时，可以额外指定一组信号，当调用信号处理函数时将该</li>
</ul>
<p>组信号自动添加到信号掩码中，当信号处理函数结束返回后，再将这组信号从信号掩码中移除；通</p>
<p>过 sa_mask 参数进行设置。</p>
<ul>
<li>除了以上两种方式之外，还可以使用<code>sigprocmask()</code>系统调用，随时可以显式地向信号掩码中添加或</li>
</ul>
<p>移除信号。使用<code>man2</code>查看使用教程</p>
<h2 id="实时信号"><a href="#实时信号" class="headerlink" title="实时信号"></a>实时信号</h2><p>可靠信号（32~64）队列处理</p>
<p>可以在<code>/usr/include/asm-generic/signal.h</code>进行查看</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _NSIG		64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These should not be considered constants from userland.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGRTMIN	32</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIGRTMAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGRTMAX	_NSIG</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>对于可靠信号需要使用<code>sigqueue</code>来传递信号</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>忽略信号</strong></p>
<p><code>SIG_IGN</code></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略中断信号</span></span><br><span class="line"><span class="comment">// 忽略 SIGINT 信号 (通常是 Ctrl+C)</span></span><br><span class="line">signal(SIGINT, SIG_IGN);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>异常退出</strong></p>
<p><code>abort</code></p>
<p>无论阻塞或忽略 SIGABRT 信号，abort()调用均不收到影响，总会成功终止进程</p>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>


<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>图论</title>
    <url>/10f14ed7.html</url>
    <content><![CDATA[<p>第二难的一个…..</p>
<span id="more"></span>

<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">组合</a></p>
<p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">分割</a></p>
<p><a href="https://leetcode.cn/problems/subsets-ii/description/">子集</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1219">应用</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">dfs(...)</span><br><span class="line">{</span><br><span class="line">    if(){</span><br><span class="line">       // 递归终止 </span><br><span class="line">    }</span><br><span class="line">    for(){</span><br><span class="line">        //遍历</span><br><span class="line">        dfs(...)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><a href="https://www.luogu.com.cn/problem/P1443">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">bfs(int x, int y){</span><br><span class="line">    queue&lt;Point&gt; que;</span><br><span class="line">    Point s = Point(x, y, 0);</span><br><span class="line">    que.push(s);</span><br><span class="line">    while(!que.empty()){</span><br><span class="line">        s = que.pop();</span><br><span class="line">        // ....</span><br><span class="line">        for(...){</span><br><span class="line">            // ...</span><br><span class="line">            if(...){</span><br><span class="line">                que.push(Point(s.x, s.y, s.step+1));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="图的储存"><a href="#图的储存" class="headerlink" title="图的储存"></a>图的储存</h1><h2 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="1.邻接矩阵"></a>1.邻接矩阵</h2><p><strong>过于简单….省略</strong></p>
<h2 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="2.邻接表"></a>2.邻接表</h2><p><strong>第一种写法</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">const int MAXN = ....; //最大点的数量</span><br><span class="line">vector&lt;int&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line">// 存一个from-&gt;to边的实例</span><br><span class="line">cin &gt;&gt; from &gt;&gt; to;</span><br><span class="line">G[from].push_back(to);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>第二种写法 链式前向星</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct Edge{</span><br><span class="line">    int to;</span><br><span class="line">    int val;</span><br><span class="line">    int next;</span><br><span class="line">} edge[MAXM];</span><br><span class="line">int head[MAXN];</span><br><span class="line"></span><br><span class="line">int cnt = 0;</span><br><span class="line">void add_edge(int from, int to, int val)</span><br><span class="line">{</span><br><span class="line">    edge[++cnt].to = to;</span><br><span class="line">    edge[cnt].val = val;</span><br><span class="line">    edge[cnt].next = head[from];</span><br><span class="line">    head[from] = cnt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="连通问题"><a href="#连通问题" class="headerlink" title="连通问题"></a>连通问题</h1><h2 id="Tarjan求强连通分量"><a href="#Tarjan求强连通分量" class="headerlink" title="Tarjan求强连通分量"></a>Tarjan求强连通分量</h2><p><a href="https://www.luogu.com.cn/problem/P2863">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;int&gt; G[MAXN]; // 存储好的图</span><br><span class="line"></span><br><span class="line">stack&lt;int&gt; st;</span><br><span class="line">int dfn[MAXN], low[MAXN]; // dfn为遍历到x点的时间，low表示x点可以回溯到的时间最小的起点</span><br><span class="line">int instack[MAXN];</span><br><span class="line">void tarjan(int x);</span><br><span class="line">{</span><br><span class="line">    static int tim = 1;</span><br><span class="line">    st.push(x);</span><br><span class="line">    instack[x] = 1;</span><br><span class="line">    dfn[x] = low[n] = tim++;</span><br><span class="line">    for(int i = 0; i &lt; G[x].size(); i++){</span><br><span class="line">        int j = G[x][i];</span><br><span class="line">        if(!dfn[j]){</span><br><span class="line">            tarjan(j);</span><br><span class="line">            low[x] = min(low[x], low[j]);</span><br><span class="line">        }else if(instack[j]){</span><br><span class="line">            low[x] = min(low[x], dfn[j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if(dfn[x] == low[x]){</span><br><span class="line">        int tmp;</span><br><span class="line">        do{</span><br><span class="line">            tmp = st.top(); st.pop();</span><br><span class="line">            instack[tmp] = 0;</span><br><span class="line">            // todo</span><br><span class="line">        }while(tmp != x);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="利用Tarjan进行缩点"><a href="#利用Tarjan进行缩点" class="headerlink" title="利用Tarjan进行缩点"></a>利用Tarjan进行缩点</h2><p><a href="https://www.luogu.com.cn/problem/P3387">模板</a></p>
<p><strong>将强连通分量缩成一个点，变成有向无环图（DAG）</strong></p>
<p><strong>template</strong></p>
<pre class="md-fences mock-cm md-end-block" spellcheck="false" lang="c++" cid="n196" mdtype="fences"><br>int degree[MAXN]; // 有向无环图每个点的入度<br>int tb[MAXN], tb_a[MAXN], cnt = 1, times = 1;<br>// tb记录原来的点映射到新的点是什么， tb_a记录新的点所花费的时间, cnt记录新点的下标<br>void tarjan(int x)<br>{<br>	dfn[x] = low[x] = times++;<br>	instack[x] = 1;<br>	s.push(x);<br>	for(int i = 0; i &lt; G[x].size(); i++){<br>		int y = G[x][i];<br>		if(!dfn[y]){<br>			tarjan(y);<br>			low[x] = min(low[x], low[y]);<br>		}else if(instack[y]){<br>			low[x] = min(low[x], dfn[y]);<br>		}<br>	}<br>	 // 重点在此<br>	if(dfn[x] == low[x]){<br>		int tmp;<br>		do{<br>			tmp = s.top();<br>			s.pop();<br>			instack[tmp] = 0;<br>			tb[tmp] = cnt;<br>			tb_a[cnt] += a[tmp];<br>		}while(tmp != x);<br>		dp[cnt] = tb_a[cnt];<br>		cnt++;<br>	}<br>}<br><br>void build_tb()<br>{<br>	for(int i = 0; i &lt; n; i++){<br>		for(int j = 0; j &lt; G[i].size(); j++){<br>			int y = G[i][j];<br>			if(tb[i] != tb[y]){ // 映射点相同不做处理<br>				TG[tb[i]].push_back(tb[y]);<br>				indegree[tb[y]]++;<br>			}<br>		}<br>	}<br>}</pre>

<h2 id="Tarjan求割点和桥"><a href="#Tarjan求割点和桥" class="headerlink" title="Tarjan求割点和桥"></a>Tarjan求割点和桥</h2><p><a href="https://www.luogu.com.cn/problem/P3388">模板割点</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1656">模板桥</a></p>
<blockquote>
<p><strong>ps: 无向图中不考虑儿子到父亲的边</strong></p>
</blockquote>
<p><strong>割点</strong>：去除后图不能连通的点</p>
<p><strong>桥</strong>：去除后图不能连通的边</p>
<p><strong>割点条件</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1. 非root点 &amp;&amp; 有儿子 &amp;&amp; low[x儿子] &gt;= dfn[x]</span><br><span class="line">2. root点 &amp;&amp; 有两个及以上的儿子</span><br></pre></td></tr></tbody></table></figure>

<p><strong>x-&gt;y是桥条件</strong>：</p>
<p>low[y] &gt; dfn[x]</p>
<p><strong>template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;int&gt; G[MAXN];</span><br><span class="line">int dfn[MAXN], low[MAXN], root, ans[MAXN], fa[MAXN]; // fa[x]为0时, x为根节点</span><br><span class="line">int times = 1;</span><br><span class="line">void tarjan(int x)</span><br><span class="line">{</span><br><span class="line">    dfn[x] = low[x] = time++;</span><br><span class="line">    int child = 0;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; G[x].size(); i++){</span><br><span class="line">        int y = G[x][i];</span><br><span class="line">        if(!dfn[y]){</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            child++;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            if(!fa[x] &amp;&amp; child &gt; 2) ans[x] = 1; // 割点条件一，会重复运行这一句</span><br><span class="line">            if(fa[x] &amp;&amp; low[y] &gt;= dfn[x]) ans[x] = 1; // 割点条件二，会重复运行这一句</span><br><span class="line">            if(low[y] &gt; dfn[x]) ... // 桥的条件</span><br><span class="line">            low[x] = min(low[x], low[y]);</span><br><span class="line">        }else if(fa[x] != y){</span><br><span class="line">            low[x] = min(low[x], dfn[y]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt;= n; i++){</span><br><span class="line">    if(!dfn[i]){</span><br><span class="line">        tarjan(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="1-Dijkstra算法"><a href="#1-Dijkstra算法" class="headerlink" title="1.Dijkstra算法"></a>1.Dijkstra算法</h2><p><a href="https://www.luogu.com.cn/problem/P4779">模板</a></p>
<p><strong>本质还是贪心算法</strong></p>
<p><strong>储存使用****链式前向星</strong></p>
<p><strong>适用于****非负权边图</strong>，求最短路径</p>
<p><strong>一定要使用****优先队列</strong>！！！！</p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1e5 + 5, MAXM = 2e5 + 5;</span><br><span class="line">struct Edge{</span><br><span class="line">	int to, val, next;</span><br><span class="line">}edge[MAXM];</span><br><span class="line"></span><br><span class="line">int head[MAXN];</span><br><span class="line">int cnt = 0;</span><br><span class="line">void add_edge(int from, int to, int val)</span><br><span class="line">{</span><br><span class="line">	edge[++cnt] = {to, val, head[from]};</span><br><span class="line">	head[from] = cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">struct Node{</span><br><span class="line">	int pos;</span><br><span class="line">	int d;</span><br><span class="line">	bool operator&lt;(const Node&amp; node) const{</span><br><span class="line">		return d &gt; node.d;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int dis[MAXN];</span><br><span class="line">int n, m, s;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line">int vis[MAXN];</span><br><span class="line">void dijkstra()</span><br><span class="line">{</span><br><span class="line">	dis[s] = 0;</span><br><span class="line">	q.push({s, 0});</span><br><span class="line">	while(!q.empty()){</span><br><span class="line">		Node x = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		if(vis[x.pos]) continue;</span><br><span class="line">		vis[x.pos] = 1;</span><br><span class="line">		int pos = x.pos;</span><br><span class="line">		for(int i = head[pos]; i; i = edge[i].next){</span><br><span class="line">			int y = edge[i].to;</span><br><span class="line">			if(dis[y] &gt; dis[pos] + edge[i].val){</span><br><span class="line">				dis[y] = dis[pos] + edge[i].val;</span><br><span class="line">				if(!vis[y]) q.push({y, dis[y]});</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	memset(dis, 0x3f3f, sizeof(dis));</span><br><span class="line">	int from, to, val;</span><br><span class="line">	for(int i = 1; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">		add_edge(from, to, val);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	dijkstra();</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		cout &lt;&lt; dis[i] &lt;&lt; " ";</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-Floyd算法"><a href="#2-Floyd算法" class="headerlink" title="2.Floyd算法"></a>2.Floyd算法</h2><p><a href="https://www.luogu.com.cn/problem/B3647">模板</a></p>
<p><strong>求多源最短路径</strong></p>
<p><strong>存储使用****邻接矩阵</strong></p>
<p><strong>不适用图中****带负边的环</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 1e9</span><br><span class="line">const int MAXN = 105; </span><br><span class="line">int n, m;</span><br><span class="line">int G[MAXN][MAXN];</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		for(int j = 1; j &lt;= n; j++){</span><br><span class="line">			if(i != j) G[i][j] = INF;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	int from, to, val;</span><br><span class="line">	for(int i = 1; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">		G[from][to] = min(G[from][to], val);</span><br><span class="line">		G[to][from] = min(G[to][from], val);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for(int k = 1; k &lt;= n; k++){</span><br><span class="line">		for(int i = 1; i &lt;= n; i++){</span><br><span class="line">			for(int j = 1; j &lt;= n; j++){</span><br><span class="line">				if(G[i][k] &lt; INF &amp;&amp; G[k][j] &lt; INF)</span><br><span class="line">					G[i][j] = min(G[i][j], G[i][k] + G[k][j]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		for(int j = 1; j&lt;= n; j++){</span><br><span class="line">			cout &lt;&lt; G[i][j] &lt;&lt; " ";</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; '\n';</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-Bellman-Ford算法"><a href="#3-Bellman-Ford算法" class="headerlink" title="3. Bellman Ford算法"></a>3. Bellman Ford算法</h2><p><strong>求单源最短路径</strong></p>
<p><strong>使用****三元组</strong>来储存图（存边）</p>
<p><strong>可用于负权边图，但不适用负环路图</strong></p>
<p><strong>可检测负环路图</strong></p>
<p><strong>时间复杂度不如Dijkstra算法好</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1e5 + 5, MAXM = 2e5 + 5;</span><br><span class="line"></span><br><span class="line">int n, m, s;</span><br><span class="line">int u[MAXM], v[MAXM], w[MAXM];</span><br><span class="line">int dis[MAXN];</span><br><span class="line"></span><br><span class="line">void bellman_ford()</span><br><span class="line">{</span><br><span class="line">	dis[s] = 0;</span><br><span class="line">	for(int i = 1; i &lt;= n - 1; i++){</span><br><span class="line">		int check = 0;</span><br><span class="line">		for(int j = 1; j &lt;= m; j++){</span><br><span class="line">			if(dis[v[j]] &gt;= dis[u[j]] + w[j]){</span><br><span class="line">				dis[v[j]] = dis[u[j]] + w[j];</span><br><span class="line">				check = 1;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		if(!check) break;</span><br><span class="line">	}</span><br><span class="line">    // 再进行一次循环，若有更新就可以判断有负权边</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++) dis[i] = 1e9;</span><br><span class="line">	for(int i = 1; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	bellman_ford();</span><br><span class="line"></span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		cout &lt;&lt; dis[i] &lt;&lt; " ";</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-SPFA算法"><a href="#4-SPFA算法" class="headerlink" title="4.SPFA算法"></a>4.SPFA算法</h2><p><a href="https://www.luogu.com.cn/problem/P3385">模板</a></p>
<p><strong>是Bellman Ford算法的优化</strong></p>
<p><strong>可用来判断图中是否有负环</strong></p>
<p><strong>使用****链式前向星</strong>来储存图</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e3 + 5, M = 6e3 + 5;</span><br><span class="line">int T;</span><br><span class="line">int n, m;</span><br><span class="line">struct Edge{</span><br><span class="line">	int to, val, next;</span><br><span class="line">}edge[M];</span><br><span class="line"></span><br><span class="line">int head[N];</span><br><span class="line">int tot = 0;</span><br><span class="line">void add_edge(int from, int to, int val)</span><br><span class="line">{</span><br><span class="line">	edge[++tot] = {to, val, head[from]};</span><br><span class="line">	head[from] = tot;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int dis[N], vis[N], cnt[N];</span><br><span class="line">bool SPFA()</span><br><span class="line">{</span><br><span class="line">	memset(dis, 0x3f, sizeof(dis));</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(cnt, 0, sizeof(cnt));</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	dis[1] = 0;</span><br><span class="line">	vis[1] = 1;</span><br><span class="line">	q.push(1);</span><br><span class="line">	while(!q.empty()){</span><br><span class="line">		int x = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		vis[x] = 0;</span><br><span class="line"></span><br><span class="line">		for(int i = head[x]; i; i = edge[i].next){</span><br><span class="line">			int y = edge[i].to;</span><br><span class="line">			if(dis[y] &gt; dis[x] + edge[i].val){</span><br><span class="line">				dis[y] = dis[x] + edge[i].val;</span><br><span class="line">				cnt[y] = cnt[x] + 1;</span><br><span class="line">				if(cnt[y] &gt;= n) return true;</span><br><span class="line">				if(!vis[y]){</span><br><span class="line">					q.push(y);</span><br><span class="line">					vis[y] = 1;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	return false;</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	while(T--){</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		tot = 0;</span><br><span class="line">		memset(head, 0, sizeof(head));</span><br><span class="line"></span><br><span class="line">		for(int i = 1; i &lt;= m; i++){</span><br><span class="line">			int from, to, val;</span><br><span class="line">			cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">			add_edge(from, to, val);</span><br><span class="line">			if(val &gt;= 0) add_edge(to, from, val); </span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		bool res = SPFA();</span><br><span class="line">		if(res) cout &lt;&lt; "YES\n";</span><br><span class="line">		else cout &lt;&lt; "NO\n";</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><a href="https://www.luogu.com.cn/problem/P3367">模板</a></p>
<p><strong>将不同的元素放在同一个集合进行区分</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e4 + 5, M = 2e5 + 5;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">int fa[N];</span><br><span class="line">void init()</span><br><span class="line">{</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int find(int x)</span><br><span class="line">{</span><br><span class="line">	if(fa[x] == x){</span><br><span class="line">		return x;</span><br><span class="line">	}else{</span><br><span class="line">		fa[x] = find(fa[x]);</span><br><span class="line">		return fa[x];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void join(int x, int y)</span><br><span class="line">{</span><br><span class="line">	x = find(x);</span><br><span class="line">	y = find(y);</span><br><span class="line">	if(x == y) return;</span><br><span class="line">	fa[y] = x;</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	init();</span><br><span class="line">	for(int i = 1; i &lt;= m; i++){</span><br><span class="line">		int z, x, y;</span><br><span class="line">		cin &gt;&gt; z &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        // z为1表示合并，z为2表示查询是否在一个集合</span><br><span class="line">		if(z == 1){</span><br><span class="line">			join(x, y);</span><br><span class="line">		}else if(z == 2){</span><br><span class="line">			if(find(x) == find(y)) cout &lt;&lt; "Y\n";</span><br><span class="line">			else cout &lt;&lt; "N\n";</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><a href="https://www.luogu.com.cn/problem/P3366">模板</a></p>
<p><strong>n个点，n-1条边，边的权值和最小</strong></p>
<h2 id="Kruscal算法"><a href="#Kruscal算法" class="headerlink" title="Kruscal算法"></a>Kruscal算法</h2><p><strong>适用于无向图，将边按小到大进行排列，依次选择，成环就丢弃，直到边的数量为n - 1条</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 5e3 + 5, M = 2e5 + 5;</span><br><span class="line">struct Edge{</span><br><span class="line">	int u, v, z; </span><br><span class="line">}edge[M];</span><br><span class="line">int n, m, fa[N], cnt = 0, ans = 0;</span><br><span class="line">// 并查集操作 </span><br><span class="line">int find(int x)</span><br><span class="line">{</span><br><span class="line">	if(fa[x] == x){</span><br><span class="line">		return x;</span><br><span class="line">	}else{</span><br><span class="line">		fa[x] = find(fa[x]);</span><br><span class="line">		return fa[x];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">void join(int x, int y)</span><br><span class="line">{</span><br><span class="line">	int f_x = find(x);</span><br><span class="line">	int f_y = find(y);</span><br><span class="line">	if(f_x == f_y) return;</span><br><span class="line">	fa[f_x] = f_y;</span><br><span class="line">}</span><br><span class="line">void kruscal()</span><br><span class="line">{</span><br><span class="line">	sort(edge, edge + m, [](Edge e1, Edge e2){</span><br><span class="line">		return e1.z &lt; e2.z;</span><br><span class="line">	});</span><br><span class="line">	for(int i = 1; i &lt;= m; i++)</span><br><span class="line">	{</span><br><span class="line">		int u = edge[i].u, v = edge[i].v;</span><br><span class="line">		if(find(u) == find(v)) continue; // 成环就丢弃</span><br><span class="line">		else{</span><br><span class="line">			join(u, v);</span><br><span class="line">			ans += edge[i].z;</span><br><span class="line">			cnt++;</span><br><span class="line">		}</span><br><span class="line">		if(cnt == n - 1) break;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	}</span><br><span class="line">	for(int i = 1; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].z;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	kruscal();</span><br><span class="line">	if(cnt == n - 1) cout &lt;&lt; ans;</span><br><span class="line">	else cout &lt;&lt; "orz";</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>update….</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/a444b428.html</url>
    <content><![CDATA[<p>排序算法中的一些思想可以用于解决一些题目，例如逆序对等….</p>
<span id="more"></span>

<h1 id="1-归并排序-分治算法"><a href="#1-归并排序-分治算法" class="headerlink" title="1.归并排序(分治算法)"></a>1.归并排序(分治算法)</h1><p><a href="https://www.luogu.com.cn/problem/P1908">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 5;</span><br><span class="line">int arr[N], n;</span><br><span class="line"></span><br><span class="line">void merge(int l, int mid, int r){</span><br><span class="line">	int n1 = mid - l + 1;</span><br><span class="line">	int n2 = r - mid;</span><br><span class="line">	int larr[n1], rarr[n2];</span><br><span class="line">	int i, j;</span><br><span class="line">	for(int i = 0; i &lt; n1; i++){</span><br><span class="line">		larr[i] = arr[l + i];</span><br><span class="line">	}</span><br><span class="line">	for(int j = 0; j &lt; n2; j++){</span><br><span class="line">		rarr[j] = arr[j + mid + 1];</span><br><span class="line">	}</span><br><span class="line">	i = 0, j = 0;</span><br><span class="line">	int k = l;</span><br><span class="line">	while(i &lt; n1 &amp;&amp; j &lt; n2){</span><br><span class="line">		if(larr[i] &lt; rarr[j]){</span><br><span class="line">			arr[k] = larr[i];</span><br><span class="line">			i++;</span><br><span class="line">		}else{</span><br><span class="line">			arr[k] = rarr[j];</span><br><span class="line">			j++;</span><br><span class="line">		}</span><br><span class="line">		k++;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	while(i &lt; n1){</span><br><span class="line">		arr[k] = larr[i];</span><br><span class="line">		i++, k++;</span><br><span class="line">	}</span><br><span class="line">	while(j &lt; n2){</span><br><span class="line">		arr[k] = rarr[j];</span><br><span class="line">		j++, k++; </span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void msort(int l, int r){</span><br><span class="line">	if(l &lt; r){</span><br><span class="line">		int mid = l + ((r - l) &gt;&gt; 1);</span><br><span class="line">		msort(l, mid);</span><br><span class="line">		msort(mid + 1, r);</span><br><span class="line">		merge(l, mid, r);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for(int i = 0; i &lt; n; i++){</span><br><span class="line">		scanf("%d", &amp;arr[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	msort(0, n - 1); </span><br><span class="line">	for(int i = 0; i &lt; n; i++){</span><br><span class="line">		printf("%d ", arr[i]);</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>update</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法</title>
    <url>/2cc2fa98.html</url>
    <content><![CDATA[<p>蓝桥杯之前进行的一些算法小总结，本文只写了一些简单的算法，图论，树论，动态规划，排序请看该站算法目录下的…..</p>
<span id="more"></span>


<h1 id="C-小技巧"><a href="#C-小技巧" class="headerlink" title="C++小技巧"></a>C++小技巧</h1><h2 id="重定义比较器"><a href="#重定义比较器" class="headerlink" title="重定义比较器"></a>重定义比较器</h2><ul>
<li><strong>lambda变量</strong><br><strong>[=]捕获变量值</strong><br><strong>[&amp;]捕获变量引用</strong></li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">struct Person {</span><br><span class="line"> &nbsp; &nbsp;std::string name;</span><br><span class="line"> &nbsp; &nbsp;int age;</span><br><span class="line"></span><br><span class="line"> &nbsp; &nbsp;Person(std::string n, int a) : name(n), age(a) {}</span><br><span class="line">};</span><br><span class="line">int main() {</span><br><span class="line"> &nbsp; &nbsp;Person alice("Alice", 30);</span><br><span class="line"> &nbsp; &nbsp;Person bob("Bob", 25);</span><br><span class="line"></span><br><span class="line"> &nbsp; &nbsp;// 使用 lambda 表达式比较两个 Person 对象的年龄</span><br><span class="line"> &nbsp; &nbsp;Person older = std::max(alice, bob, [](const Person&amp; a, const Person&amp; b) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;return a.age &lt; b.age;</span><br><span class="line"> &nbsp;  });</span><br><span class="line"> &nbsp; &nbsp;return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>比较器</strong></li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> &nbsp;struct Person {</span><br><span class="line"> &nbsp; &nbsp; &nbsp;std::string name;</span><br><span class="line"> &nbsp; &nbsp; &nbsp;int age;</span><br><span class="line"> &nbsp;</span><br><span class="line"> &nbsp; &nbsp; &nbsp;Person(std::string n, int a) : name(n), age(a) {}</span><br><span class="line">};</span><br><span class="line"> &nbsp;</span><br><span class="line"> &nbsp;// 比较器函数</span><br><span class="line"> &nbsp;bool compareByAge(const Person&amp; a, const Person&amp; b) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp;return a.age &lt; b.age;</span><br><span class="line">}</span><br><span class="line"> &nbsp;</span><br><span class="line"> &nbsp;int main() {</span><br><span class="line"> &nbsp; &nbsp; &nbsp;Person alice("Alice", 30);</span><br><span class="line"> &nbsp; &nbsp; &nbsp;Person bob("Bob", 25);</span><br><span class="line"> &nbsp;</span><br><span class="line"> &nbsp; &nbsp; &nbsp;// 使用比较器函数</span><br><span class="line"> &nbsp; &nbsp; &nbsp;Person older = std::max(alice, bob, compareByAge);</span><br><span class="line"> &nbsp; &nbsp; &nbsp;return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><strong>优先队列（堆）</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class cmp</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">bool operator()(int a, int b){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;// 注意这里！！！！！</span><br><span class="line">return a &gt; b;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">// 对于类 重写 bool operator&lt;(const Node&amp;) const{}即可</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int weigh; </span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; apples;</span><br><span class="line"> &nbsp; &nbsp;apples.push(2);</span><br><span class="line"> &nbsp; &nbsp;apples.push(1);</span><br><span class="line"> &nbsp; &nbsp;apples.push(8);</span><br><span class="line"> &nbsp; &nbsp;apples.push(4);</span><br><span class="line"> &nbsp; &nbsp;apples.push(9);</span><br><span class="line"> &nbsp; &nbsp;apples.push(3);</span><br><span class="line"> &nbsp; &nbsp; // output: 1 2 3 4 8 9</span><br><span class="line"> &nbsp; &nbsp;return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>**		**对于pair&lt;int,int&gt; 优先比较first</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><table>
<thead>
<tr>
<th><strong>常用</strong></th>
<th><strong>map</strong></th>
<th><strong>multiply_map</strong></th>
<th><strong>unordered_map</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层原理</strong></td>
<td><strong>红黑树</strong></td>
<td><strong>红黑树</strong></td>
<td><strong>哈希表</strong></td>
</tr>
<tr>
<td><strong>时间复杂度（查找）</strong></td>
<td><strong>O(logn)</strong></td>
<td><strong>O(logn)</strong></td>
<td><strong>O(1)</strong></td>
</tr>
<tr>
<td><strong>是否有序</strong></td>
<td><strong>有序</strong></td>
<td><strong>有序</strong></td>
<td><strong>无序</strong></td>
</tr>
</tbody></table>
<p><strong>一般使用unordere_map</strong></p>
<h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p><strong>去重</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">unique(a, a + n); // 返回去重后数组的最后一个元素的后一个迭代器</span><br></pre></td></tr></tbody></table></figure>

<h2 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">nth_element(vec.begin(), vec.begin() + k, vec.end() /*, lamda*/);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>将数组中第k + 1大的元素放到vec[k]的位置上</strong></p>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 使用欧几里得算法计算最大公约数</span><br><span class="line">int gcd(int a, int b) {</span><br><span class="line"> &nbsp; &nbsp;while (b != 0) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;a %= b;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;swap(a, b);</span><br><span class="line"> &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp;return a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 计算最小公倍数</span><br><span class="line">int lcm(int a, int b) {</span><br><span class="line"> &nbsp; &nbsp;return a * b / gcd(a, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>容斥原理</strong>：<ul>
<li>**计算小于等于 **<code>x</code> 的丑数的数量，即可以被 <code>a</code> 或 <code>b</code> 或 <code>c</code> 整除的数的数量。</li>
<li><strong>这可以通过以下公式计算：</strong><br><strong>count= 𝑥 / 𝑎+𝑥 / 𝑏+𝑥 / 𝑐−𝑥 / lcm(𝑎,𝑏)−𝑥 / lcm(𝑎,𝑐)−𝑥 / lcm(𝑏,𝑐)+𝑥 / lcm(𝑎,𝑏,𝑐)</strong></li>
<li><strong>其中，</strong><code>lcm</code> 表示最小公倍数。</li>
</ul>
</li>
</ol>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// Question:</span><br><span class="line">// 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line"> &nbsp; &nbsp;int trap(vector&lt;int&gt;&amp; height) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;int ans = 0;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;height.insert(height.begin(), 0);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;height.push_back(0);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;int n = height.size();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;stack&lt;int&gt; st;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;for(int i = 0; i &lt; n; i++){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while(!st.empty() &amp;&amp; height[i] &gt; height[st.top()]){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int tmp = st.top();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st.pop();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(!st.empty()){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int h = min(height[st.top()], height[i]) - height[tmp];</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int w = i - st.top() - 1;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans += h * w;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st.push(i);</span><br><span class="line"> &nbsp; &nbsp; &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;return ans;</span><br><span class="line"> &nbsp;  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p><a href="https://www.luogu.com.cn/problem/P1886">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 5;</span><br><span class="line">deque&lt;int&gt; maxq;</span><br><span class="line">deque&lt;int&gt; minq;</span><br><span class="line"></span><br><span class="line">int n, k;</span><br><span class="line">int arr[N], min_ans[N], max_ans[N];</span><br><span class="line">void push(int x){</span><br><span class="line">while(!maxq.empty() &amp;&amp; maxq.back() &lt; x){</span><br><span class="line">maxq.pop_back();</span><br><span class="line">}</span><br><span class="line">maxq.push_back(x);</span><br><span class="line"></span><br><span class="line">while(!minq.empty() &amp;&amp; minq.back() &gt; x){</span><br><span class="line">minq.pop_back();</span><br><span class="line">}</span><br><span class="line">minq.push_back(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void pop(int x){</span><br><span class="line">if(maxq.front() == x) maxq.pop_front();</span><br><span class="line">if(minq.front() == x) minq.pop_front();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int get_min(){</span><br><span class="line">return minq.front();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int get_max(){</span><br><span class="line">return maxq.front();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">for(int i = 0; i &lt; n; i++){</span><br><span class="line">scanf("%d", &amp;arr[i]);</span><br><span class="line">}</span><br><span class="line">for(int i = 0; i &lt; k; i++){</span><br><span class="line">push(arr[i]);</span><br><span class="line">}</span><br><span class="line">min_ans[0] = get_min();</span><br><span class="line">max_ans[0] = get_max();</span><br><span class="line">int i = 0, j = k;</span><br><span class="line">while(j &lt; n){</span><br><span class="line">pop(arr[i++]);</span><br><span class="line">push(arr[j++]);</span><br><span class="line">min_ans[i] = get_min();</span><br><span class="line">max_ans[i] = get_max();</span><br><span class="line">}</span><br><span class="line">for(int i = 0; i &lt;= n - k; i++){</span><br><span class="line">cout &lt;&lt; min_ans[i] &lt;&lt; " ";</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; '\n';</span><br><span class="line">for(int i = 0; i &lt;= n - k; i++){</span><br><span class="line">cout &lt;&lt; max_ans[i] &lt;&lt; " ";</span><br><span class="line">}</span><br><span class="line">return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h1><p><a href="https://www.luogu.com.cn/problem/P2249">二分查找模板</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2678">二分答案模板</a></p>
<p><strong>upper_bound 找到首个大于的迭代器</strong></p>
<p><strong>lower_bound 找到首个不小于的迭代器</strong></p>
<p><strong>最小的….的最大….一般想到用二分答案</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int judge(){</span><br><span class="line">    // todo</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">while(left &lt;= right){</span><br><span class="line">    // todo</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if(judge(mid)){</span><br><span class="line">        ans = mid;</span><br><span class="line">        left = mid + 1;</span><br><span class="line">    }else{</span><br><span class="line">        right = mid - 1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p><a href="https://www.luogu.com.cn/problem/P8218">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 保证数组第一个元素为0，即arr[0] = 0, prefix[0] = 0</span><br><span class="line">arr[10000]; //数据</span><br><span class="line">prefix[10000]; //前缀和</span><br><span class="line">prefix[i] = prefix[i - 1] + arr[i]; // 初始化前缀和数组</span><br><span class="line">// l - r的前缀和即为</span><br><span class="line">ans = prefix[r] - prefix[l - 1];</span><br></pre></td></tr></tbody></table></figure>

<h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><p><a href="https://www.luogu.com.cn/problem/P2367">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">for.....</span><br><span class="line">	d[i] = arr[i] - arr[i - 1];</span><br><span class="line">// 假设a - b段arr加1</span><br><span class="line">d[a]++; // a后面所有都受到了影响...</span><br><span class="line">d[b+1]--; // 终止b+1后面受到的影响...</span><br><span class="line"></span><br><span class="line">//将加1使用到arr上</span><br><span class="line">for.....</span><br><span class="line">	arr[i] = d[i] + arr[i - 1];</span><br></pre></td></tr></tbody></table></figure>

<p><strong>扩展(二维模式)</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 可以画一个图看一下</span><br><span class="line">// (x1, y1) - (x2, y2)进行了操作</span><br><span class="line">d[x][y1]++; // x从x1到x2</span><br><span class="line">d[x][y2 + 1]--; // x上同</span><br><span class="line"></span><br><span class="line">mmap[x][y] = mmap[x][y - 1] + d[x][y]; //按行扫描 </span><br></pre></td></tr></tbody></table></figure>

<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p><strong>应用范围: 数组空间无限大，只关注相对距离的问题</strong></p>
<p><strong>template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 范围为1 ~ 10^9，但只用到了10^5个数</span><br><span class="line">a[10005]; // 存储下标</span><br><span class="line">sort(a, a + n);</span><br><span class="line">int len = unique(a, a + n) - a; //去重并获得新的去重数组的长度</span><br></pre></td></tr></tbody></table></figure>

<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p><a href="https://www.luogu.com.cn/problem/P3375">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 5;</span><br><span class="line">string s1, s2;</span><br><span class="line">int nxt[N];</span><br><span class="line"></span><br><span class="line">void get_nxt(){</span><br><span class="line">	int j = 0;</span><br><span class="line">	for(int i = 1; i &lt; s2.size(); i++){</span><br><span class="line">		while(s2[j] != s2[i] &amp;&amp; j &gt; 0){</span><br><span class="line">			j = nxt[j - 1];</span><br><span class="line">		}</span><br><span class="line">		if(s2[i] == s2[j]) j++;</span><br><span class="line">		nxt[i] = j;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">	get_nxt();</span><br><span class="line">	int i = 0, j = 0;</span><br><span class="line">	while(i &lt; s1.size()){</span><br><span class="line">		if(s1[i] == s2[j]){</span><br><span class="line">			i++, j++;</span><br><span class="line">		}else{</span><br><span class="line">			if(j &gt; 0) j = nxt[j - 1];</span><br><span class="line">			else if(j == 0) i++;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		if(j == s2.size()){</span><br><span class="line">			cout &lt;&lt; i - s2.size() + 1 &lt;&lt; '\n';</span><br><span class="line">			j = nxt[j - 1];</span><br><span class="line">		} </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for(i = 0; i &lt; s2.size(); i++){</span><br><span class="line">		cout &lt;&lt; nxt[i] &lt;&lt; " ";</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<p>Update: 水了个国二😆</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/b2626942.html</url>
    <content><![CDATA[<p>背包九讲经典问题！！！</p>
<span id="more"></span>

<p><strong>DP做题顺序</strong></p>
<ol>
<li><strong>确定dp数组（dp table）以及下标的含义</strong></li>
<li><strong>确定递推公式</strong></li>
<li><strong>dp数组如何初始化</strong></li>
<li><strong>确定遍历顺序</strong></li>
<li><strong>举例推导dp数组</strong></li>
</ol>
<blockquote>
<p><strong>以下背包均用一维数组来完成</strong></p>
<p><strong>多少种方法</strong> <code>dp[j] += dp[j - num[i]]</code></p>
</blockquote>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h2><p><a href="https://www.acwing.com/problem/content/2/">模板</a></p>
<p><strong>二维数组推算公式</strong> <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 滚动数组法</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int m,n;</span><br><span class="line">int w[10000], v[10000];</span><br><span class="line">int dp[10000]; // 0 - n</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	for(int i = 0; i &lt; m; ++i){</span><br><span class="line">		scanf("%d", &amp;w[i]);</span><br><span class="line">	}</span><br><span class="line">	for(int i = 0; i &lt; m; ++i){</span><br><span class="line">		scanf("%d", &amp;v[i]);</span><br><span class="line">	}</span><br><span class="line">	// 先遍历物品，再遍历容量，容量要倒序遍历</span><br><span class="line">	for(int i = 0; i &lt; m; ++i){</span><br><span class="line">		for(int j = n; j &gt;= w[i]; --j){</span><br><span class="line">			dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p><a href="https://www.acwing.com/problem/content/3/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line">int m,n;</span><br><span class="line">ll w[10000], v[10000];</span><br><span class="line">ll dp[10000]; // 0 - n</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	for(int i = 0; i &lt; m; ++i){</span><br><span class="line">		scanf("%d %d", &amp;w[i], &amp;v[i]);</span><br><span class="line">	}</span><br><span class="line">	// 与01背包问题不同，容量按照正序遍历</span><br><span class="line">	for(int i = 0; i &lt; m; ++i){</span><br><span class="line">		for(int j = w[i]; j &lt;= n; ++j){</span><br><span class="line">			dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p><a href="https://www.luogu.com.cn/problem/P1776">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 5, MAXW = 4e4 + 5; // 开大一点建议....</span><br><span class="line">int n, W;</span><br><span class="line">int v[N], w[N];</span><br><span class="line">int dp[MAXW];</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; W;</span><br><span class="line">	int v_val, w_val, m_val;</span><br><span class="line">	int cnt = 0;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; v_val &gt;&gt; w_val &gt;&gt; m_val;</span><br><span class="line">		for(int k = 1; k &lt;= m_val; k &lt;&lt;= 1){</span><br><span class="line">            // 二进制优化</span><br><span class="line">			v[++cnt] = k * v_val;</span><br><span class="line">			w[cnt] = k * w_val;</span><br><span class="line">			m_val -= k;</span><br><span class="line">		}</span><br><span class="line">		if(m_val &gt; 0){</span><br><span class="line">			v[++cnt] = m_val * v_val;</span><br><span class="line">			w[cnt] = m_val * w_val;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for(int i = 1; i &lt;= cnt; i++){</span><br><span class="line">		for(int j = W; j &gt;= w[i]; j--){</span><br><span class="line">				dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[W];</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="有依赖背包问题"><a href="#有依赖背包问题" class="headerlink" title="有依赖背包问题"></a>有依赖背包问题</h2><p><a href="https://www.luogu.com.cn/problem/P1064">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 3.2e4 + 5, M = 65;</span><br><span class="line">int cost[M], val[M], king[M], fans[M];</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; follow;</span><br><span class="line">int dp[N];</span><br><span class="line">int n, m;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	follow.resize(m + 1);</span><br><span class="line">	int v, belong;</span><br><span class="line">	for(int i = 1; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; cost[i] &gt;&gt; v &gt;&gt; belong;</span><br><span class="line">		val[i] = v * cost[i];</span><br><span class="line">		if(belong == 0) king[i] = 1;</span><br><span class="line">		else{</span><br><span class="line">			fans[belong]++;</span><br><span class="line">			follow[belong].push_back(i);</span><br><span class="line">		} </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for(int i = 1, fan1, fan2; i &lt;= m; i++){</span><br><span class="line">		if(king[i]){</span><br><span class="line">			for(int j = n; j &gt;= cost[i]; j--){</span><br><span class="line">					dp[j] = max(dp[j - cost[i]] + val[i], dp[j]);</span><br><span class="line">					fan1 = fans[i] &gt;= 1? follow[i][0]: -1;</span><br><span class="line">					fan2 = fans[i] &gt;= 2? follow[i][1]: -1;</span><br><span class="line">					if(fan1 != -1 &amp;&amp; j &gt;= cost[i] + cost[fan1]){</span><br><span class="line">						dp[j] = max(dp[j - cost[i] - cost[fan1]] + val[i] + val[fan1], dp[j]);</span><br><span class="line">					}</span><br><span class="line">					if(fan1 != -1 &amp;&amp; j &gt;= cost[i] + cost[fan2]){</span><br><span class="line">						dp[j] = max(dp[j - cost[i] - cost[fan2]] + val[i] + val[fan2], dp[j]);</span><br><span class="line">					}</span><br><span class="line">					if(fan1 != -1 &amp;&amp; fan2 != -1 &amp;&amp; j &gt;= cost[i] + cost[fan1] + cost[fan2]){</span><br><span class="line">						dp[j] = max(dp[j - cost[i] - cost[fan1] - cost[fan2]] + val[i] + val[fan1] + val[fan2], dp[j]);</span><br><span class="line">					}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><p><a href="https://www.luogu.com.cn/problem/P1757">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int N = 1005, M = 1005;</span><br><span class="line">ll dp[M];</span><br><span class="line">int w[N], v[N], t[N]; // t--&gt;分组 </span><br><span class="line">int n, m;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; t[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for(int start = 1, end = 2; start &lt;= n; ){</span><br><span class="line">		while(t[end] == t[end - 1] &amp;&amp; end &lt;= n){</span><br><span class="line">			end++;</span><br><span class="line">		}</span><br><span class="line">		for(int j = m; j &gt;= 0; j--){</span><br><span class="line">			for(int k = start; k &lt; end; k++){</span><br><span class="line">				if(j - w[k] &gt;= 0) dp[j] = max(dp[j - w[k]] + v[k], dp[j]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		start = end++;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; dp[m];</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><p><a href="https://www.acwing.com/problem/content/7/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 5, V = 1e5 + 5; //要开大一点.....</span><br><span class="line"></span><br><span class="line">int v[N], w[N];</span><br><span class="line">int dp[V];</span><br><span class="line">int n, m;</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	int a, b, s;</span><br><span class="line">	int cnt = 0;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">		if(s == -1) s = 1; // 01转换为多重</span><br><span class="line">		else if(s == 0) s = m / a; // 完全转换为多重...</span><br><span class="line">		for(int k = 1; k &lt;= s; k *= 2){</span><br><span class="line">			v[++cnt] = k * a;</span><br><span class="line">			w[cnt] = k * b;</span><br><span class="line">			s -= k;</span><br><span class="line">		}</span><br><span class="line">		if(s &gt; 0){</span><br><span class="line">			v[++cnt] = s * a;</span><br><span class="line">			w[cnt] = s * b;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for(int i = 1; i &lt;= cnt; i++){</span><br><span class="line">		for(int j = m; j &gt;= v[i]; j--){</span><br><span class="line">			dp[j] = max(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; dp[m];</span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><p><a href="https://www.acwing.com/problem/content/8/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1005, V = 105, M = 105;</span><br><span class="line">int v[N], m[N], w[N];</span><br><span class="line">int dp[V][M];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	int a, b, c;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">	for(int i = 1; i &lt;= a; i++){</span><br><span class="line">		cin &gt;&gt; v[i] &gt;&gt; m[i] &gt;&gt; w[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	for(int i = 1; i &lt;= a; i++){</span><br><span class="line">		for(int j = b; j &gt;= v[i]; j--){</span><br><span class="line">			for(int k = c; k &gt;= m[i]; k--){</span><br><span class="line">				dp[j][k] = max(dp[j][k], dp[j - v[i]][k - m[i]] + w[i]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[b][c];</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树论</title>
    <url>/b8c50a86.html</url>
    <content><![CDATA[<p>最难的一集…..</p>
<span id="more"></span>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p><a href="https://www.luogu.com.cn/problem/P3374">模板1</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3368">模板2</a></p>
<p><strong>对于单点改变的题目，求动态区间和</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int n, m, tree[N];</span><br><span class="line"></span><br><span class="line">int lowbit(int x){</span><br><span class="line">	return x &amp; (-x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void update(int loc, int k){</span><br><span class="line">	while(loc &lt;= n){</span><br><span class="line">		tree[loc] += k;</span><br><span class="line">		loc += lowbit(loc);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int query(int loc){</span><br><span class="line">	int ans = 0;</span><br><span class="line">	while(loc){</span><br><span class="line">		ans += tree[loc];</span><br><span class="line">		loc -= lowbit(loc);</span><br><span class="line">	}</span><br><span class="line">	return ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现差分数组</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	}</span><br><span class="line">	for(int i = 1; i &lt;= m; i++){</span><br><span class="line">		int a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		if(a == 1){</span><br><span class="line">			int x, y, k;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">			update(x, k);</span><br><span class="line">			update(y + 1, -k);</span><br><span class="line">		}</span><br><span class="line">		if(a == 2){</span><br><span class="line">			int x;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			cout &lt;&lt; arr[x] + query(x) &lt;&lt; '\n';</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><p><a href="https://www.luogu.com.cn/problem/P3379">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 5e5 + 5;</span><br><span class="line">int n, m, s;</span><br><span class="line"></span><br><span class="line">int dep[N];</span><br><span class="line">int jump[N][20];</span><br><span class="line">vector&lt;int&gt; G[N];</span><br><span class="line">void dfs(int x, int fa)</span><br><span class="line">{</span><br><span class="line">	jump[x][0] = fa;</span><br><span class="line">	dep[x] = dep[fa] + 1;</span><br><span class="line">	for(int i = 1; i &lt; 20; i++){</span><br><span class="line">		jump[x][i] = jump[jump[x][i - 1]][i - 1];</span><br><span class="line">	}</span><br><span class="line">	for(int i = 0; i &lt; G[x].size(); i++){</span><br><span class="line">		int y = G[x][i];</span><br><span class="line">		if(y != fa){</span><br><span class="line">			dfs(y, x);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">int LCA(int x, int y){</span><br><span class="line">	if(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">	while(dep[x] &gt; dep[y]){</span><br><span class="line">		x = jump[x][(int)log2(dep[x] - dep[y])];</span><br><span class="line">	}</span><br><span class="line">	if(x == y) return x;</span><br><span class="line">	for(int i = log2(dep[x]); i &gt;= 0; i--){</span><br><span class="line">		if(jump[x][i] != jump[y][i]){</span><br><span class="line">			x = jump[x][i];</span><br><span class="line">			y = jump[y][i];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	return jump[x][0];</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	int x, y;</span><br><span class="line">	for(int i = 0; i &lt; n - 1; i++){</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		G[x].push_back(y);</span><br><span class="line">		G[y].push_back(x);</span><br><span class="line">	}</span><br><span class="line">	dfs(s, 0);</span><br><span class="line">	for(int i = 0; i &lt; m; i++){</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		int ans = LCA(x, y);</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; '\n';</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p><strong>两次dfs，但是好像还是有点问题，待更正……</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5 + 5;</span><br><span class="line">struct Edge{</span><br><span class="line">	int v, w, next;</span><br><span class="line">}edge[N];</span><br><span class="line"></span><br><span class="line">// 链式前向星 </span><br><span class="line">int head[N];</span><br><span class="line">int cnt;</span><br><span class="line">void add_edge(int u, int v, int w){</span><br><span class="line">	edge[++cnt].v = v;</span><br><span class="line">	edge[cnt].w = w;</span><br><span class="line">	edge[cnt].next = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int n, vis[N], fa[N];</span><br><span class="line">ll dis[N];</span><br><span class="line">void dfs(int x, int d, int&amp; fnode){</span><br><span class="line">	vis[x] = 1;</span><br><span class="line">	dis[x] = d;</span><br><span class="line">	for(int i = head[x]; i; i = edge[i].next){</span><br><span class="line">		int y = edge[i].v;</span><br><span class="line">		int w = edge[i].w;</span><br><span class="line">		if(!vis[y]){</span><br><span class="line">			fa[y] = x;</span><br><span class="line">			dfs(y, d + w, fnode);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	if(d &gt; dis[fnode]){</span><br><span class="line">		fnode = x;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int u, v, w;</span><br><span class="line">	for(int i = 1; i &lt;= n - 1; i++){</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		add_edge(u, v, w);</span><br><span class="line">		add_edge(v, u, w);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	int fnode = 1;</span><br><span class="line">	dfs(1, 0, fnode);</span><br><span class="line"></span><br><span class="line">	int o_fnode = fnode;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	dfs(fnode, 0, o_fnode);</span><br><span class="line"></span><br><span class="line">	ll diameter = dis[o_fnode];</span><br><span class="line">	cout &lt;&lt; diameter &lt;&lt; '\n';</span><br><span class="line"></span><br><span class="line">	// 记录路径上的边</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int node = o_fnode;</span><br><span class="line">    while (node != fnode) {</span><br><span class="line">        node = fa[node];</span><br><span class="line">        cnt++;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; cnt - 1;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>update….</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程</title>
    <url>/87698413.html</url>
    <content><![CDATA[<p>进程在Linux系统中扮演着至关重要的角色。它不仅是系统资源管理和任务调度的基本单位，还直接影响着系统的性能和稳定性。本文将详细探讨Linux中的进程，包括其概念、生命周期、内核数据结构、以及与进程管理相关的常用API函数，以便读者更深入地理解进程在Linux中的重要性和实现机制。</p>
<span id="more"></span>

<h1 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h1><p>进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后，它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。</p>
<p>Linux系统下的所有进程都是由其父进程创建而来，譬如在 shell 终端通过命令的方式执行一个程序./app，那么 app进程就是由 shell 终端进程创建出来的，shell 终端就是该进程的父进程。init 进程，它是 Linux 系统启动之后运行的第一个进程，它管理着系统上所有其它进程，init 进程是由内核启动，因此理论上说它没有父进程。</p>
<p>程序结束其实就是进程终止，进程终止的方式通常有多种，大体上分为正常终止和异常终止，正常终止</p>
<p>包括：</p>
<ul>
<li><p>main()函数中通过 return 语句返回来终止进程；</p>
</li>
<li><p>应用程序中调用 exit()函数终止进程；</p>
</li>
<li><p>应用程序中调用<code>_exit()</code>终止进程；</p>
</li>
</ul>
<p>异常终止包括：</p>
<ul>
<li>应用程序中调用 abort()函数终止进程；</li>
<li>进程接收到一个信号，譬如 SIGKILL 信号。</li>
</ul>
<p><strong>exit和_exit的区别：</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> = atexit + _exit;</span><br><span class="line"><span class="comment">// atexit: 调用终止处理+刷新IO（注册,最后exit执行按先进后出顺序来）</span></span><br><span class="line"><span class="comment">// _exit: 进入内核执行清理工作</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>exit和return的区别：</strong></p>
<p>exit会进入内核，而return只是一个返回，把指挥权交给上层调用，return也会调用终止处理函数并刷新缓冲</p>
<h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><img src="/undefined/image-20240702212909754.png" class="">

<p>进程中相关属性</p>
<ol>
<li><p>pid</p>
<p>每个进程都有自己唯一的标识：进程号（进程 ID、PID）。</p>
</li>
<li><p>pgid</p>
<p>每个进程除了有一个进程 ID、父进程 ID 之外，还有一个进程组 ID，用于标识该进程属于哪一个进程组，进程组是一个或多个进程的集合。每一个进程组有一个组长进程，组长进程的 ID 就等于进程组 ID；组长进程不能再创建新的进程组；只要进程组中还存在一个进程，则该进程组就存在，这与其组长进程是否终止无关。</p>
</li>
<li><p>sid</p>
<p>会话是一个或多个进程组的集合，其与进程组、进程之间的关系如</p>
<p>下图所示：</p>
<img src="/undefined/image-20240702213346684.png" class="">

<p>一个会话可以有控制终端、也可没有控制终端，在有控制终端的情况下也只能连接一个控制终端。</p>
<p>对于会话来说，会话的首领进程的进程组 ID 将作为该会话的标识，也就是会话 ID（sid），在默认情况下，新创建的进程会继承父进程的会话 ID。</p>
</li>
</ol>
<p>相关操作</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>



<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>获取进程中的环境变量</p>
<ol>
<li><p>environ变量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 代码中使用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ; <span class="comment">// 申明外部全局变量 environ</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>getenv()函数</p>
<p><code>man 3</code> 查看使用</p>
</li>
<li><p>通过main函数参数获取</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span> <span class="comment">// 不推荐，有些系统不支持</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>程序启动时可设置环境变量<code>NAME=value ./app</code></p>
<p>常用操作</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// man 3 查看使用</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 设置环境变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>; <span class="comment">// 修改string会修改环境变量</span></span><br><span class="line"><span class="comment">// 修改name和value不会修改环境变量，创建了一个缓冲区指向他们</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clearenv</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">clearenv()函数内部的做法其实就是将environ赋值为NULL。在某些情况下，使用setenv()函数和clearenv()</span></span><br><span class="line"><span class="comment">函数可能会导致程序内存泄漏。setenv()函数会为环境变量分配一块内存缓冲区，随之称为进程的一部分；而调用 clearenv()函数时没有释放该缓冲区（clearenv()调用并不知晓该缓冲区的存在，故而也无法将其释放）</span></span><br><span class="line"><span class="comment">反复调用者两个函数的程序，会不断产生内存泄漏。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h1><img src="/undefined/image-20240701181207013.png" class="">

<h1 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h1><p><code>fork</code>函数</p>
<ol>
<li>一次fork两个返回值，0为子进程，大于0为父进程</li>
<li>fork进程创建了与原来进程几乎完全相同的进程（复制父进程的代码段，堆，栈）</li>
<li>子进程从fork调用后开始执行</li>
</ol>
<p><code>vfork</code>函数：与父进程共有代码段，堆，栈</p>
<p>ps: 创建的子进程退出需要使用_exit而不是exit</p>
<p>对文件的共享</p>
<img src="/undefined/image-20240701202424640.png" class="">

<p>父子进程fd指向同一个文件表</p>
<p>fork 后子进程会继承父进程绑定的信号处理函数，若调用 exec 加载新程序后，就不会在继承这个信号处理函数了fork 后子进程会继承父进程的信号掩码，执行 exec 后仍会继承这个信号掩码</p>
<h1 id="监视子进程"><a href="#监视子进程" class="headerlink" title="监视子进程"></a>监视子进程</h1><p><strong>孤儿进程：</strong>父进程先死且未回收子进程，子进程的父进程会交给init进程（图形化界面不一样）</p>
<p><strong>僵尸进程：</strong>子进程先死但父进程未回收，此时使用kill也无法杀死</p>
<p>SIGCHLD 信号发送条件：</p>
<ul>
<li>当父进程的某个子进程终止时，父进程会收到 SIGCHLD 信号；</li>
<li>当父进程的某个子进程因收到信号而停止（暂停运行）或恢复时，内核也可能向父进程发送该信号。</li>
</ul>
<p>监视子进程函数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值是回收的子进程的pid号, man查看</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>; <span class="comment">// 只能阻塞等待</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>; <span class="comment">// 可非阻塞</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h1><p><code>man</code>进行查看</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">// 以下都是对execve的封装，path表示路径，file表示若本目录没找到会在PATH里找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>守护进程（Daemon）也称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些事情的发生，主要表现为以下两个特点：</p>
<ol>
<li>长期运行</li>
<li>与控制终端分离</li>
</ol>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><img src="/undefined/image-20240702222117113.png" class="">

<ul>
<li><p>UNIX IPC：管道、FIFO、信号；</p>
</li>
<li><p>System V IPC：信号量、消息队列、共享内存；</p>
</li>
<li><p>POSIX IPC：信号量、消息队列、共享内存（最快）；</p>
</li>
<li><p>Socket IPC：基于 Socket 进程间通信。（网络）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
</search>
