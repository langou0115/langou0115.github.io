<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++基础语法</title>
    <url>/3c96480a.html</url>
    <content><![CDATA[<p>本文只是记录一些常见的C++语法和细节，包括类，泛型编程，右值引用，移动语义，完美转发。方便日后进行复习使用</p>
<span id="more"></span>

<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> {red, green, blue};</span><br><span class="line"></span><br><span class="line"><span class="comment">// color cc = 1; // invalid</span></span><br><span class="line">color cc = <span class="built_in">color</span>(<span class="number">1</span>); <span class="comment">// cc = green</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用是指针常量的伪装。</p>
<p>引用是编译器提供的一个有用且安全的工具，去除了指针的一些缺点，禁止了部分不安全的操作。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = a;</span><br><span class="line"><span class="comment">// 编译器将其转换为 int *const ref = &amp;a;</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>C++允许不同函数形式有同一种名称，C++编译器会将其名称与参数进行拼接在一起，但是C编译器不会，为了调用C的函数需要使用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"c"</span>{</span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>来声明里面的函数是C语言编译的形式。</p>
<p>如果使用C语言编译头文件</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus <span class="comment">// 防止C编译器报错</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// all of your legacy C code here</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p><code>dynamic_cast</code>运算符用于将指向基类的指针转换为派生类的指针。它不能回答“指针指向的是什么类类型的对象”的问题，但能回答“是否可以安全地将对象的地址赋给特定类型的指针”的问题。用于<strong>RTTI</strong>（运行时类型识别）机制。</p>
<p>对于RTTI，也可以使用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">A a;</span><br><span class="line"><span class="built_in">typeid</span>(a).<span class="built_in">name</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>来判断类型，<code>typeid</code>也重载了==，!=运算符</p>
<p>语法使用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">派生类指针 = <span class="built_in">dynamic_cast</span>&lt;派生类类型 *&gt;(基类指针);</span><br></pre></td></tr></tbody></table></figure>

<p>如果转换成功，<code>dynamic_cast</code>返回对象的地址；如果失败，返回<code>nullptr</code>；</p>
<p>注意事项：</p>
<ol>
<li><code>dynamic_cast</code>只适用于包含虚函数的类。</li>
<li><code>dynamic_cast</code>可以将派生类指针转换为基类指针，这种做法通常没有意义。</li>
<li><code>dynamic_cast</code>可以用于引用，但没有与空指针对应的引用值，如果转换请求不正确，会出现<code>bad_cast</code>异常。</li>
</ol>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>⽤于各种隐式转换，⽐如⾮const转const，void*转指针等, static_cast能⽤于多态向上转化，如果向下转能成功但是不安全，结果未知；</p>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>⽤于将const变量转为⾮const</p>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>⼏乎什么都可以转，⽐如将int转指针，可能会出问题，尽量少⽤；</p>
<h1 id="异常与断言"><a href="#异常与断言" class="headerlink" title="异常与断言"></a>异常与断言</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>基础使用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    <span class="keyword">if</span>(...) <span class="keyword">throw</span> ..;</span><br><span class="line">}<span class="built_in">catch</span>(..){</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>若抛出异常未catch，程序会挂掉</p>
<img src="/3c96480a/image-20240728230401601.png" class="">

<p><strong>重点关注</strong></p>
<ol>
<li><p><strong>std::bad_alloc</strong></p>
<p>如果内存不足，调用 <code>new</code> 会产生异常，导致程序中止；如果在 <code>new</code> 关键字后面加 <code>(std::nothrow)</code> 选项，则返回 <code>nullptr</code>，不会产生异常。</p>
</li>
<li><p><strong>std::bad_cast</strong> </p>
<p>dynamic_cast 可以用于引用，但是，没有与空指针对应的引用值，如果转换请求不正确，会出现 std::bad_cast 异常。</p>
</li>
<li><p><strong>std::bad_typeid</strong> </p>
<p>假设有表达式 <code>typeid(*ptr)</code>，当 <code>ptr</code> 是空指针时，如果 <code>ptr</code> 是多态的类型，将引发 std::bad_typeid 异常。</p>
</li>
</ol>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>语法：<code>assert(表达式);</code></p>
<p>断言就是判断(表达式)的值，如果为 0 (false)，程序将调用 abort() 函数中止，如果为非 0 (true)，程序继续执行。</p>
<p>断言可以提高程序的可读性，帮助程序员定位违反了某些前提条件的错误。断言失败不是异常，不能捕获</p>
<p>C++11 新增了静态断言 <code>static_assert</code>，用于在编译时检查源代码。</p>
<p>使用静态断言不需要包含头文件。</p>
<p>语法：<code>static_assert(常量表达式, 提示信息);</code></p>
<p>注意：<code>static_assert</code> 的第一个参数是常量表达式。而 <code>assert</code> 的表达式既可以是常量，也可以是变量。</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>已被摒弃，在复制和赋值时原auto_ptr会变为空</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"p1: "</span> &lt;&lt; p1.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"p2: "</span> &lt;&lt; p2.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; p4;</span><br><span class="line">p4 = p3;</span><br><span class="line">cout &lt;&lt; <span class="string">"p3: "</span> &lt;&lt; p3.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"p4: "</span> &lt;&lt; p4.<span class="built_in">get</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">p1: 0</span><br><span class="line">p2: 0x55555556aeb0</span><br><span class="line">p3: 0</span><br><span class="line">p4: 0x55555556b2e0</span><br></pre></td></tr></tbody></table></figure>

<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><strong>unique_ptr</strong> 对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是 1，禁止了拷贝构造函数和赋值运算符，<strong>unique_ptr</strong> 对象销毁时会释放其持有的堆内存。可以使用以下方式初始化一个<strong>unique_ptr</strong>对象：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//初始化方式1</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式2</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; sp2;</span><br><span class="line">sp2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">123</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式3 更推荐！！！ C++14</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; sp3 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>可通过std::move来转移所有权</p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><strong>std::shared_ptr</strong> 持有的资源可以在多个 <strong>std::shared_ptr</strong> 之间共享，每多一个 <strong>std::shared_ptr</strong> 对资源的引用，资源引用计数将增加 1，每一个指向该资源的 <strong>std::shared_ptr</strong> 对象析构时，资源引用计数减 1，最后一个 <strong>std::shared_ptr</strong> 对象析构时，发现资源计数为 0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。其中引用计数的实现利用了指针，将计数变量存储在堆上，所以共享指针的shared_ptr 就存储一个指向堆内存的指针。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//初始化方式1</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式2</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;A&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">sp2.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">    std::shared_ptr&lt;A&gt; sp3 = sp1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>

<p>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个 <strong>std::shared_ptr</strong> 对象给外部使用，C++ 新标准也为我们考虑到了这一点，有如此需求的类只要继承自 <strong>std::enable_shared_from_this</strong> 模板对象即可。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"A constructor"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"A destructor"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">getSelf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="built_in">getSelf</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>陷阱一：不应该共享栈对象的 this 给智能指针对象</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">A a;</span><br><span class="line">std::shared_ptr&lt;A&gt; sp2 = a.<span class="built_in">getSelf</span>(); <span class="comment">// 崩溃，a调用完后会析构</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>陷阱二：避免 std::enable_shared_from_this 的循环引用问题</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>： <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt;{</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_SelfPtr = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>                 m_i;</span><br><span class="line">    std::shared_ptr&lt;A&gt;  m_SelfPtr;  </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::shared_ptr&lt;A&gt; <span class="title">spa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">        spa-&gt;<span class="built_in">func</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 会内存泄漏</span></span><br><span class="line">    <span class="comment">// 必须销毁 A 才能销毁其成员变量 m_SelfPtr，而销毁 m_SelfPtr 必须先销毁 A。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>shared_ptr手写实现</strong></p>
<ol>
<li>构造函数中计数初始化为1；</li>
<li>拷⻉构造函数中计数值加1；</li>
<li>赋值运算符中，左边的对象引⽤计数减1，右边的对象引⽤计数加1；</li>
<li>析构函数中引⽤计数减1；</li>
<li>在赋值运算符和析构函数中，如果减1后为0，则调⽤ delete 释放对象。</li>
</ol>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><strong>std::weak_ptr</strong> 是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助 <strong>std::shared_ptr</strong> 工作。</p>
<p><strong>std::weak_ptr</strong> 可以从一个 <strong>std::shared_ptr</strong> 或另一个 <strong>std::weak_ptr</strong> 对象构造，<strong>std::shared_ptr</strong> 可以直接赋值给 <strong>std::weak_ptr</strong> ，也可以通过 <strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 函数来获得 <strong>std::shared_ptr</strong>。它的构造和析构不会引起引用计数的增加或减少。<strong>std::weak_ptr</strong> 可用来解决 <strong>std::shared_ptr</strong> 相互引用时的死锁问题（即两个<strong>std::shared_ptr</strong> 相互引用，那么这两个指针的引用计数永远不可能下降为 0， 资源永远不会释放）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个std::shared_ptr对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数得到一个std::weak_ptr对象</span></span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过赋值运算符得到一个std::weak_ptr对象</span></span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; sp3 = sp1;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过一个std::weak_ptr对象得到另外一个std::weak_ptr对象</span></span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; sp4 = sp2;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">use count: 1</span><br><span class="line">use count: 1</span><br><span class="line">use count: 1</span><br><span class="line">use count: 1</span><br></pre></td></tr></tbody></table></figure>

<p><strong>std::weak_ptr</strong> 不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？<strong>std::weak_ptr</strong> 提供了一个 <strong>expired()</strong> 方法来做这一项检测，返回 true，说明其引用的资源已经不存在了；返回 false，说明该资源仍然存在，这个时候可以使用 <strong>std::weak_ptr</strong> 的 <strong>lock()</strong> 方法得到一个 <strong>std::shared_ptr</strong> 对象然后继续操作资源。</p>
<h2 id="自定义智能指针对象持有的资源的释放函数"><a href="#自定义智能指针对象持有的资源的释放函数" class="headerlink" title="自定义智能指针对象持有的资源的释放函数"></a>自定义智能指针对象持有的资源的释放函数</h2><p>默认情况下，智能指针对象在析构时只会释放其持有的堆内存（调用 delete 或者 delete[]），但是假设这块堆内存代表的对象还对应一种需要回收的资源（如操作系统的套接字句柄、文件句柄等），我们可以通过自定义智能指针的资源释放函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> deletor = [](Socket* pSocket) {</span><br><span class="line">    <span class="comment">//关闭句柄</span></span><br><span class="line">    pSocket-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 你甚至可以在这里打印一行日志...</span></span><br><span class="line">    <span class="keyword">delete</span> pSocket;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Socket, <span class="title">void</span><span class="params">(*)</span><span class="params">(Socket * pSocket)</span>&gt; <span class="title">spSocket</span><span class="params">(<span class="keyword">new</span> Socket(), deletor)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol>
<li><p>创建对象的时候不要在对象名后面加空的圆括号，编译器误认为是声明函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">MyClass <span class="title function_">c</span><span class="params">()</span>;<span class="comment">// 编译器会认为在声明函数</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(); <span class="comment">// 下一句该匿名对象会立即销毁</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>类中有成员为其他类，会先调用类的析构函数再调用成员类的析构函数</p>
</li>
</ol>
<p>初始化列表（C++11之前就有的）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">初始化列表的语法：</span><br><span class="line"></span><br><span class="line">类名(形参列表):成员一(值一), 成员二(值二), ..., 成员<span class="built_in">n</span>(值n) {......}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后再调用拷贝构造函数。</strong></p>
<p><strong>如果成员是常量和引用，必须使用初始化列表，因为常量和引用只能在定义的时候初始化。</strong></p>
<p>构造函数可用作自动类型转换函数，但有时候会导致意外的类型转换。<code>explicit</code> 关键字用于关闭这种自动特性，但仍允许显示转换。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CGirl</span><span class="params">(<span class="type">int</span> bh)</span></span>;</span><br><span class="line"></span><br><span class="line">CGirl g = <span class="number">8</span>;          <span class="comment">// 错误。</span></span><br><span class="line">CGirl g = <span class="built_in">CGirl</span>(<span class="number">8</span>);   <span class="comment">// 显示转换，可以。</span></span><br><span class="line">CGirl g = (CGirl)<span class="number">8</span>;   <span class="comment">// 显示转换，可以。</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><ol>
<li><p>函数以值的方式返回对象时，可能会调用拷贝构造函数（VS 会调用，Linux 不会，g++ 编译器做了优化）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(){</span><br><span class="line">        cout &lt;&lt; <span class="string">"构造函数"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Student</span>(){</span><br><span class="line">        cout &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student &amp;stu){</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造函数"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"show"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function">Student <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Student stu;</span><br><span class="line">    cout &lt;&lt; <span class="string">"funtion Student address: "</span> &lt;&lt; &amp;stu &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Student stu = <span class="built_in">test</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"main Student address: "</span> &lt;&lt; &amp;stu &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">funtion Student address: 0x7fffffffd9e7</span><br><span class="line">main Student address: 0x7fffffffd9e7</span><br><span class="line">析构函数</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数。</p>
</li>
</ol>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// const对象只能调用const的成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 不会修改成员变量, 成员变量前有mutable除外</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>静态变量初始化</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> st_variable;</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> A::st_variable = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ol>
<li><p>友元全局函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>{cout &lt;&lt; <span class="string">"func1"</span> &lt;&lt; endl;}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Girl</span>(<span class="comment">/* args */</span>):<span class="built_in">name</span>(<span class="string">"Alice"</span>){}</span><br><span class="line">    ~<span class="built_in">Girl</span>(){}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>在类中函数前添加friend，即可在该函数中访问类的私有对象</p>
</li>
<li><p>友元类</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Boy</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>{cout &lt;&lt; <span class="string">"func1"</span> &lt;&lt; endl;}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Girl</span>(<span class="comment">/* args */</span>):<span class="built_in">name</span>(<span class="string">"Alice"</span>){}</span><br><span class="line">    ~<span class="built_in">Girl</span>(){}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>可以在Boy类中访问Girl的私有成员</p>
</li>
<li><p>友元成员函数</p>
<p>在友元类某个成员函数中可以访问另一个类所有成员。（逆天语法…）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Boy</span>(<span class="comment">/* args */</span>){}</span><br><span class="line">    ~<span class="built_in">Boy</span>(){}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> Girl&amp; a)</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Boy::func</span><span class="params">(<span class="type">const</span> Girl&amp; a)</span></span>; <span class="comment">// 友元成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="type">const</span> </span>{cout &lt;&lt; <span class="string">"func1"</span> &lt;&lt; endl;}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Girl</span>(<span class="comment">/* args */</span>):<span class="built_in">name</span>(<span class="string">"Alice"</span>){}</span><br><span class="line">    ~<span class="built_in">Girl</span>(){}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Boy::func</span><span class="params">(<span class="type">const</span> Girl&amp; a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    a.<span class="built_in">func1</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p><strong>tips:</strong></p>
<ul>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，不具备交换性。</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span>+(Girl&amp; g, <span class="type">int</span> score) <span class="comment">// 给超女加分的函数。</span></span><br><span class="line">{</span><br><span class="line">    g.m_score = g.m_score + score;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// g + 60;</span></span><br></pre></td></tr></tbody></table></figure>

<p>非成员函数版本的重载运算符函数：形参个数与运算符的操作数个数相同；</p>
<p>成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的一个操作数隐式传递给调用对象。</p>
<p>以下运算符只能通过成员函数进行重载：</p>
<ul>
<li><code>=</code> 赋值运算符</li>
<li><code>()</code> 函数调用运算符</li>
<li><code>[]</code> 下标运算符</li>
<li><code>-&gt;</code> 通过指针访问类成员的运算符</li>
</ul>
<p><strong>重载输出流</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Point&amp; point) {</span><br><span class="line">    os &lt;&lt; <span class="string">"("</span> &lt;&lt; point.x &lt;&lt; <span class="string">", "</span> &lt;&lt; point.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>只能使用全局方式书写（在类成员函数中os需要在point右边）</p>
<p><strong>重载new和delete</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> <span class="comment">// 参数必须是size_t（unsigned long long），返回值必须是void*。</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"调用了重载的new: "</span> &lt;&lt; size &lt;&lt; <span class="string">"字节。\n"</span>;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">malloc</span>(size); <span class="comment">// 申请内存。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"申请到的内存的地址是: "</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="comment">// 参数必须是void*，返回值必须是void。</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"调用了重载的delete.\n"</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 对空指针delete是安全的。</span></span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 释放内存。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为一个类重载 <code>new</code> 和 <code>delete</code> 时，尽管不必显式地使用 <code>static</code>，但实际上仍在创建 <code>static</code> 成员函数。</p>
<p>编译器看到使用 <code>new</code> 创建自定义类的对象时，它选择成员版本的 <code>operator new()</code> 而不是全局版本的 <code>new()</code>。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2>

<p>使用 <code>using</code> 关键字可以改变基类成员在派生类中的访问权限。</p>
<p>注意：<code>using</code> 只能改变基类中 <code>public</code> 和 <code>protected</code> 成员的访问权限，不能改变 <code>private</code> 成员的访问权限，因为基类中 <code>private</code> 成员在派生类中是不可见的，根本不能使用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {          <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_c = <span class="number">30</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {  <span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::m_b;     <span class="comment">// 把 m_b 的权限修改为公有的。</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> A::m_a;     <span class="comment">// 把 m_a 的权限修改为私有的。</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>创建派生类对象时，首先调用基类构造函数，再调用派生类构造函数，只申请一次内存</p>
<p>需要使用初始化列表调用基类的构造函数（有参数）</p>
<p><strong>名字遮蔽和类作用域</strong></p>
<p>如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，通过派生类对象或者在派生类的成员函数中使用该成员时，将使用派生类新增的成员，而不是基类的。</p>
<p>基类的成员函数和派生类的成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数。</p>
<p><strong>虚函数</strong></p>
<p>对于基类，即使它不需要析构函数，也应该提供一个虚析构函数。</p>
<p>可用于实现多态，具体原理请看<a href="https://www.cnblogs.com/Mered1th/p/10924545.html">深入理解C++虚函数表</a></p>
<h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>用法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>{</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意事项：</p>
<ol>
<li>可以为类的成员函数创建模板，但不能是虚函数和析构函数。</li>
<li>使用函数模板时，必须明确数据类型，确保实参与函数模板能匹配上。</li>
<li>使用函数模板时，推导的数据类型必须适应函数模板中的代码。</li>
<li>使用函数模板，如果是自动类型推导，不会发生隐式类型转换，如果显式指定了函数模板的数据类型，可以发生隐式类型转换。</li>
<li>函数模板支持多个通用数据类型的参数。</li>
</ol>
<p><strong>函数模板具体化</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// template&lt;&gt; void Swap&lt;A&gt;(A&amp; a1, A&amp; a2) // 交换两个对象的排名。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(A&amp; a1, A&amp; a2)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> tmp = a1.num;</span><br><span class="line">    a1.num = a2.num;</span><br><span class="line">    a2.num = tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>优先级：普通函数 &gt; 具体化函数模板 &gt; 函数模板</p>
<p><strong>decltype使用</strong></p>
<p>语法：<code>decltype(expression) var</code>;</p>
<ol>
<li><p>如果expression是没有用括号括起来的标识符，则var的类型与该标识符的类型相同，包括const等限定符。</p>
</li>
<li><p>2如果expression是函数调用，则var的类型与函数的返回值类型相同（函数不能返回void，但可以返回void*）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) da; <span class="comment">// da为int类型</span></span><br><span class="line"><span class="built_in">decltyoe</span>(func) *da; <span class="comment">// da为函数指针</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果expression是左值（能取地址），或者用括号括起来的标识符，那么var的类型是expression的引用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(++a) da; <span class="comment">// da-&gt;int &amp;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>如果上面的条件都不满足，则var的类型与expression的类型相同。</p>
</li>
</ol>
<p><strong>函数后置返回类型</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T1 a, T2 b)</span>-&gt;<span class="title">decltype</span><span class="params">(a + b)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> tmp = a + b;</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>语法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line">    类的定义;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// A&lt;int&gt; a: 显示定义</span></span><br><span class="line"><span class="comment">//外部文件定义函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T&gt;::<span class="built_in">test</span>(){</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>函数模板建议用 typename 描述通用数据类型，类模板建议用 class。</p>
<p><strong>模板类继承</strong></p>
<ol>
<li><p>模板类继承普通类（常见）。</p>
</li>
<li><p>普通类继承模板类的实例化版本。</p>
</li>
<li><p>普通类继承模板类。（常见）</p>
<p><strong>普通类继承模板类需要将普通类转换成模板类</strong></p>
</li>
<li><p>模板类继承模板类。</p>
</li>
<li><p>模板类继承模板参数给出的基类（不能是模板类）。</p>
</li>
</ol>
<p><strong>模板类与友元</strong></p>
<ol>
<li>非模板友元</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> {</span><br><span class="line">    T1 m_x;</span><br><span class="line">    T2 m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">const</span> T1 x, <span class="type">const</span> T2 y) : <span class="built_in">m_x</span>(x), <span class="built_in">m_y</span>(y) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非模板友元：友元函数不是模板函数，而是利用模板类参数生成的函数，只能在类内实现。</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> AA&lt;T1, T2&gt;&amp; a)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"x = "</span> &lt;&lt; a.m_x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; a.m_y &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>约束模板友元</li>
</ol>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T&amp; a)</span></span>;  <span class="comment">// 第一步：在模板类的定义前面，声明友元函数模板。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>  <span class="comment">// 模板类 AA。</span></span><br><span class="line">{</span><br><span class="line">   <span class="keyword">friend</span> <span class="type">void</span> show&lt;&gt;(AA&lt;T1, T2&gt;&amp; a);  <span class="comment">// 第二步：在模板类中，再次声明友元函数模板。</span></span><br><span class="line">   T1 m_x;</span><br><span class="line">   T2 m_y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">AA</span>(<span class="type">const</span> T1 x, <span class="type">const</span> T2 y) : <span class="built_in">m_x</span>(x), <span class="built_in">m_y</span>(y) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T&amp; a)</span>  <span class="comment">// 第三步：友元函数模板的定义。</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   std::cout &lt;&lt; <span class="string">"通用：x = "</span> &lt;&lt; a.m_x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; a.m_y &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(AA&lt;<span class="type">int</span>, std::string&gt;&amp; a)</span>  <span class="comment">// 第三步：具体化版本。</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"具体&lt;int, string&gt;：x = "</span> &lt;&lt; a.m_x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; a.m_y &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>非约束模板友元（不常用）</li>
</ol>
<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>C++11 扩展了右值的概念，将右值分为了纯右值和将亡值。</p>
<ul>
<li>纯右值：1. 非引用返回的临时变量；2. 运算表达式产生的结果；3. 字面常量（C风格字符串除外，它是地址）。</li>
<li>将亡值：与右值引用相关的表达式，例如：将要被移动的对象、T&amp;&amp;函数返回的值、std::move(e())的返回值，转换成T&amp;&amp;的类型的转换函数的返回值。</li>
</ul>
<p>不懂纯右值和将亡值的区别其实没关系，统一看作右值即可，不影响使用。</p>
<p><strong>右值引用</strong>就是给右值取个名字。</p>
<p>语法：数据类型&amp;&amp; 变量名 = 右值;</p>
<p>左值引用只能绑定（关联、指向）左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;a = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = <span class="number">7</span>; <span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">AA</span>(AA&amp;&amp; a) { <span class="comment">// 移动构造函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"调用了移动构造函数。\n"</span>; <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">    <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) <span class="keyword">delete</span> m_data; <span class="comment">// 如果已分配内存，先释放掉。</span></span><br><span class="line">    m_data = a.m_data; <span class="comment">// 把资源从源对象中转移过来。</span></span><br><span class="line">    a.m_data = <span class="literal">nullptr</span>; <span class="comment">// 把源对象中的指针置空。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">AA&amp; <span class="keyword">operator</span>=(AA&amp;&amp; a) { <span class="comment">// 移动赋值函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"调用了移动赋值函数。\n"</span>; <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 避免自我赋值。</span></span><br><span class="line">    <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) <span class="keyword">delete</span> m_data; <span class="comment">// 如果已分配内存，先释放掉。</span></span><br><span class="line">    m_data = a.m_data; <span class="comment">// 把资源从源对象中转移过来。</span></span><br><span class="line">    a.m_data = <span class="literal">nullptr</span>; <span class="comment">// 把源对象中的指针置空。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ol>
<li><p>对于一个左值，会调用拷贝构造函数，但是有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？C++11 为了解决这个问题，提供了 <code>std::move()</code> 方法来将左值转义为右值，从而方便使用移动语义。它其实就是告诉编译器，虽然我是一个左值，但不要对我用拷贝构造函数，用移动构造函数吧。左值对象被转移资源后，不会立刻析构，只有在离开自己的作用域的时候才会析构，如果继续使用左值中的资源，可能会发生意想不到的错误。</p>
</li>
<li><p>如果没有提供移动构造/赋值函数，只提供了拷贝构造/赋值函数，编译器找不到移动构造/赋值函数就去寻找拷贝构造/赋值函数</p>
</li>
<li><p>C++11 中的所有容器都实现了移动语义，避免对含有资源的对象发生无谓的拷贝。</p>
</li>
<li><p>移动语义对于拥有资源（如内存、文件句柄）的对象有效，如果是基本类型，使用移动语义没有意义。</p>
</li>
</ol>
<h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><p>在函数模板中，可以将参数“完美”的转发给其他函数。所谓完美，即不仅能准确的转发参数的值，还能保证被转发参数的左、右值属性不变。</p>
<p>为了支持完美转发，C++11 提供了以下方案：</p>
<p>1）如果模板中（包括类模板和函数模板）函数的参数书写成 T&amp;&amp;，那么函数可以接受左值和右值引用。</p>
<p>2）提供了模板函数 <code>std::forward&lt;T&gt;(参数)</code>，用于转发参数，如果参数是一个右值，转发之后仍是右值引用；如果参数是一个左值，转发之后仍是左值引用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(T&amp;&amp; a)</span></span>{</span><br><span class="line">    <span class="built_in">func2</span>(std::forward&lt;T&gt; a);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="类型萃取"><a href="#类型萃取" class="headerlink" title="类型萃取"></a>类型萃取</h1><p>C++11 提供了 <code>type_traits</code> 头文件，其中定义了一系列模板类，用于在编译期间判断类型的属性。</p>
<p>类型萃取（type_traits）是一种编译时技术，用于在编译期间获取和操作类型的信息。主要用于泛型编程以及在编译时做出决策。下面是常见的例子：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">std::is_integral&lt;T&gt; <span class="comment">//判断类型 T 是否为整数类型。</span></span><br><span class="line">std::is_pointer&lt;T&gt; <span class="comment">//判断类型 T 是否为指针类型。</span></span><br><span class="line">std::is_reference&lt;T&gt; <span class="comment">//判断类型 T 是否为引用类型。</span></span><br><span class="line">std::is_const&lt;T&gt; <span class="comment">//判断类型 T 是否为 const 限定类型。</span></span><br><span class="line">std::is_volatile&lt;T&gt; <span class="comment">//判断类型 T 是否为 volatile 限定类型。</span></span><br><span class="line">std::is_fundamental&lt;T&gt; <span class="comment">//判断类型 T 是否为基本类型。</span></span><br><span class="line">std::is_same&lt;T1, T2&gt; <span class="comment">//判断类型 T1 和 T2 是否相同。</span></span><br></pre></td></tr></tbody></table></figure>

<p>这些类型萃取通常具有一个静态布尔值 value，当类型符合特定条件时，它为 true，否则为 false。</p>
<p>其实这些萃取函数原理都差不多，这里举一个例子说明下，比如 is_integral 用于判断一个变量是否是整形:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral_helper</span> : std::false_type {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral_helper</span>&lt;<span class="type">bool</span>&gt; : std::true_type {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral_helper</span>&lt;<span class="type">char</span>&gt; : std::true_type {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral_helper</span>&lt;<span class="type">short</span>&gt; : std::true_type {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral_helper</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt; : std::true_type {};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral_helper</span>&lt;<span class="type">int</span>&gt; : std::true_type {};</span><br><span class="line"></span><br><span class="line">..... 依次类推各种整形都定义一个特化版本</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_integral</span> : is_integral_helper&lt;<span class="keyword">typename</span> std::remove_cv&lt;T&gt;::type&gt; {};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>（ 核心思想就是为所有的整形提供一个特殊版本，其它非整形的就只能匹配到默认的版本，也就是 false_type）</strong></p>
<p><strong>萃取如何使用：</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(T t)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"foo() called with an integral type: "</span> &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(T t)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"foo() called with a floating point type: "</span> &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>); <span class="comment">// Output: foo() called with an integral type: 42</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">3.14</span>); <span class="comment">// Output: foo() called with a floating point type: 3.14</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>C++语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LinuxIO操作</title>
    <url>/1f3f638f.html</url>
    <content><![CDATA[<p>在Linux中，对文件进行I/O操作是指对文件执行输入（Input）和输出（Output）操作。这些操作包括打开文件、读取文件内容、写入数据到文件、关闭文件等。文件I/O操作是通过系统调用实现的，这些系统调用提供了一组标准接口，使得程序可以与操作系统交互，进行文件操作。</p>
<span id="more"></span>

<h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>read, write, lseek, perror, strerror, truncate(截断), ftruncate(截断), fcntl(文件描述符操作)</p>
<p>ioctl(一般用于操作特殊文件或硬件外设，后期介绍)</p>
<p>linux中0，1，2表示标准输入、标准输出和标准错误，文件分配符fd不会取到这三个值</p>
<p>详情可使用<code>man 2 read/write/lseek...</code>查看</p>
<h2 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h2><p><code>errno</code>表示错误对应的标号需要<code>#include &lt;errno.h&gt;</code></p>
<p><code>strerr(errno)</code>打印出错误信息</p>
<p><code>perror()</code>直接打印</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>多次open()和dup()复制的区别</p>
<ol>
<li><p>多次open()</p>
<img src="/1f3f638f/image-20240624230432725.png" class="">
</li>
<li><p>dup(), dup2()复制</p>
<img src="/1f3f638f/image-20240624230350781.png" class=""></li>
</ol>
<p>可以看出多次open()的fd会指向不同的文件表，不同文件表指向同一个inode节点，而dup(), dup2()指向一个文件表</p>
<h3 id="三种实现方法"><a href="#三种实现方法" class="headerlink" title="三种实现方法"></a>三种实现方法</h3><ol>
<li><p>同一个进程中多次调用 open 函数打开同一个文件</p>
<img src="/1f3f638f/image-20240624231735907.png" class="" title="image-20240624231735907">
</li>
<li><p>不同进程中分别使用 open 函数打开同一个文件</p>
<img src="/1f3f638f/image-20240624231752361.png" class="" title="image-20240624231752361">
</li>
<li><p>同一个进程中通过 dup(dup2)函数对文件描述符进行复制</p>
<img src="/1f3f638f/image-20240624231804747.png" class="" title="image-20240624231804747"></li>
</ol>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ol>
<li><p><strong>O_APPEND</strong></p>
<p>open时加入该标志</p>
</li>
<li><p><strong>pread()<strong>和</strong>pwrite()</strong></p>
<p><code>man 2 pread</code>查看</p>
</li>
<li><p><strong>O_EXCL</strong></p>
<p>避免创建文件出现问题</p>
</li>
</ol>
<h1 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h1><p>标准 I/O 是对文件 I/O 进行了封装。标准 I/O 会处理很多细节，譬如分配 stdio 缓冲区、以优</p>
<p>化的块长度执行 I/O 等，这些处理使用户不必担心如何选择使用正确的块长度。</p>
<h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><p>文件：fopen, fclose, fseek, fread, fwrite</p>
<p>错误：feof, ferror, clearerr</p>
<p>详情使用<code>man 3 fopen/fclose...</code>来查看</p>
<h1 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h1><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">// 本质：write(1, format, size)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>; <span class="comment">// 本质：read(0, format, size)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="文件描述符和FILE指针相互转换"><a href="#文件描述符和FILE指针相互转换" class="headerlink" title="文件描述符和FILE指针相互转换"></a>文件描述符和FILE指针相互转换</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>; <span class="comment">// FILE* -&gt; fd</span></span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>; <span class="comment">// fd -&gt; FILE*</span></span><br></pre></td></tr></tbody></table></figure>



<h1 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a>IO缓冲</h1><img src="/1f3f638f/image-20240625115550593.png" class="" title="image-20240625115550593">

<p>可以看出：文件IO比标准IO要快</p>
<h2 id="文件IO缓冲"><a href="#文件IO缓冲" class="headerlink" title="文件IO缓冲"></a>文件IO缓冲</h2><p>刷新缓冲区：fsync, fdatasync, sync</p>
<p><code>man 3 sync</code>查看</p>
<p>fsync: 文件内数据和元数据</p>
<p>fdatasync: 文件内容数据</p>
<p>sync: 所有</p>
<h3 id="绕过IO缓冲"><a href="#绕过IO缓冲" class="headerlink" title="绕过IO缓冲"></a>绕过IO缓冲</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE <span class="comment">// 需要定义宏</span></span></span><br><span class="line">fd = open(filepath, O_WRONLY | O_DIRECT);</span><br></pre></td></tr></tbody></table></figure>

<p>限制：</p>
<ul>
<li>应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐；</li>
<li>写文件时，文件的位置偏移量必须是块大小的整数倍；</li>
<li>写入到文件的数据大小必须是块大小的整数倍。</li>
</ul>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 查看blocksize</span></span><br><span class="line"><span class="built_in">df</span> -h <span class="comment"># 查看根目录在哪</span></span><br><span class="line">tune2fs -l /dev/sda? | grep <span class="string">"Block size"</span></span><br></pre></td></tr></tbody></table></figure>

<p>内存起始地址对齐</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buf[<span class="number">8192</span>] __attribute__((aligned(<span class="number">4096</span>)));</span><br></pre></td></tr></tbody></table></figure>

<p>写入块大小整数倍</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret = write(fd, buf, <span class="number">4096</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="标准IO缓冲"><a href="#标准IO缓冲" class="headerlink" title="标准IO缓冲"></a>标准IO缓冲</h2><p>对stdio缓冲设置</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>man 3</code>查看文档</p>
<h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>使用stat，fstat, lstat查看文件（目录）属性，stat返回一个<code>struct stat</code>结构体</p>
<p>可使用<code>man 2</code>查看，fstat可通过fd来查看属性，lstat可以看链接文件属性</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="type">dev_t</span> st_dev; <span class="comment">/* 文件所在设备的 ID */</span></span><br><span class="line"> <span class="type">ino_t</span> st_ino; <span class="comment">/* 文件对应 inode 节点编号 */</span></span><br><span class="line"> <span class="type">mode_t</span> st_mode; <span class="comment">/* 文件对应的模式 */</span></span><br><span class="line"> <span class="type">nlink_t</span> st_nlink; <span class="comment">/* 文件的链接数 */</span></span><br><span class="line"> <span class="type">uid_t</span> st_uid; <span class="comment">/* 文件所有者的用户 ID */</span></span><br><span class="line"> <span class="type">gid_t</span> st_gid; <span class="comment">/* 文件所有者的组 ID */</span></span><br><span class="line"> <span class="type">dev_t</span> st_rdev; <span class="comment">/* 设备号（指针对设备文件） */</span></span><br><span class="line"> <span class="type">off_t</span> st_size; <span class="comment">/* 文件大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">blksize_t</span> st_blksize; <span class="comment">/* 文件内容存储的块大小 */</span></span><br><span class="line"> <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* 文件内容所占块数 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span> <span class="comment">/* 文件最后被访问的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span> <span class="comment">/* 文件内容最后被修改的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span> <span class="comment">/* 文件状态最后被改变的时间 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="归属"><a href="#归属" class="headerlink" title="归属"></a>归属</h2><p>使用chown, fchown, lchown来更改文件所属，三者区别上同</p>
<p>PS：进程相关联ID</p>
<img src="/1f3f638f/image-20240626092456008.png" class="">

<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>修改时间属性utime, utimes(精度区别)</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> {</span></span><br><span class="line">	<span class="type">time_t</span> actime; <span class="comment">/* 访问时间 */</span></span><br><span class="line">	<span class="type">time_t</span> modtime; <span class="comment">/* 内容修改时间 */</span></span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> <span class="title function_">utimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> {</span></span><br><span class="line"> <span class="type">long</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"> <span class="type">long</span> tv_usec; <span class="comment">/* 微秒 */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>还有futimens()和 utimensat()，区别是：</p>
<ul>
<li>可按纳秒级精度设置时间戳。</li>
<li>可单独设置某一时间戳。</li>
<li>可独立将任一时间戳设置为当前时间。</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>通过<code>link</code>设置硬连接，<code>symlink</code>设置软连接，<code>readlink</code>读取链接文件</p>
<p><strong>软链接和硬链接区别</strong></p>
<ol>
<li><strong>本质：</strong>硬链接是同一个文件的多个名字，而软链接则是不同的文件。</li>
<li><strong>跨分区：</strong>硬链接不支持跨分区，而软链接则支持。</li>
<li><strong>目录：</strong>硬链接不支持链接到目录，而软链接则支持。</li>
<li><strong>相互关系：</strong>硬链接的文件之间是平等的关系，删除任何一个都不会影响其他的链接。而软链接的目标文件如果被删除，软链接就会失效。</li>
<li><strong>文件大小：</strong>硬链接文件显示的大小与原文件一样，而软链接文件的大小则是链接路径的长度。</li>
<li><strong>Inode号：</strong>硬链接的原文件和链接文件共享同一个Inode号，说明它们是同一个文件，而软链接的原文件和链接文件拥有不同的Inode号，表明它们是两个不同的文件2。</li>
<li><strong>文件属性：</strong>在文件属性上，软链接明确写出了是链接文件，而硬链接没有写出来，因为在本质上硬链接文件和原文件是完全平等的关系。</li>
<li><strong>链接数目：</strong>硬链接的链接数目会增加，而软链接的链接数目不会增加。</li>
</ol>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>unlink</code>删除文件</p>
<p><code>man 2</code>查看</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>存储形式</p>
<img src="/1f3f638f/image-20240626105646448.png" class="">

<p>常用操作：mkdir, rmdir, opendir, readdir, rewinddir, closedir, getcwd, chdir, fchdir</p>
<p><code>man 2</code>查看</p>
<h1 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h1><p>在调用 open()函数打开文件时，为参数 flags 指定 O_NONBLOCK 标志，open()调用成功后，后续的 I/O 操作将以非阻塞式方式进行；这就是非阻塞 I/O 的打开方式，如果未指定 O_NONBLOCK 标志，则默认使用阻塞式 I/O 进行操作。</p>
<p>当对文件进行读取操作时，如果文件当前无数据可读，那么阻塞式 I/O 会将调用者应用程序挂起、进入休眠阻塞状态，直到有数据可读时才会解除阻塞；而对于非阻塞 I/O，应用程序不会被挂起，而是会立即返回，它要么一直轮训等待，直到数据可读，要么直接放弃！</p>
<p>阻塞式 I/O 的优点在于能够提升 CPU 的处理效率，当自身条件不满足时，进入阻塞状态，交出 CPU资源，将 CPU 资源让给别人使用；而非阻塞式则是抓紧利用 CPU 资源，譬如不断地去轮训，这样就会导致该程序占用了非常高的 CPU 使用率！</p>
<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>I/O 多路复用（IO multiplexing）它通过一种机制，可以监视多个文件描述符，一旦某个文件描述符（也就是某个文件）可以执行 I/O 操作时，能够通知应用程序进行相应的读写操作。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 select()会一直阻塞，直到某一个或多个文件描述符成为就绪态（可以读或写）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>对于fds，都是 fd_set 类型指针，指向一个 fd_set 类型对象，fd_set 数据类型是一个文件描述符的集合体。本质是bitmap</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>缺点：</p>
<ol>
<li>bitmap位数有限</li>
<li>fd_set不可重用</li>
<li>用户态到内核态切换有开销</li>
<li>O(n)遍历哪一个被置位</li>
</ol>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> {</span></span><br><span class="line"> <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line"> <span class="type">short</span> events; <span class="comment">/* requested events */</span></span><br><span class="line"> <span class="type">short</span> revents; <span class="comment">/* returned events */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>每次恢复revents就行了，不需要重置整个bitmap</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">新建epoll描述符==epoll_create()</span><br><span class="line">epoll_ctrl(epoll描述符，添加或者删除所有待监控的连接)</span><br><span class="line">返回的活跃连接 ==epoll_wait（ epoll描述符 ）</span><br></pre></td></tr></tbody></table></figure>

<p>epoll是通过内核与用户空间mmap同一块内存实现的。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，减少了用户态和内核态之间的数据交换。</p>
<p>epoll_wait会返回改动文件的数，并将其置于epoll的前列（红黑树），所以只需遍历前几个就行了</p>
<h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><p>O_ASYNC 标志可用于使能文件描述符的异步 I/O 事件，当文件描述符可执行 I/O 操作时，内核会向异步 I/O 事件的接收进程发送 SIGIO 信号。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 只能使用fcntl设置异步IO</span></span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line">flag = fcntl(fd, F_GETFL); <span class="comment">//先获取原来的 flag</span></span><br><span class="line">flag |= O_ASYNC; <span class="comment">//将 O_ASYNC 标志添加到 flag</span></span><br><span class="line">fcntl(fd, F_SETFL, flag); <span class="comment">//重新设置 flag</span></span><br><span class="line"><span class="comment">// 设置异步 I/O 事件的接收进程</span></span><br><span class="line">fcntl(fd, F_SETOWN, getpid());</span><br></pre></td></tr></tbody></table></figure>

<p><strong>优化</strong></p>
<p>默认的SIGIO是非可靠信号，使用</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">fcntl(fd, F_SETSIG, SIGRTMIN);</span><br></pre></td></tr></tbody></table></figure>

<p>将其设为可靠信号。</p>
<h1 id="存储映射IO"><a href="#存储映射IO" class="headerlink" title="存储映射IO"></a>存储映射IO</h1><p>存储映射 I/O（memory-mapped I/O）是一种基于内存区域的高级 I/O 操作，它能将一个文件映射到进程地址空间中的一块内存区域中，当从这段内存中读数据时，就相当于读文件中的数据（对文件进行 read 操作），将数据写入这段内存时，则相当于将数据直接写入文件中（对文件进行 write 操作）。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></tbody></table></figure>

<img src="/1f3f638f/image-20240715222704115.png" class="">

<h1 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h1><ol>
<li><p>建议性锁</p>
<p>建议性锁本质上是一种协议，程序访问文件之前，先对文件上锁，上锁成功之后再访问文件，这是建议性锁的一种用法；但是如果你的程序不管三七二十一，在没有对文件上锁的情况下直接访问文件，也是可以访问的，并非无法访问文件；如果是这样，那么建议性锁就没有起到任何作用，如果要使得建议性锁起作用，那么大家就要遵守协议，访问文件之前先对文件上锁。</p>
</li>
<li><p>强制性锁</p>
<p>如果进程对文件上了强制性锁，其它的进程在没有获取到文件锁的情况下是无法对文件进行访问的。其本质原因在于，强制性锁会让内核检查每一个 I/O 操作（譬如 read()、write()），验证调用进程是否是该文件锁的拥有者，如果不是将无法访问文件。</p>
</li>
</ol>
<p><strong>flock</strong></p>
<ol>
<li>同一进程对文件多次加锁不会导致死锁。</li>
<li>文件关闭的时候，会自动解锁。</li>
<li>一个进程不可以对另一个进程持有的文件锁进行解锁。</li>
<li>由 fork()创建的子进程不会继承父进程所创建的锁。</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 建议性锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">flock</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> operation)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>fcntl</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 功能很强大，目前只谈论文件锁功能</span></span><br><span class="line"><span class="comment">// cmd: F_GETLK, F_SETLK, F_SETLKW(阻塞版)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct flock {</span></span><br><span class="line"><span class="comment"> ...</span></span><br><span class="line"><span class="comment"> short l_type; // Type of lock: F_RDLCK,F_WRLCK, F_UNLCK</span></span><br><span class="line"><span class="comment"> short l_whence; // How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END</span></span><br><span class="line"><span class="comment"> off_t l_start; // Starting offset for lock</span></span><br><span class="line"><span class="comment"> off_t l_len; // Number of bytes to lock</span></span><br><span class="line"><span class="comment"> pid_t l_pid; // PID of process blocking our lock(set by F_GETLK and F_OFD_GETLK)</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* struct flock *flockptr */</span> )</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>fcntl()可以对文件的某个区域（某部分内容）进行加锁解锁，可以精确到某一个字节数据。</li>
<li>fcntl()可支持建议性锁和强制性锁两种类型</li>
</ul>
<img src="/1f3f638f/image-20240715225728423.png" class="">

<p>如果要开启强制性锁机制，需要设置文件的 Set-GroupID（S_ISGID）位为 1，并且禁止文件的组用户执行权限（S_IXGRP），也就是将其设置为 0。</p>
<p>有些发行版不支持。</p>
<p><strong>lockf</strong>：对fcntl的封装</p>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程与线程</title>
    <url>/87698413.html</url>
    <content><![CDATA[<p>进程在Linux系统中扮演着至关重要的角色。它不仅是系统资源管理和任务调度的基本单位，还直接影响着系统的性能和稳定性。本文将详细探讨Linux中的进程，包括其概念、生命周期、内核数据结构、以及与进程管理相关的常用API函数，以便读者更深入地理解进程在Linux中的重要性和实现机制。</p>
<span id="more"></span>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p>进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后，它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。</p>
<p>Linux系统下的所有进程都是由其父进程创建而来，譬如在 shell 终端通过命令的方式执行一个程序./app，那么 app进程就是由 shell 终端进程创建出来的，shell 终端就是该进程的父进程。init 进程，它是 Linux 系统启动之后运行的第一个进程，它管理着系统上所有其它进程，init 进程是由内核启动，因此理论上说它没有父进程。</p>
<p>程序结束其实就是进程终止，进程终止的方式通常有多种，大体上分为正常终止和异常终止，正常终止</p>
<p>包括：</p>
<ul>
<li><p>main()函数中通过 return 语句返回来终止进程；</p>
</li>
<li><p>应用程序中调用 exit()函数终止进程；</p>
</li>
<li><p>应用程序中调用<code>_exit()</code>终止进程；</p>
</li>
</ul>
<p>异常终止包括：</p>
<ul>
<li>应用程序中调用 abort()函数终止进程；</li>
<li>进程接收到一个信号，譬如 SIGKILL 信号。</li>
</ul>
<p><strong>exit和_exit的区别：</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> = atexit + _exit;</span><br><span class="line"><span class="comment">// atexit: 调用终止处理+刷新IO（注册,最后exit执行按先进后出顺序来）</span></span><br><span class="line"><span class="comment">// _exit: 进入内核执行清理工作</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>exit和return的区别：</strong></p>
<p>exit会进入内核，而return只是一个返回，把指挥权交给上层调用，return也会调用终止处理函数并刷新缓冲</p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><img src="/87698413/image-20240702212909754.png" class="">

<p>进程中相关属性</p>
<ol>
<li><p>pid</p>
<p>每个进程都有自己唯一的标识：进程号（进程 ID、PID）。</p>
</li>
<li><p>pgid</p>
<p>每个进程除了有一个进程 ID、父进程 ID 之外，还有一个进程组 ID，用于标识该进程属于哪一个进程组，进程组是一个或多个进程的集合。每一个进程组有一个组长进程，组长进程的 ID 就等于进程组 ID；组长进程不能再创建新的进程组；只要进程组中还存在一个进程，则该进程组就存在，这与其组长进程是否终止无关。</p>
</li>
<li><p>sid</p>
<p>会话是一个或多个进程组的集合，其与进程组、进程之间的关系如</p>
<p>下图所示：</p>
<img src="/87698413/image-20240702213346684.png" class="">

<p>一个会话可以有控制终端、也可没有控制终端，在有控制终端的情况下也只能连接一个控制终端。</p>
<p>对于会话来说，会话的首领进程的进程组 ID 将作为该会话的标识，也就是会话 ID（sid），在默认情况下，新创建的进程会继承父进程的会话 ID。</p>
</li>
</ol>
<p>相关操作</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>



<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>获取进程中的环境变量</p>
<ol>
<li><p>environ变量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 代码中使用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ; <span class="comment">// 申明外部全局变量 environ</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>getenv()函数</p>
<p><code>man 3</code> 查看使用</p>
</li>
<li><p>通过main函数参数获取</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span> <span class="comment">// 不推荐，有些系统不支持</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>程序启动时可设置环境变量<code>NAME=value ./app</code></p>
<p>常用操作</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// man 3 查看使用</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 设置环境变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>; <span class="comment">// 修改string会修改环境变量</span></span><br><span class="line"><span class="comment">// 修改name和value不会修改环境变量，创建了一个缓冲区指向他们</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clearenv</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">clearenv()函数内部的做法其实就是将environ赋值为NULL。在某些情况下，使用setenv()函数和clearenv()</span></span><br><span class="line"><span class="comment">函数可能会导致程序内存泄漏。setenv()函数会为环境变量分配一块内存缓冲区，随之称为进程的一部分；而调用 clearenv()函数时没有释放该缓冲区（clearenv()调用并不知晓该缓冲区的存在，故而也无法将其释放）</span></span><br><span class="line"><span class="comment">反复调用者两个函数的程序，会不断产生内存泄漏。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><img src="/87698413/image-20240701181207013.png" class="">

<h2 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h2><p><code>fork</code>函数</p>
<ol>
<li>一次fork两个返回值，0为子进程，大于0为父进程</li>
<li>fork进程创建了与原来进程几乎完全相同的进程（复制父进程的代码段，堆，栈）</li>
<li>子进程从fork调用后开始执行</li>
</ol>
<p><code>vfork</code>函数：与父进程共有代码段，堆，栈</p>
<p>ps: 创建的子进程退出需要使用_exit而不是exit</p>
<p>对文件的共享</p>
<img src="/87698413/image-20240701202424640.png" class="">

<p>父子进程fd指向同一个文件表</p>
<p>fork 后子进程会继承父进程绑定的信号处理函数，若调用 exec 加载新程序后，就不会在继承这个信号处理函数了fork 后子进程会继承父进程的信号掩码，执行 exec 后仍会继承这个信号掩码</p>
<h2 id="监视子进程"><a href="#监视子进程" class="headerlink" title="监视子进程"></a>监视子进程</h2><p><strong>孤儿进程：</strong>父进程先死且未回收子进程，子进程的父进程会交给init进程（图形化界面不一样）</p>
<p><strong>僵尸进程：</strong>子进程先死但父进程未回收，此时使用kill也无法杀死</p>
<p>SIGCHLD 信号发送条件：</p>
<ul>
<li>当父进程的某个子进程终止时，父进程会收到 SIGCHLD 信号；</li>
<li>当父进程的某个子进程因收到信号而停止（暂停运行）或恢复时，内核也可能向父进程发送该信号。</li>
</ul>
<p>监视子进程函数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值是回收的子进程的pid号, man查看</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>; <span class="comment">// 只能阻塞等待</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>; <span class="comment">// 可非阻塞</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><p><code>man</code>进行查看</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">// 以下都是对execve的封装，path表示路径，file表示若本目录没找到会在PATH里找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>守护进程（Daemon）也称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性地执行某种任务或等待处理某些事情的发生，主要表现为以下两个特点：</p>
<ol>
<li>长期运行</li>
<li>与控制终端分离</li>
</ol>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><img src="/87698413/image-20240702222117113.png" class="">

<ul>
<li><p>UNIX IPC：管道、FIFO、信号；</p>
</li>
<li><p>System V IPC：信号量、消息队列、共享内存；</p>
</li>
<li><p>POSIX IPC：信号量、消息队列、共享内存（最快）；</p>
</li>
<li><p>Socket IPC：基于 Socket 进程间通信。（网络）</p>
</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是程序最基本的运行单位，而进程不能运行，真正运行的是进程中的线程。当启动应用程序后，系统就创建了一个进程，可以认为进程仅仅是一个容器，它包含了线程运行所需的数据结构、环境变量等信息。</p>
<!-- more -->

<h2 id="线程特点"><a href="#线程特点" class="headerlink" title="线程特点"></a>线程特点</h2><ul>
<li>线程不单独存在、而是包含在进程中；</li>
<li>线程是参与系统调度的基本单位；</li>
<li>可并发执行。同一进程的多个线程之间可并发执行，在宏观上实现同时运行的效果；</li>
<li>共享进程资源。</li>
</ul>
<p><strong>串行，并行，并发区别</strong></p>
<p>串行</p>
<img src="/87698413/image-20240703220319726.png" class="">

<p>并行</p>
<img src="/87698413/image-20240703220348407.png" class="">

<p>并发</p>
<img src="/87698413/image-20240703220412134.png" class="">

<h2 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 线程ID</span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程 attr: 定义了线程的各种属性 arg: 传入start_routine的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程终止 retval返回值可由pthread_join()获取</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收线程</span></span><br><span class="line"><span class="comment">// 调用 pthread_join()函数将会以阻塞的形式等待指定的线程终止，如果该线程已经终止，则 pthread_join()</span></span><br><span class="line"><span class="comment">// 立刻返回。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，线程是响应其它线程发送过来的取消请求的，响应请求然后退出线程。当然，线程可以选</span></span><br><span class="line"><span class="comment">// 择不被取消或者控制如何被取消</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程清理，需要一一对应</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="取消点"><a href="#取消点" class="headerlink" title="取消点"></a>取消点</h2><p>取消点其实就是一系列函数，当执行到这些函数的时候，才会真正响应取消请求，这些函数就是取消点；在没有出现取消点时，取消请求是无法得到处理的。</p>
<p>可作为取消点的函数</p>
<img src="/87698413/image-20240704223904340.png" class="">

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 设置取消状态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于type项</span></span><br><span class="line"><span class="comment">PTHREAD_CANCEL_DEFERRED：取消请求到来时，线程还是继续运行，取消请求被挂起，直</span></span><br><span class="line"><span class="comment">到线程到达某个取消点</span></span><br><span class="line"><span class="comment">PTHREAD_CANCEL_ASYNCHRONOUS：可能会在任何时间点（也许是立即取消，但不一定）</span></span><br><span class="line"><span class="comment">取消线程（应用较少）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生一个取消点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_testcancel</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化和销毁属性</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>每个线程都有自己的栈空间，pthread_attr_t 数据结构中定义了栈的起始地址以及栈大小</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 设置和获取栈位置和大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstack</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr, <span class="type">size_t</span> *stacksize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstackaddr</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstackaddr</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> **stackaddr)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>pthread_attr_t也可以设置detach属性</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程同步是为了对共享资源的访问进行保护。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>仅列出API</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// init mutex</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock and unlock</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; <span class="comment">// 若无法上锁，会阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; <span class="comment">// 不会阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// destroy mutex</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>互斥锁属性</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化和销毁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_destroy</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutexattr_settype</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>互斥锁的类型属性控制着互斥锁的锁定特性，一共有 4 中类型：</p>
<p><strong>PTHREAD_MUTEX_NORMAL</strong>：一种标准的互斥锁类型，不做任何的错误检查或死锁检测。如果线程试图对已经由自己锁定的互斥锁再次进行加锁，则发生死锁；互斥锁处于未锁定状态，或者已由其它线程锁定，对其解锁会导致不确定结果。</p>
<p><strong>PTHREAD_MUTEX_ERRORCHECK</strong>：此类互斥锁会提供错误检查。譬如这三种情况都会导致返回错误：线程试图对已经由自己锁定的互斥锁再次进行加锁（同一线程对同一互斥锁加锁两次），返回错误；线程对由其它线程锁定的互斥锁进行解锁，返回错误；线程对处于未锁定状态的互斥锁进行解锁，返回错误。这类互斥锁运行起来比较慢，因为它需要做错误检查，不过可将其作为调试工具，以发现程序哪里违反了互斥锁使用的基本原则。</p>
<p><strong>PTHREAD_MUTEX_RECURSIVE</strong>：此类互斥锁允许同一线程在互斥锁解锁之前对该互斥锁进行多次加锁，然后维护互斥锁加锁的次数，把这种互斥锁称为递归互斥锁，但是如果解锁次数不等于加速次数，则是不会释放锁的；所以，如果对一个递归互斥锁加锁两次，然后解锁一次，那么这个互斥锁依然处于锁定状态，对它再次进行解锁之前不会释放该锁。</p>
<p> <strong>PTHREAD_MUTEX_DEFAULT</strong>：此类互斥锁提供默认的行为和特性。使用宏PTHREAD_MUTEX_INITIALIZER初始化的互斥锁， 或者调用参数arg为NULL的pthread_mutexattr_init()函数所创建的互斥锁，都属于此类型。此类锁意在为互斥锁的实现保留最大灵活性，Linux 上， PTHREAD_MUTEX_DEFAULT类型互斥锁的行为与PTHREAD_MUTEX_NORMAL 类型相仿。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量用于自动阻塞线程，知道某个特定事件发生或某个条件满足为止，通常情况下，条件变量是和互斥锁一起搭配使用的。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 条件变量初始化</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>在使用条件变量之前必须对条件变量进行初始化操作，使用 PTHREAD_COND_INITIALIZER 宏或者函数 pthread_cond_init()都行；</li>
<li>对已经初始化的条件变量再次进行初始化，将可能会导致未定义行为；</li>
<li>对没有进行初始化的条件变量进行销毁，也将可能会导致未定义行为；</li>
<li>对某个条件变量而言，仅当没有任何线程等待它时，将其销毁才是最安全的；</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 发送信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥锁很相似，从本质上说也是一把锁，在访问共享资源之前对自旋锁进行上锁，在访问完成后释放自旋锁（解锁）；事实上，从实现方式上来说，互斥锁是基于自旋锁来实现的，所以自旋锁相较于互斥锁更加底层。</p>
<p>自旋锁与互斥锁相似，但是互斥锁在无法获取到锁时会让线程陷入阻塞等待状态；而自旋锁在无法获取到锁时，将会在原地“自旋”等待。“自旋”其实就是调用者一直在循环查看该自旋锁的持有者是否已经释放了锁。</p>
<p>自旋锁的不足之处在于：自旋锁一直占用的 CPU，它在未获得锁的情况下，一直处于运行状态（自旋），所以占着 CPU，如果不能在很短的时间内获取锁，这无疑会使 CPU 效率降低。（一般在内核中使用，中断….）</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// init and destroy</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_destroy</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_init</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> pshared 表示自旋锁的进程共享属性</span></span><br><span class="line"><span class="comment"> PTHREAD_PROCESS_SHARED：共享自旋锁。该自旋锁可以在多个进程中的线程之间共享；</span></span><br><span class="line"><span class="comment"> PTHREAD_PROCESS_PRIVATE：私有自旋锁。只有本进程内的线程才能够使用该自旋锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// So easy, no need to explain</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_lock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_trylock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_unlock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁有3 种状态：读模式下的加锁状态（以下简称读加锁状态）、写模式下的加锁状态（以下简称写加锁状态）和不加锁状态（见），一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。</p>
<img src="/87698413/image-20240705230905164.png" class="">

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// init and destroy</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>; <span class="comment">// 读模式上锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>; <span class="comment">// 写模式上锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>; <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_destroy</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_init</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *attr, <span class="type">int</span> *pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlockattr_setpshared</span><span class="params">(<span class="type">pthread_rwlockattr_t</span> *attr, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> pshared 表示自旋锁的进程共享属性</span></span><br><span class="line"><span class="comment"> PTHREAD_PROCESS_SHARED：共享自旋锁。该自旋锁可以在多个进程中的线程之间共享；</span></span><br><span class="line"><span class="comment"> PTHREAD_PROCESS_PRIVATE：私有自旋锁。只有本进程内的线程才能够使用该自旋锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="线程安全函数"><a href="#线程安全函数" class="headerlink" title="线程安全函数"></a>线程安全函数</h3><p><strong>可重入函数</strong>：如果一个函数被同一进程的多个不同的执行流同时调用，每次函数调用总是能产生正确的结果（或者叫产生预期的结果），把这样的函数就称为可重入函数。</p>
<p>分类：</p>
<ol>
<li><strong>绝对的可重入函数：</strong>所谓绝对，指的是该函数不管如何调用，都刚断言它是可重入的，都能得到预期的结果。</li>
<li><strong>带条件的可重入函数：</strong>指的是在满足某个/某些条件的情况下，可以断言该函数是可重入的，不管怎么调用都能得到预期的结果。</li>
</ol>
<p>绝对可重入函数的特点：</p>
<ul>
<li><p>函数内所使用到的变量均为局部变量，换句话说，该函数内的操作的内存地址均为本地栈地址；</p>
</li>
<li><p>函数参数和返回值均是值类型；</p>
</li>
<li><p>函数内调用的其它函数也均是绝对可重入函数。</p>
</li>
</ul>
<p><strong>线程安全函数</strong>：一个函数被多个线程（其实也是多个执行流，但是不包括由信号处理函数所产生的执行流）同时用时，它总会一直产生正确的结果，把这样的函数称为线程安全函数。线程安全函数包括可重入函数，可重入函数是线程安全函数的一个真子集，也就是说可重入函数一定是线程安全函数，但线程安全函数不一定是可重入函数。</p>
<img src="/87698413/image-20240706223032854.png" class="">

<p>POSIX.1-2001 和 POSIX.1-2008 标准中规定的所有函数都必须是线程安全函数，但以下函数除外：</p>
<img src="/87698413/image-20240706223328484.png" class="">

<h3 id="线程特有数据"><a href="#线程特有数据" class="headerlink" title="线程特有数据"></a>线程特有数据</h3><p><strong>一次性初始化</strong>：在多线程编程环境下，有些代码段只需要执行一次，譬如一些初始化相关的代码段。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>在多线程编程环境下，尽管 pthread_once()调用会出现在多个线程中，但该函数会保证 init_routine()函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。</p>
<p><strong>线程特有数据</strong></p>
<p>很多库函数都会返回一个字符串指针，譬如 asctime()、ctime()、localtime()等，返回出来的字符串可以被调用线程直接使用，但该字符串缓冲区通常是这些函数内部所维护的静态数组或者是某个全局数组。被多个线程同时调用时，返回的字符串中的数据可能是混乱的，因为某一线程调用它时，缓冲区中的数据可能被另一个调用线程修改了。</p>
<p>线程特有数据的核心思想其实非常简单，就是为每一个调用线程（调用某函数的线程，该函数就是我们要通过线程特有数据将其实现为线程安全的函数）分配属于该线程的私有数据区，为每个调用线程分别维护一份变量的副本。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建键值对</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_create</span><span class="params">(<span class="type">pthread_key_t</span> *key, <span class="type">void</span> (*destructor)(<span class="type">void</span>*))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键值对，对应的value就是要复制的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setspecific</span><span class="params">(<span class="type">pthread_key_t</span> key, <span class="type">const</span> <span class="type">void</span> *value)</span>;</span><br><span class="line"><span class="comment">// 返回复制值的内存地址</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_getspecific</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_key_delete</span><span class="params">(<span class="type">pthread_key_t</span> key)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>或者也可以使用<code>__thread</code>，也可以达成特有数据的效果</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> __thread <span class="type">char</span> buf[MAX_ERROR_LEN];</span><br></pre></td></tr></tbody></table></figure>

<h2 id="线程与信号"><a href="#线程与信号" class="headerlink" title="线程与信号"></a>线程与信号</h2><ul>
<li>信号的系统默认行为是属于进程层面。</li>
<li>信号处理函数属于进程层面。</li>
<li>信号的发送既可针对整个进程，也可针对某个特定的线程。在满足以下三个条件中的任意一个时，信号的发送针对的是某个线程：<ol>
<li>产生了硬件异常相关信号，譬如 SIGBUS、SIGFPE、SIGILL 和 SIGSEGV 信号；</li>
<li>当线程试图对已断开的管道进行写操作时所产生的 SIGPIPE 信号；</li>
<li>由函数 pthread_kill()或 pthread_sigqueue()所发出的信号</li>
</ol>
</li>
<li>当一个多线程进程接收到一个信号时，且该信号绑定了信号处理函数时，内核会任选一个线程来接收这个信号</li>
<li>信号掩码其实是属于线程层面的，<code> pthread_sigmask()</code>函数来设置各自线程的信号掩码</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 设置线程掩码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="comment">// 向线程发送信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_kill</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>异步信号安全函数</strong>：指的是可以在信号处理函数中可以被安全调用的线程安全函数，可重入函数一定是异步信号安全函数。</p>
<h1 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h1><ol>
<li>进程是资源分配的基本单位，线程是CPU调度的基本单位；</li>
<li>进程拥有独立的地址空间，线程共享进程的地址空间；</li>
<li>进程间通信需要IPC，线程间通信直接读写全局变量；</li>
<li>创建进程比创建线程开销大；</li>
<li>进程间切换开销大，线程间切换开销小；</li>
<li>进程有自己的独立堆栈，线程共享进程的堆栈；</li>
<li>进程间不会相互影响，线程间会相互影响；</li>
<li>进程可以跨平台，线程不可以。</li>
</ol>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统信息与资源</title>
    <url>/8c131bee.html</url>
    <content><![CDATA[<p>在应用程序当中，有时往往需要去获取到一些系统相关的信息，譬如时间、日期、以及其它一些系统相关信息，本章将向大家介绍如何通过 Linux 系统调用或 C 库函数获取系统信息，譬如获取系统时间、日期以及设置系统时间、日期等；除此之外，还会向大家介绍 Linux 系统下的/proc 虚拟文件系统，包括/proc 文件系统是什么以及如何从/proc 文件系统中读取系统、进程有关信息。也会提及到信号相关的问题。</p>
<span id="more"></span>

<h1 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h1><p>常用函数：uname, sysinfo, gethostname, sysconf</p>
<p><code>man 2</code>查看文档</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 示例程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">os_info</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = uname(&amp;os_info);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != ret)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"uname"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sysname: %s\n"</span>, os_info.sysname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nodename: %s\n"</span>, os_info.nodename);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"release: %s\n"</span>, os_info.release);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"version: %s\n"</span>, os_info.version);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"machine: %s\n"</span>, os_info.machine);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sys_info</span>;</span></span><br><span class="line">    <span class="comment">/* 获取信息 */</span></span><br><span class="line">    ret = sysinfo(&amp;sys_info);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"sysinfo error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">    <span class="comment">/* 打印信息 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uptime: %ld\n"</span>, sys_info.uptime);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"totalram: %lu\n"</span>, sys_info.totalram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"freeram: %lu\n"</span>, sys_info.freeram);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"procs: %u\n"</span>, sys_info.procs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gethostname</span></span><br><span class="line">    <span class="type">char</span> hostname[<span class="number">256</span>];</span><br><span class="line">    ret = gethostname(hostname, <span class="keyword">sizeof</span>(hostname));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret)</span><br><span class="line">    {</span><br><span class="line">        perror(<span class="string">"gethostname"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hostname: %s\n"</span>, hostname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"每个用户的最大并发进程数: %ld\n"</span>, sysconf(_SC_CHILD_MAX));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"系统节拍率: %ld\n"</span>, sysconf(_SC_CLK_TCK));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"系统页大小: %ld\n"</span>, sysconf(_SC_PAGESIZE));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大文件数: %ld\n"</span>, sysconf(_SC_OPEN_MAX));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h1><p>​	<img src="/8c131bee/image-20240626135355304.png" class=""></p>
<p>​	Linux 系统在开机启动之后首先会读取 RTC 硬件获取实时时钟作为系统时钟的初始值，之后内核便开始维护自己的系统时钟。实时时钟一般由 RTC 时钟芯片提供，RTC 芯片有相应的电池为其供电，以保证系统在关机情况下 RTC 能够继续工作、继续计时。</p>
<p>​	内核使用 jiffies 来记录系统从启动以来的系统节拍数，全局变量 jiffies 在系统开机启动时会设置一个初始值，RTC 实时时钟会在系统开机启动时读取一次，目的是用于对系统时钟进行初始化，这里说的初始化其实指的就是对内核的 jiffies 变量进行初始化操作。</p>
<p><strong>获取时间函数：</strong>time，gettimeofday(返回自 1970-01-01 00:00:00 +0000 (UTC)以来的时间值)</p>
<p><strong>时间转换函数：</strong>ctime, localtime_r(均是C库函数)</p>
<p><strong>设置时间</strong>：settimeofday</p>
<h1 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h1><ol>
<li><p>times</p>
<p>除以<code> sysconf(_SC_CLK_TCK)</code>，返回的是用户CPU时间和内核CPU时间</p>
</li>
<li><p>clock</p>
<p>C库函数，除以<code>CLOCKS_PER_SEC</code>, 返回的是总的CPU时间</p>
</li>
</ol>
<h1 id="Proc"><a href="#Proc" class="headerlink" title="Proc"></a>Proc</h1><p>proc 文件系统是一个虚拟文件系统，它以文件系统的方式为应用层访问系统内核数据提供了接口，用</p>
<p>户和应用程序可以通过 proc 文件系统得到系统信息和进程相关信息，对 proc 文件系统的读写作为与内核</p>
<p>进行通信的一种手段。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /proc</span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></tbody></table></figure>

<img src="/8c131bee/image-20240627094516424.png" class="">

<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>不可靠信号：信号可能丢失（非实时信号）序号为1~31</p>
<p>当排队时，不可靠信号等待是集合，当相同信号再次传来的时候就会丢弃</p>
<h2 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h2><table>
<thead>
<tr>
<th>信号名称</th>
<th>编号</th>
<th>描述</th>
<th>系统默认操作</th>
</tr>
</thead>
<tbody><tr>
<td>SIGINT</td>
<td>2</td>
<td>终端中断符</td>
<td>term</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>终端退出符</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>非法硬件指令</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>异常终止（abort）</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>7</td>
<td>内存访问错误</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>算术异常</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>终极终止信号</td>
<td>term</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>10</td>
<td>用户自定义信号 1</td>
<td>term</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>无效的内存引用</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>12</td>
<td>用户自定义信号 2</td>
<td>term</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>管道关闭</td>
<td>term</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>定时器超时（alarm）</td>
<td>term</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>终止进程</td>
<td>term</td>
</tr>
<tr>
<td>SIGCHLD/SIGCLD</td>
<td>17</td>
<td>子进程终止或停止</td>
<td>ignore</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>18</td>
<td>使停止状态的进程继续运行</td>
<td>cont</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>19</td>
<td>停止进程</td>
<td>stop</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>20</td>
<td>终端停止符</td>
<td>stop</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>24</td>
<td>超过 CPU 限制</td>
<td>term+core</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>26</td>
<td>虚拟定时器超时</td>
<td>term</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>28</td>
<td>终端窗口尺寸发生变化</td>
<td>term</td>
</tr>
<tr>
<td>SIGPOLL/SIGIO</td>
<td>29</td>
<td>异步 I/O</td>
<td>term/ignore</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>31</td>
<td>无效系统调用</td>
<td>term+core</td>
</tr>
</tbody></table>
<p>tips: term 表示终止进程；core 表示生成核心转储文件；ignore 表示忽略信号；cont 表示继续运行进程；stop 表示停止进程（注意停止不等于终止，而是暂停）</p>
<p><strong>进程对信号处理：</strong>signal和sigaction函数</p>
<p><strong>发送信号：</strong>kill和raise函数，kill发送任一进程，raise发送自身</p>
<p><strong>定时和休眠：</strong>alarm和pause函数</p>
<p><strong>信号集相关函数</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">// 空信号集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>; <span class="comment">// 捕获所有信号</span></span><br><span class="line"><span class="comment">// 添加信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 是否在信号集中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 查看是否信号是否等待并存入信号集中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="信号掩码"><a href="#信号掩码" class="headerlink" title="信号掩码"></a>信号掩码</h2><p>内核为每一个进程维护了一个信号掩码（其实就是一个信号集），即一组信号。当进程接收到一个属于信号掩码中定义的信号时，该信号将会被阻塞、无法传递给进程进行处理，那么内核会将其阻塞，直到该信号从信号掩码中移除，内核才会把该信号传递给进程从而得到处理。</p>
<ul>
<li>当应用程序调用 signal()或 sigaction()函数为某一个信号设置处理方式时，进程会自动将该信号添加</li>
</ul>
<p>到信号掩码中，这样保证了在处理一个给定的信号时，如果此信号再次发生，那么它将会被阻塞；</p>
<p>当然对于 sigaction()而言，是否会如此，需要根据 sigaction()函数是否设置了 SA_NODEFER 标志</p>
<p>而定；当信号处理函数结束返回后，会自动将该信号从信号掩码中移除。</p>
<ul>
<li>使用 sigaction()函数为信号设置处理方式时，可以额外指定一组信号，当调用信号处理函数时将该</li>
</ul>
<p>组信号自动添加到信号掩码中，当信号处理函数结束返回后，再将这组信号从信号掩码中移除；通</p>
<p>过 sa_mask 参数进行设置。</p>
<ul>
<li>除了以上两种方式之外，还可以使用<code>sigprocmask()</code>系统调用，随时可以显式地向信号掩码中添加或</li>
</ul>
<p>移除信号。使用<code>man2</code>查看使用教程</p>
<h2 id="实时信号"><a href="#实时信号" class="headerlink" title="实时信号"></a>实时信号</h2><p>可靠信号（32~64）队列处理</p>
<p>可以在<code>/usr/include/asm-generic/signal.h</code>进行查看</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _NSIG		64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These should not be considered constants from userland.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGRTMIN	32</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIGRTMAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGRTMAX	_NSIG</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>对于可靠信号需要使用<code>sigqueue</code>来传递信号</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><strong>忽略信号</strong></p>
<p><code>SIG_IGN</code></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略中断信号</span></span><br><span class="line"><span class="comment">// 忽略 SIGINT 信号 (通常是 Ctrl+C)</span></span><br><span class="line">signal(SIGINT, SIG_IGN);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>异常退出</strong></p>
<p><code>abort</code></p>
<p>无论阻塞或忽略 SIGABRT 信号，abort()调用均不收到影响，总会成功终止进程</p>
]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>QThread使用</title>
    <url>/c8ec8ef9.html</url>
    <content><![CDATA[<p>本文介绍QtThread的基础使用</p>
<span id="more"></span>

<p>在qt中使用了多线程，有些事项是需要额外注意的：</p>
<ul>
<li><p>默认的线程在Qt中称之为窗口线程，也叫主线程，负责窗口事件处理或者窗口控件数据的更新</p>
</li>
<li><p>子线程负责后台的业务逻辑处理，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理</p>
</li>
<li><p>主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制</p>
</li>
</ul>
<h1 id="QThread的基础使用"><a href="#QThread的基础使用" class="headerlink" title="QThread的基础使用"></a>QThread的基础使用</h1><h2 id="使用方法1"><a href="#使用方法1" class="headerlink" title="使用方法1"></a>使用方法1</h2><ol>
<li><p>需要创建一个线程类的子类，让其继承QT中的线程类 QThread，比如:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>:<span class="keyword">public</span> QThread</span><br><span class="line">{</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>重写父类的 run() 方法，在该函数内部编写子线程要处理的具体的业务流程</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>:<span class="keyword">public</span> QThread</span><br><span class="line">{</span><br><span class="line">    ......</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ........</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在主线程中创建子线程对象，new 一个就可以了</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">   MyThread * subThread = <span class="keyword">new</span> MyThread;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 启动子线程, 调用 <span class="built_in">start</span>() 方法</span><br><span class="line"></span><br><span class="line">   ```c++</span><br><span class="line">   subThread-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="使用方法2"><a href="#使用方法2" class="headerlink" title="使用方法2"></a>使用方法2</h2><p>用起来更加灵活一些</p>
<ol>
<li><p>创建一个新的类，让这个类从QObject派生</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span>:<span class="keyword">public</span> QObject</span><br><span class="line">{</span><br><span class="line">    .......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在这个类中添加一个公共的成员函数，函数体就是我们要子线程中执行的业务逻辑</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span>:<span class="keyword">public</span> QObject</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 函数名自己指定, 叫什么都可以, 参数可以根据实际需求添加</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在主线程中创建一个QThread对象, 这就是子线程的对象</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">QThread* sub = <span class="keyword">new</span> QThread;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在主线程中创建工作的类对象（<strong>千万不要指定给创建的对象指定父对象</strong>）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">MyWork* work = <span class="keyword">new</span> <span class="built_in">MyWork</span>(<span class="keyword">this</span>);    <span class="comment">// error</span></span><br><span class="line">MyWork* work = <span class="keyword">new</span> MyWork;          <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>将MyWork对象移动到创建的子线程对象中, 需要调用QObject类提供的moveToThread()方法</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// void QObject::moveToThread(QThread *targetThread);</span></span><br><span class="line"><span class="comment">// 如果给work指定了父对象, 这个函数调用就失败了</span></span><br><span class="line"><span class="comment">// 提示： QObject::moveToThread: Cannot move objects with a parent</span></span><br><span class="line">work-&gt;<span class="built_in">moveToThread</span>(sub);	<span class="comment">// 移动到子线程中工作</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>启动子线程，调用 start(), 这时候线程启动了, 但是移动到线程中的对象并没有工作</p>
</li>
<li><p>调用MyWork类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</p>
</li>
</ol>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>在Qt中使用线程池需要先创建任务，添加到线程池中的每一个任务都需要是一个QRunnable类型，因此在程序中需要创建子类继承QRunnable这个类，然后重写 run() 方法，在这个函数中编写要在线程池中执行的任务，并将这个子类对象传递给线程池，这样任务就可以被线程池中的某个工作的线程处理掉了。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyWork</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">{</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// MyWork(QObject *parent = nullptr): QObject(parent), QRunnable(){}</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyWork</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// 任务执行完毕,该对象自动销毁</span></span><br><span class="line">        <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">MyWork</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>每个Qt应用程序都有一个全局 QThreadPool 对象，可以通过调用 <code>globalInstance() </code>来访问它。也可以单独创建一个 QThreadPool 对象使用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">{</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池初始化，设置最大线程池数</span></span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">setMaxThreadCount</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    MyWork* task = <span class="keyword">new</span> MyWork;</span><br><span class="line">    QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(task);    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>本文转自</p>
<p>作者: <a href="https://space.bilibili.com/147020887">爱编程的大丙</a><br>链接: <a href="https://subingwen.cn/qt/">https://subingwen.cn/qt/</a><br>只是作为学习进行记录</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>RM装甲板识别</title>
    <url>/158223f0.html</url>
    <content><![CDATA[<p>在Robomaster比赛中，装甲板是机器人得分的主要目标。识别并攻击装甲板可以帮助机器人按照比赛规则得分，同时避免攻击非装甲部位，减少无效攻击和违规行为。通过装甲板识别技术，机器人可以准确地检测并定位敌方机器人，从而进行有效的瞄准和攻击。装甲板通常是对方机器人的关键部位，通过识别这些部位可以提高攻击的命中率。</p>
<span id="more"></span>

<p><strong>装甲板示例图</strong></p>
<img src="/158223f0/test1.png" class="">

<p>config.py中，is_video=0表示是图片识别反之则是视频识别</p>
<p>is_debug=1时显示中间debug文件</p>
<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><ol>
<li>使用语言：Python</li>
<li>项目流程管理：git, docker</li>
<li>训练模型使用的框架：pytorch</li>
<li>识别基本思路：通过装甲板两边的灯条来定位装甲板，再通过数字检测再进行筛选最后得到装甲板的位置（传统识别+深度学习）</li>
</ol>
<p>项目目录</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">│  .gitignore</span><br><span class="line">|  Dockerfile <span class="comment"># 构建镜像</span></span><br><span class="line">|  requirements.txt <span class="comment"># 所需要的包</span></span><br><span class="line">|  test.py <span class="comment"># 测试文件</span></span><br><span class="line">│  config.py <span class="comment"># 配置</span></span><br><span class="line">│  detect.py <span class="comment"># 识别模块</span></span><br><span class="line">│  main.py <span class="comment"># 主程序入口</span></span><br><span class="line">│  readme.md <span class="comment"># 文档</span></span><br><span class="line">│  train.py <span class="comment"># 训练文件</span></span><br><span class="line">│</span><br><span class="line">├─cfg <span class="comment"># 模型文件</span></span><br><span class="line">│</span><br><span class="line">├─datasets <span class="comment"># 数据集</span></span><br><span class="line">│</span><br><span class="line">├─image <span class="comment"># readme图片</span></span><br><span class="line">│</span><br><span class="line">├─testdata 测试数据集</span><br></pre></td></tr></tbody></table></figure>

<h1 id="识别具体实现"><a href="#识别具体实现" class="headerlink" title="识别具体实现"></a>识别具体实现</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>位于config.py中，模型，是否debug，一些参数，类的定义均存在里面</p>
<h2 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h2><p>通过cvtColor和threshold将图片转为二值图片，将目标从背景中分离出来。</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">def preProcess(rgb_img):</span><br><span class="line">    gray = cv.cvtColor(rgb_img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    _, binary = cv.threshold(gray, settings.binary_thres, 255, cv.THRESH_BINARY) #_是阈值 忽略</span><br><span class="line">    return binary</span><br></pre></td></tr></tbody></table></figure>

<h2 id="寻找灯条"><a href="#寻找灯条" class="headerlink" title="寻找灯条"></a>寻找灯条</h2><p>通过 findContours 得到轮廓</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">contours, hierarchy = cv.findContours(binary_img, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></tbody></table></figure>

<p>将轮廓点数小于5的排除掉</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">for contour in contours:</span><br><span class="line">        if len(contour) &lt; 5:</span><br><span class="line">            continue</span><br></pre></td></tr></tbody></table></figure>

<p>对轮廓进行外接矩形并且判定是否是灯条</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line">	r_rect = cv.minAreaRect(contour)</span><br><span class="line">        light = Light(r_rect)</span><br><span class="line"></span><br><span class="line">        if is_light(light):</span><br><span class="line"># Light的定义(一小部分)</span><br><span class="line">class Light:</span><br><span class="line">    def __init__(self, box=None):</span><br><span class="line">	self.center = box[0]</span><br><span class="line">        self.size = box[1]</span><br><span class="line">        self.angle = box[2]</span><br><span class="line"></span><br><span class="line">        points = cv.boxPoints(box)</span><br><span class="line">        points = sorted(points, key=lambda p: p[1])</span><br><span class="line"></span><br><span class="line">        self.top = (points[0] + points[1]) / 2</span><br><span class="line">        self.bottom = (points[2] + points[3]) / 2</span><br><span class="line"></span><br><span class="line">        self.length = np.linalg.norm(self.top - self.bottom)</span><br><span class="line">        self.width = np.linalg.norm(points[0] - points[1])</span><br><span class="line"></span><br><span class="line">        self.tilt_angle = atan2(abs(self.top[0] - self.bottom[0]), abs(self.top[1] - self.bottom[1]))</span><br><span class="line">        self.tilt_angle = self.tilt_angle / pi * 180</span><br><span class="line">        self.color = None</span><br></pre></td></tr></tbody></table></figure>

<p>通过统计在给定轮廓内的红色和蓝色像素值的总和，来判断该区域主要的颜色是红色还是蓝色。使用 <code>cv.pointPolygonTest</code>来确保只统计轮廓内部的像素值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sum_r, sum_b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">   roi = rbg_img[rect[<span class="number">1</span>]:rect[<span class="number">1</span>]+rect[<span class="number">3</span>], rect[<span class="number">0</span>]:rect[<span class="number">0</span>]+rect[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(roi.shape[<span class="number">0</span>]):</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(roi.shape[<span class="number">1</span>]):</span><br><span class="line">   <span class="keyword">if</span> cv.pointPolygonTest(contour, (j + rect[<span class="number">0</span>], i + rect[<span class="number">1</span>]), <span class="literal">False</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">   	sum_b += roi[i, j, <span class="number">0</span>]</span><br><span class="line">   	sum_r += roi[i, j, <span class="number">2</span>]</span><br><span class="line">	light.color = <span class="string">'RED'</span> <span class="keyword">if</span> sum_r &gt; sum_b <span class="keyword">else</span> <span class="string">'BLUE'</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="配对灯条"><a href="#配对灯条" class="headerlink" title="配对灯条"></a>配对灯条</h2><p>根据 <code>detect_color</code> 选择对应颜色的灯条进行两两配对，首先筛除掉两条灯条中间包含另一个灯条的情况，然后根据两灯条的长度之比、两灯条中心的距离、配对出装甲板的倾斜角度来筛选掉条件不满足的结果，得到形状符合装甲板特征的灯条配对（数据根据官方和测量得出）。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">def <span class="title function_">containLight</span><span class="params">(light_1, light_2, lights)</span>:</span><br><span class="line">    # 获取两个光条的顶点和底点坐标</span><br><span class="line">    points = np.<span class="built_in">array</span>([light_1.top, light_1.bottom, light_2.top, light_2.bottom])</span><br><span class="line">    bounding_rect = cv.boundingRect(points)</span><br><span class="line"></span><br><span class="line">    # 遍历所有光条，检查是否有光条被包含在两个光条之间</span><br><span class="line">    <span class="keyword">for</span> test_light in lights:</span><br><span class="line">        <span class="keyword">if</span> np.array_equal(test_light.center, light_1.center) or np.array_equal(test_light.center, light_2.center):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cv.pointPolygonTest(points, (test_light.top[<span class="number">0</span>], test_light.top[<span class="number">1</span>]), False) &gt;= <span class="number">0</span> or</span><br><span class="line">            cv.pointPolygonTest(points, (test_light.bottom[<span class="number">0</span>], test_light.bottom[<span class="number">1</span>]), False) &gt;= <span class="number">0</span> or</span><br><span class="line">            cv.pointPolygonTest(points, (test_light.center[<span class="number">0</span>], test_light.center[<span class="number">1</span>]), False) &gt;= <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> True</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> False</span><br><span class="line">def isArmor(light_1, light_2):</span><br><span class="line">    # 比较两个光条的长度比例（短边 / 长边）</span><br><span class="line">    light_length_ratio = min(light_1.length, light_2.length) / max(light_1.length, light_2.length)</span><br><span class="line">    light_ratio_ok = light_length_ratio &gt; settings.amin_light_ratio</span><br><span class="line"></span><br><span class="line">    # 计算两个光条中心的距离（以光条长度为单位）</span><br><span class="line">    avg_light_length = (light_1.length + light_2.length) / <span class="number">2</span></span><br><span class="line">    center_distance = np.linalg.norm(np.<span class="built_in">array</span>(light_1.center) - np.<span class="built_in">array</span>(light_2.center)) / avg_light_length</span><br><span class="line">    center_distance_ok = (settings.amin_small_center_distance &lt;= center_distance &lt; settings.amax_small_center_distance) or \</span><br><span class="line">                         (settings.amin_large_center_distance &lt;= center_distance &lt; settings.amax_large_center_distance)</span><br><span class="line"></span><br><span class="line">    # 计算光条中心连接线的角度</span><br><span class="line">    diff = np.<span class="built_in">array</span>(light_1.center) - np.<span class="built_in">array</span>(light_2.center)</span><br><span class="line">    angle = degrees(<span class="built_in">abs</span>(<span class="built_in">atan2</span>(diff[<span class="number">1</span>], diff[<span class="number">0</span>])))</span><br><span class="line">    angle_ok = angle &lt; settings.amax_angle</span><br><span class="line"></span><br><span class="line">    # 综合判断是否为装甲板</span><br><span class="line">    is_armor = light_ratio_ok and center_distance_ok and angle_ok</span><br><span class="line"></span><br><span class="line">    # 判断装甲板类型</span><br><span class="line">    <span class="keyword">if</span> is_armor:</span><br><span class="line">        type = <span class="string">'LARGE'</span> <span class="keyword">if</span> center_distance &gt; settings.amin_large_center_distance <span class="keyword">else</span> <span class="string">'SMALL'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        type = <span class="string">'INVALID'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type</span><br></pre></td></tr></tbody></table></figure>

<h2 id="提取数字"><a href="#提取数字" class="headerlink" title="提取数字"></a>提取数字</h2><p>设置好roi，根据灯条的坐标获得装甲板大致的位置，然后使用透视变换截取出数字部分</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">lights_vertices = np.array([armor.left_light.bottom, armor.left_light.top,</span><br><span class="line">                                       armor.right_light.top, armor.right_light.bottom], dtype=np.float32)</span><br><span class="line">           <span class="comment"># 计算变换后图像中灯条顶部和底部的y坐标</span></span><br><span class="line">           top_light_y = (warp_height - light_length) // <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">           bottom_light_y = top_light_y + light_length</span><br><span class="line">           <span class="comment"># 根据装甲板类型确定变换后的图像宽度</span></span><br><span class="line">           warp_width = small_armor_width <span class="keyword">if</span> armor.<span class="built_in">type</span> == <span class="string">'SMALL'</span> <span class="keyword">else</span> large_armor_width</span><br><span class="line">           <span class="comment"># 设置变换后图像的目标顶点位置</span></span><br><span class="line">           target_vertices = np.array([[<span class="number">0</span>, bottom_light_y],</span><br><span class="line">                                       [<span class="number">0</span>, top_light_y],</span><br><span class="line">                                       [warp_width - <span class="number">1</span>, top_light_y],</span><br><span class="line">                                       [warp_width - <span class="number">1</span>, bottom_light_y]], dtype=np.float32)</span><br><span class="line">           <span class="comment"># 计算透视变换矩阵</span></span><br><span class="line">           rotation_matrix = cv.getPerspectiveTransform(lights_vertices, target_vertices)</span><br><span class="line">           <span class="comment"># 应用透视变换，将源图像中的装甲板区域变换到目标顶点位置</span></span><br><span class="line">           number_image = cv.warpPerspective(src, rotation_matrix, (warp_width, warp_height))</span><br><span class="line">           <span class="comment"># 从变换后的图像中提取感兴趣区域（ROI）</span></span><br><span class="line">           x_start = (warp_width - roi_size[<span class="number">0</span>]) // <span class="number">2</span></span><br><span class="line">           x_end = x_start + roi_size[<span class="number">0</span>]</span><br><span class="line">           number_image = number_image[<span class="number">0</span>:roi_size[<span class="number">1</span>], x_start:x_end]</span><br><span class="line">           <span class="comment"># 将图像转换为灰度图像</span></span><br><span class="line">           number_image = cv.cvtColor(number_image, cv.COLOR_RGB2GRAY)</span><br><span class="line">           <span class="comment"># 对灰度图像应用二值化处理</span></span><br><span class="line">           _, number_image = cv.threshold(number_image, <span class="number">0</span>, <span class="number">255</span>, cv.THRESH_BINARY | cv.THRESH_OTSU)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><p>由于MiniPC的性能限制，只是设计了简单的mlp网络用于数字分类</p>
<img src="/158223f0/image-20240626144621090.png" class="">

<p>在训练前对训练集进行处理</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dataset = torchvision.datasets.ImageFolder(</span><br><span class="line">    root=os.path.join(os.path.dirname(__file__), <span class="string">'datasets'</span>),</span><br><span class="line">    transform=torchvision.transforms.Compose([</span><br><span class="line">        torchvision.transforms.Grayscale(num_output_channels=<span class="number">1</span>), <span class="comment"># 灰度化</span></span><br><span class="line">        torchvision.transforms.RandomAffine(</span><br><span class="line">            degrees=(-<span class="number">5</span>, <span class="number">5</span>), translate=(<span class="number">0.08</span>, <span class="number">0.08</span>), scale=(<span class="number">0.9</span>, <span class="number">1.1</span>)), <span class="comment"># 旋转，平移，放缩</span></span><br><span class="line">        torchvision.transforms.ToTensor(),</span><br><span class="line">        torchvision.transforms.RandomErasing(</span><br><span class="line">            scale=(<span class="number">0.02</span>, <span class="number">0.02</span>))</span><br><span class="line">    ]))<span class="comment"># 擦除</span></span><br><span class="line"><span class="comment"># 用ImageFolder表示文件夹为标签名</span></span><br></pre></td></tr></tbody></table></figure>

<p>数据集分为两部分（4:1）训练集和测试集</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">train_dataset, test_dataset = torch.utils.data.random_split(</span><br><span class="line">    dataset, [<span class="built_in">int</span>(<span class="built_in">len</span>(dataset) * <span class="number">0.8</span>), <span class="built_in">len</span>(dataset) - <span class="built_in">int</span>(<span class="built_in">len</span>(dataset) * <span class="number">0.8</span>)])</span><br></pre></td></tr></tbody></table></figure>

<p>损失函数和优化器</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">1e-3</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>训练评估</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        correct = <span class="number">0</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> test_loader:</span><br><span class="line">            x, y = x.to(device), y.to(device)  <span class="comment"># Move data to the device</span></span><br><span class="line">            y_pred = model(x)</span><br><span class="line">            loss = loss_fn(y_pred, y)</span><br><span class="line">            running_val_loss += loss.item()</span><br><span class="line"></span><br><span class="line">            _, predicted = torch.<span class="built_in">max</span>(y_pred.data, <span class="number">1</span>)</span><br><span class="line">            total += y.size(<span class="number">0</span>)</span><br><span class="line">            correct += (predicted == y).<span class="built_in">sum</span>().item()</span><br><span class="line">        avg_val_loss = running_val_loss / <span class="built_in">len</span>(test_loader)</span><br><span class="line">        accuracy = <span class="number">100</span> * correct / total</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'Epoch: <span class="subst">{epoch + <span class="number">1</span>}</span>, Accuracy: <span class="subst">{accuracy}</span>%'</span>)</span><br><span class="line">        writer.add_scalar(<span class="string">'Accuracy/test'</span>, accuracy, epoch)</span><br><span class="line">        writer.add_scalar(<span class="string">'Loss/val'</span>, avg_val_loss, epoch)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="模型部署"><a href="#模型部署" class="headerlink" title="模型部署"></a>模型部署</h2><p>使用opencv的dnn模块, softmax转换为概率，argmax转换为对应的类别（0 - 5）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">blob = cv.dnn.blobFromImage(image)</span><br><span class="line">self.net.setInput(blob)</span><br><span class="line">outputs = self.net.forward()</span><br><span class="line">outputs = outputs.flatten()</span><br><span class="line">exp_outputs = np.exp(outputs - np.<span class="built_in">max</span>(outputs))</span><br><span class="line">softmax_prob = exp_outputs / np.<span class="built_in">sum</span>(exp_outputs)</span><br><span class="line">confidence = np.<span class="built_in">max</span>(softmax_prob)</span><br><span class="line">label_id = np.argmax(softmax_prob)</span><br><span class="line"></span><br><span class="line">armor.confidence = confidence</span><br><span class="line">armor.number = self.class_names[label_id]</span><br><span class="line"></span><br><span class="line">armor.classification_result = <span class="string">f"<span class="subst">{armor.number}</span>: <span class="subst">{armor.confidence * <span class="number">100.0</span>:<span class="number">.1</span>f}</span>%"</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">docker build -t my-python-image .</span><br><span class="line">docker run -it \</span><br><span class="line">    --name my-python-container \</span><br><span class="line">    --<span class="built_in">env</span>=<span class="string">"DISPLAY"</span> \</span><br><span class="line">    --volume=<span class="string">"/tmp/.X11-unix:/tmp/.X11-unix:rw"</span> \</span><br><span class="line">    --volume=<span class="string">"<span class="subst">$(pwd)</span>:/app"</span> \</span><br><span class="line">    my-python-image</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用前记得</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">xhost +</span><br></pre></td></tr></tbody></table></figure>

<h1 id="PIP安装"><a href="#PIP安装" class="headerlink" title="PIP安装"></a>PIP安装</h1><p>如果不想使用docker部署可以使用</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></tbody></table></figure>

<p>安装所需要的包</p>
<p><strong>PS:</strong></p>
<p>项目基础是从rm_vision改过来的纯Python版本，同时也有ROS C++版的，详见<a href="https://github.com/langou0115/RoboDetect">here</a></p>
]]></content>
      <categories>
        <category>Robomaster</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket网络编程</title>
    <url>/df38ad26.html</url>
    <content><![CDATA[<p>套接字（socket）是 Linux 下的一种进程间通信机制（socket IPC），使用 socket IPC 可以使得在不同主机上的应用程序之间进行通信（网络通信），当然也可以是同一台主机上的不同应用程序。socket IPC 通常使用客户端&lt;—&gt;服务器这种模式完成通信，多个客户端可以同时连接到服务器中，与服务器之间完成数据交互。本文介绍Socket网络编程的基本函数、及TCP和UDP的实现。</p>
<span id="more"></span>

<h1 id="Socket基本函数"><a href="#Socket基本函数" class="headerlink" title="Socket基本函数"></a>Socket基本函数</h1><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>; <span class="comment">// 创建套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>; <span class="comment">// 绑定套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>; <span class="comment">// 监听套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>; <span class="comment">// 接受连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>; <span class="comment">// 连接套接字</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>; <span class="comment">// 发送数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>; <span class="comment">// 接收数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>; <span class="comment">// 发送数据到指定地址(UDP)</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>; <span class="comment">// 从指定地址接收数据(UDP)</span></span><br><span class="line"><span class="comment">// IP地址转换</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>; <span class="comment">// 将点分十进制字符串转换为网络字节序整数</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>; <span class="comment">// 将网络字节序整数转换为点分十进制字符串</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>socket</code>第二个参数</p>
<table>
<thead>
<tr>
<th>type</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SOCK_STREAM</td>
<td>提供有序的、可靠的、双向的、基于连接的字节流，能保证数据正确传送到对方，用于 TCP 协议；可以支持带外数据传输机制。</td>
</tr>
<tr>
<td>SOCK_DGRAM</td>
<td>固定长度的、无连接的、不可靠的报文传递，用于 UDP 协议</td>
</tr>
<tr>
<td>SOCK_SEQPACKET</td>
<td>固定长度的、有序的、可靠的、面向连接的报文传递</td>
</tr>
<tr>
<td>SOCK_RAW</td>
<td>表示原始套接字，它允许应用程序访问网络层的原始数据包，这个套接字用得比较少，暂时不用理会它</td>
</tr>
<tr>
<td>SOCK_RDM</td>
<td>提供不保证排序的可靠数据报层。</td>
</tr>
<tr>
<td>SOCK_PACKET</td>
<td>已过时，不应在应用程序中使用</td>
</tr>
</tbody></table>
<p><code>bind</code>中第二个参数<code>addr</code>是一个<code>sockaddr</code>结构体，<code>sockaddr</code>结构体是一个通用的套接字地址结构。但实际上，<code>sockaddr</code>结构体是一个抽象的结构体，它的具体实现是<code>sockaddr_in</code>结构体，<code>sockaddr_in</code>结构体是一个专门用于存储 IP 地址和端口号的结构体。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> {</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port; <span class="comment">// 端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">// IP地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">// 未使用</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 通过三次握手建立连接，通过四次挥手断开连接。TCP 通过滑动窗口协议实现可靠传输，通过拥塞控制算法实现流量控制。</p>
<p>三次握手：客户端向服务器发送一个 SYN 包，服务器收到后回复一个 SYN+ACK 包，客户端再回复一个 ACK 包，连接建立。</p>
<p>四次挥手：客户端向服务器发送一个 FIN 包，服务器收到后回复一个 ACK 包，服务器再回复一个 FIN 包，客户端再回复一个 ACK 包，连接断开。</p>
<p><strong>服务端实现流程：</strong><code>socket()-&gt; bind() -&gt; listen() -&gt; accept() -&gt; recv()/send() -&gt; close()</code></p>
<p><strong>客户端实现流程：</strong><code>socket() -&gt; connect() -&gt; send()/recv() -&gt; close()</code></p>
<p>服务端代码(perror跳过)：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"><span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line"><span class="built_in">listen</span>(sockfd, <span class="number">5</span>);</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(server_addr);</span><br><span class="line"><span class="type">int</span> clientfd = <span class="built_in">accept</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, &amp;len);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">recv</span>(clientfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Server recv: "</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, <span class="string">" from server"</span>);</span><br><span class="line">        size += <span class="built_in">strlen</span>(<span class="string">" from server"</span>);</span><br><span class="line">        <span class="built_in">send</span>(clientfd, buffer, size, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端代码(perror跳过)：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(SERVER_PORT);</span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(SERVER_IP);</span><br><span class="line"><span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        std::cin &gt;&gt; buffer;</span><br><span class="line">        <span class="built_in">send</span>(sockfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">recv</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Client recv: "</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP（User Datagram Protocol）是一种无连接的、不可靠的、基于数据报的传输层通信协议。UDP 通过数据报传输数据，不保证数据的可靠传输，不保证数据的顺序传输。</p>
<p><strong>服务端实现流程：</strong><code>socket() -&gt; bind() -&gt; recvfrom()/sendto() -&gt; close()</code></p>
<p><strong>客户端实现流程：</strong><code>socket() -&gt; sendto()/recvfrom() -&gt; close()</code></p>
<p>服务端代码(perror跳过)：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"><span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(server_addr);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">recvfrom</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, &amp;len);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Server recv: "</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, <span class="string">" from server"</span>);</span><br><span class="line">        size += <span class="built_in">strlen</span>(<span class="string">" from server"</span>);</span><br><span class="line">        <span class="built_in">sendto</span>(sockfd, buffer, size, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端代码(perror跳过)：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = <span class="built_in">htons</span>(SERVER_PORT);</span><br><span class="line">server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(SERVER_IP);</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        std::cin &gt;&gt; buffer;</span><br><span class="line">        <span class="built_in">sendto</span>(sockfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">        <span class="type">int</span> size = <span class="built_in">recvfrom</span>(sockfd, buffer, <span class="built_in">sizeof</span>(buffer), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, (<span class="type">socklen_t</span> *)<span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Client recv: "</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Linux应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>


<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>图论</title>
    <url>/10f14ed7.html</url>
    <content><![CDATA[<p>第二难的一个…..</p>
<span id="more"></span>

<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">组合</a></p>
<p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">分割</a></p>
<p><a href="https://leetcode.cn/problems/subsets-ii/description/">子集</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1219">应用</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(...)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(){</span><br><span class="line">       <span class="comment">// 递归终止 </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(){</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(...)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><a href="https://www.luogu.com.cn/problem/P1443">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">bfs</span>(<span class="type">int</span> x, <span class="type">int</span> y){</span><br><span class="line">    queue&lt;Point&gt; que;</span><br><span class="line">    Point s = <span class="built_in">Point</span>(x, y, <span class="number">0</span>);</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()){</span><br><span class="line">        s = que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="keyword">for</span>(...){</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span>(...){</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">Point</span>(s.x, s.y, s.step+<span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="图的储存"><a href="#图的储存" class="headerlink" title="图的储存"></a>图的储存</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>过于简单….省略</p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p><strong>第一种写法</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = ....; <span class="comment">//最大点的数量</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存一个from-&gt;to边的实例</span></span><br><span class="line">cin &gt;&gt; from &gt;&gt; to;</span><br><span class="line">G[from].<span class="built_in">push_back</span>(to);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>第二种写法 链式前向星</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>{</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">} edge[MAXM];</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    edge[++cnt].to = to;</span><br><span class="line">    edge[cnt].val = val;</span><br><span class="line">    edge[cnt].next = head[from];</span><br><span class="line">    head[from] = cnt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="连通问题"><a href="#连通问题" class="headerlink" title="连通问题"></a>连通问题</h1><h2 id="Tarjan求强连通分量"><a href="#Tarjan求强连通分量" class="headerlink" title="Tarjan求强连通分量"></a>Tarjan求强连通分量</h2><p><a href="https://www.luogu.com.cn/problem/P2863">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN]; <span class="comment">// 存储好的图</span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN]; <span class="comment">// dfn为遍历到x点的时间，low表示x点可以回溯到的时间最小的起点</span></span><br><span class="line"><span class="type">int</span> instack[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> tim = <span class="number">1</span>;</span><br><span class="line">    st.<span class="built_in">push</span>(x);</span><br><span class="line">    instack[x] = <span class="number">1</span>;</span><br><span class="line">    dfn[x] = low[n] = tim++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++){</span><br><span class="line">        <span class="type">int</span> j = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[j]){</span><br><span class="line">            <span class="built_in">tarjan</span>(j);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[j]);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(instack[j]){</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dfn[x] == low[x]){</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">do</span>{</span><br><span class="line">            tmp = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            instack[tmp] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// todo</span></span><br><span class="line">        }<span class="keyword">while</span>(tmp != x);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="利用Tarjan进行缩点"><a href="#利用Tarjan进行缩点" class="headerlink" title="利用Tarjan进行缩点"></a>利用Tarjan进行缩点</h2><p><a href="https://www.luogu.com.cn/problem/P3387">模板</a></p>
<p>将强连通分量缩成一个点，变成有向无环图（DAG）</p>
<p><strong>template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> degree[MAXN]; <span class="comment">// 有向无环图每个点的入度</span></span><br><span class="line"><span class="type">int</span> tb[MAXN], tb_a[MAXN], cnt = <span class="number">1</span>, times = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// tb记录原来的点映射到新的点是什么， tb_a记录新的点所花费的时间, cnt记录新点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	dfn[x] = low[x] = times++;</span><br><span class="line">	instack[x] = <span class="number">1</span>;</span><br><span class="line">	s.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++){</span><br><span class="line">		<span class="type">int</span> y = G[x][i];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y]){</span><br><span class="line">			<span class="built_in">tarjan</span>(y);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(instack[y]){</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	 <span class="comment">// 重点在此</span></span><br><span class="line">	<span class="keyword">if</span>(dfn[x] == low[x]){</span><br><span class="line">		<span class="type">int</span> tmp;</span><br><span class="line">		<span class="keyword">do</span>{</span><br><span class="line">			tmp = s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">			instack[tmp] = <span class="number">0</span>;</span><br><span class="line">			tb[tmp] = cnt;</span><br><span class="line">			tb_a[cnt] += a[tmp];</span><br><span class="line">		}<span class="keyword">while</span>(tmp != x);</span><br><span class="line">		dp[cnt] = tb_a[cnt];</span><br><span class="line">		cnt++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); j++){</span><br><span class="line">			<span class="type">int</span> y = G[i][j];</span><br><span class="line">			<span class="keyword">if</span>(tb[i] != tb[y]){ <span class="comment">// 映射点相同不做处理</span></span><br><span class="line">				TG[tb[i]].<span class="built_in">push_back</span>(tb[y]);</span><br><span class="line">				indegree[tb[y]]++;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Tarjan求割点和桥"><a href="#Tarjan求割点和桥" class="headerlink" title="Tarjan求割点和桥"></a>Tarjan求割点和桥</h2><p><a href="https://www.luogu.com.cn/problem/P3388">模板割点</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1656">模板桥</a></p>
<blockquote>
<p><strong>ps: 无向图中不考虑儿子到父亲的边</strong></p>
</blockquote>
<p><strong>割点</strong>：去除后图不能连通的点</p>
<p><strong>桥</strong>：去除后图不能连通的边</p>
<p><strong>割点条件</strong>：</p>
<ol>
<li>非root点 &amp;&amp; 有儿子 &amp;&amp; low[x儿子] &gt;= dfn[x]</li>
<li>root点 &amp;&amp; 有两个及以上的儿子</li>
</ol>
<p><strong>x-&gt;y是桥条件</strong>：</p>
<p>low[y] &gt; dfn[x]</p>
<p><strong>template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], root, ans[MAXN], fa[MAXN]; <span class="comment">// fa[x]为0时, x为根节点</span></span><br><span class="line"><span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dfn[x] = low[x] = time++;</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); i++){</span><br><span class="line">        <span class="type">int</span> y = G[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y]){</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            child++;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(!fa[x] &amp;&amp; child &gt;= <span class="number">2</span>) ans[x] = <span class="number">1</span>; <span class="comment">// 割点条件一，会重复运行这一句</span></span><br><span class="line">            <span class="keyword">if</span>(fa[x] &amp;&amp; low[y] &gt;= dfn[x]) ans[x] = <span class="number">1</span>; <span class="comment">// 割点条件二，会重复运行这一句</span></span><br><span class="line">            <span class="keyword">if</span>(low[y] &gt; dfn[x]) ... <span class="comment">// 桥的条件</span></span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(fa[x] != y){</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]){</span><br><span class="line">        <span class="built_in">tarjan</span>(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>xxxxxxxxxx&nbsp;auto deletor = [](Socket* pSocket) { &nbsp; &nbsp;//关闭句柄 &nbsp; &nbsp;pSocket-&gt;close(); &nbsp; &nbsp;//TODO: 你甚至可以在这里打印一行日志… &nbsp; &nbsp;delete pSocket;};​std::unique_ptr&lt;Socket, void(*)(Socket * pSocket)&gt; spSocket(new Socket(), deletor);c++</p>
<p><strong>本质还是贪心算法</strong></p>
<p>储存使用<strong>链式前向星</strong></p>
<p>适用于<strong>非负权边图</strong>，求最短路径</p>
<p>一定要使用<strong>优先队列</strong>！！！！</p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>{</span><br><span class="line">	<span class="type">int</span> to, val, next;</span><br><span class="line">}edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	edge[++cnt] = {to, val, head[from]};</span><br><span class="line">	head[from] = cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>{</span><br><span class="line">	<span class="type">int</span> pos;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; node) <span class="type">const</span>{</span><br><span class="line">		<span class="keyword">return</span> d &gt; node.d;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="comment">// int vis[MAXN];</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>({s, <span class="number">0</span>});</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">		Node x = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> pos = x.pos;</span><br><span class="line">		<span class="keyword">if</span>(dis[pos] &lt; x.d) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = head[pos]; i; i = edge[i].next){</span><br><span class="line">			<span class="type">int</span> y = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[y] &gt; dis[pos] + edge[i].val){</span><br><span class="line">				dis[y] = dis[pos] + edge[i].val;</span><br><span class="line">				q.<span class="built_in">push</span>({y, dis[y]});</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="type">int</span> from, to, val;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">		<span class="built_in">add_edge</span>(from, to, val);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">dijkstra</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cout &lt;&lt; dis[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p><a href="https://www.luogu.com.cn/problem/B3647">模板</a></p>
<p><strong>求多源最短路径</strong></p>
<p>存储使用<strong>邻接矩阵</strong></p>
<p>不适用图中<strong>带负边的环</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">105</span>; </span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> G[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++){</span><br><span class="line">			<span class="keyword">if</span>(i != j) G[i][j] = INF;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> from, to, val;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">		G[from][to] = <span class="built_in">min</span>(G[from][to], val);</span><br><span class="line">		G[to][from] = <span class="built_in">min</span>(G[to][from], val);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++){</span><br><span class="line">				<span class="keyword">if</span>(G[i][k] &lt; INF &amp;&amp; G[k][j] &lt; INF)</span><br><span class="line">					G[i][j] = <span class="built_in">min</span>(G[i][j], G[i][k] + G[k][j]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;= n; j++){</span><br><span class="line">			cout &lt;&lt; G[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman Ford算法"></a>Bellman Ford算法</h2><p><strong>求单源最短路径</strong></p>
<p>使用<strong>三元组</strong>来储存图（存边）</p>
<p>可用于负权边图，但不适用负环路图</p>
<p>可检测负环路图</p>
<p>时间复杂度不如Dijkstra算法好</p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>, MAXM = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> u[MAXM], v[MAXM], w[MAXM];</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++){</span><br><span class="line">		<span class="type">int</span> check = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++){</span><br><span class="line">			<span class="keyword">if</span>(dis[v[j]] &gt;= dis[u[j]] + w[j]){</span><br><span class="line">				dis[v[j]] = dis[u[j]] + w[j];</span><br><span class="line">				check = <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(!check) <span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">// 再进行一次循环，若有更新就可以判断有负权边</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i] = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bellman_ford</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cout &lt;&lt; dis[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p><a href="https://www.luogu.com.cn/problem/P3385">模板</a></p>
<p>是Bellman Ford算法的优化</p>
<p>可用来判断图中是否有负环</p>
<p>使用<strong>链式前向星</strong>来储存图</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>, M = <span class="number">6e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>{</span><br><span class="line">	<span class="type">int</span> to, val, next;</span><br><span class="line">}edge[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	edge[++tot] = {to, val, head[from]};</span><br><span class="line">	head[from] = tot;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N], vis[N], cnt[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edge[i].next){</span><br><span class="line">			<span class="type">int</span> y = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span>(dis[y] &gt; dis[x] + edge[i].val){</span><br><span class="line">				dis[y] = dis[x] + edge[i].val;</span><br><span class="line">				cnt[y] = cnt[x] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(cnt[y] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span>(!vis[y]){</span><br><span class="line">					q.<span class="built_in">push</span>(y);</span><br><span class="line">					vis[y] = <span class="number">1</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--){</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		tot = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">			<span class="type">int</span> from, to, val;</span><br><span class="line">			cin &gt;&gt; from &gt;&gt; to &gt;&gt; val;</span><br><span class="line">			<span class="built_in">add_edge</span>(from, to, val);</span><br><span class="line">			<span class="keyword">if</span>(val &gt;= <span class="number">0</span>) <span class="built_in">add_edge</span>(to, from, val); </span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="type">bool</span> res = <span class="built_in">SPFA</span>();</span><br><span class="line">		<span class="keyword">if</span>(res) cout &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><a href="https://www.luogu.com.cn/problem/P3367">模板</a></p>
<p>将不同的元素放在同一个集合进行区分</p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>, M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(fa[x] == x){</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">		<span class="keyword">return</span> fa[x];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	x = <span class="built_in">find</span>(x);</span><br><span class="line">	y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">	fa[y] = x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		<span class="type">int</span> z, x, y;</span><br><span class="line">		cin &gt;&gt; z &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="comment">// z为1表示合并，z为2表示查询是否在一个集合</span></span><br><span class="line">		<span class="keyword">if</span>(z == <span class="number">1</span>){</span><br><span class="line">			<span class="built_in">join</span>(x, y);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(z == <span class="number">2</span>){</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) cout &lt;&lt; <span class="string">"Y\n"</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">"N\n"</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><a href="https://www.luogu.com.cn/problem/P3366">模板</a></p>
<p>n个点，n-1条边，边的权值和最小</p>
<h2 id="Kruscal算法"><a href="#Kruscal算法" class="headerlink" title="Kruscal算法"></a>Kruscal算法</h2><p>适用于无向图，将边按小到大进行排列，依次选择，成环就丢弃，直到边的数量为n - 1条</p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>, M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>{</span><br><span class="line">	<span class="type">int</span> u, v, z; </span><br><span class="line">}edge[M];</span><br><span class="line"><span class="type">int</span> n, m, fa[N], cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 并查集操作 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(fa[x] == x){</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">		<span class="keyword">return</span> fa[x];</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> f_x = <span class="built_in">find</span>(x);</span><br><span class="line">	<span class="type">int</span> f_y = <span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(f_x == f_y) <span class="keyword">return</span>;</span><br><span class="line">	fa[f_x] = f_y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruscal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">sort</span>(edge, edge + m, [](Edge e1, Edge e2){</span><br><span class="line">		<span class="keyword">return</span> e1.z &lt; e2.z;</span><br><span class="line">	});</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> u = edge[i].u, v = edge[i].v;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(u) == <span class="built_in">find</span>(v)) <span class="keyword">continue</span>; <span class="comment">// 成环就丢弃</span></span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">join</span>(u, v);</span><br><span class="line">			ans += edge[i].z;</span><br><span class="line">			cnt++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].z;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kruscal</span>();</span><br><span class="line">	<span class="keyword">if</span>(cnt == n - <span class="number">1</span>) cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">"orz"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> dis[N], vis[N];</span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> v, w, nxt;</span><br><span class="line">} edges[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    edges[++cnt].v = v;</span><br><span class="line">    edges[cnt].w = w;</span><br><span class="line">    edges[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n, m, cnt_n = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add_edge</span>(v, u, w);</span><br><span class="line">    }</span><br><span class="line">    std::<span class="built_in">fill</span>(dis, dis + N, INF);</span><br><span class="line">    std::priority_queue&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, </span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, std::greater&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>() &amp;&amp; cnt_n &lt; n)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> u = pq.<span class="built_in">top</span>().second, w = pq.<span class="built_in">top</span>().first;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        cnt_n++;</span><br><span class="line">        sum += w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">0</span>; i = edges[i].nxt)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> v = edges[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; edges[i].w &lt; dis[v])</span><br><span class="line">            {</span><br><span class="line">                dis[v] = edges[i].w;</span><br><span class="line">                pq.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(dis[v], v));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cnt_n == n) std::cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">"orz"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式软件基础知识</title>
    <url>/51d11c96.html</url>
    <content><![CDATA[<p>本文介绍常用的嵌入式软件的基础知识，并进行总结，方便日后复习查看</p>
<span id="more"></span>

<h1 id="STM32启动"><a href="#STM32启动" class="headerlink" title="STM32启动"></a>STM32启动</h1><h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><ol>
<li><strong>从Flash启动</strong>，将Flash地址0x0800 0000映射到0x00000000，这样启动以后就相当于从0x08000000开始的，这是我们最常用的模式；</li>
<li><strong>从SRAM启动</strong>，将SRAM地址0x20000000映射到0x00000000，这样启动以后就相当于从0x20000000开始的，用于调试。</li>
<li><strong>从系统存储器启动(System memory)，</strong>将系统存储器地址0x1FFFF000映射到0x00000000，提供了可以通过UART1接口将用户的代码下载到Flash中的功能。</li>
</ol>
<img src="/51d11c96/image-20240910205430419.png" class="" title="启动模式配置">

<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><ol>
<li><p>初始化堆栈指针SP=_initial_sp</p>
</li>
<li><p>初始化PC 指针=Reset_Handler</p>
</li>
<li><p>初始化中断向量表</p>
</li>
<li><p>配置系统时钟</p>
</li>
<li><p>调用C 库函数_main 初始化用户堆栈，从而最终调用main 函数</p>
</li>
</ol>
<h1 id="STM32-GPIO"><a href="#STM32-GPIO" class="headerlink" title="STM32 GPIO"></a>STM32 GPIO</h1><ol>
<li><strong>推挽输出(Push-Pull Output)：</strong>推挽输出模式是最常见的GPIO输出模式。在该模式下，引脚可以输出高电平或低电平，同时具有一定的驱动能力。引脚在输出低电平时形成低阻抗，输出高电平时形成高阻抗，可以驱动外部电路。</li>
<li><strong>开漏输出(Open-Drain Output)：</strong>开漏输出模式是一种能够输出低电平和高阻抗的GPIO模式。在该模式下，引脚只能输出低电平，要输出高电平需要通过外部上拉电阻或其他方式。通常用于与外部器件连接，例如与开漏输出的I2C总线器件进行通信。</li>
<li><strong>复用推挽输出(AF Push-Pull Output)：</strong>复用推挽输出模式允许将GPIO引脚用作特定外设功能。在该模式下，引脚可以输出高电平或低电平，并具有一定的驱动能力。</li>
<li><strong>复用开漏输出(AF Open-Drain Output)：</strong>复用开漏输出模式允许将GPIO引脚用作特定外设功能。在该模式下，引脚只能输出低电平，要输出高电平需要通过外部上拉电阻或其他方式。</li>
<li><strong>浮空输入(Floating Input)：</strong>浮空输入模式是一种高阻抗输入模式。在该模式下，引脚不连接到外部电路，处于高阻抗状态。可以通过读取引脚电平来检测外部信号。</li>
<li><strong>上拉输入(Pull-up Input)：</strong>上拉输入模式是一种具有内部上拉电阻的GPIO输入模式。在该模式下，引脚连接到外部电路，通过内部上拉电阻来维持默认电平为高电平。</li>
<li><strong>下拉输入(Pull-down Input)：</strong>下拉输入模式是一种具有内部下拉电阻的GPIO输入模式。在该模式下，引脚连接到外部电路，通过内部下拉电阻来维持默认电平为低电平。</li>
<li><strong>模拟输入(Analog Input)：</strong>模拟输入模式是一种用于ADC（模数转换器）输入的特殊模式。在该模式下，引脚可以接收连续变化的模拟信号。</li>
</ol>
<h1 id="STM32时钟"><a href="#STM32时钟" class="headerlink" title="STM32时钟"></a>STM32时钟</h1><p>STM32有五个时钟源：HSI、HSE、LSI、LSE、PLL</p>
<ol>
<li><strong>HSI</strong>是高速内部时钟，RC振荡器，频率为8MHz，上电后默认的系统时钟SYSCLK = 8MHz，Flash编程时钟。</li>
<li><strong>HSE</strong>是高速外部时钟，可接石英/陶瓷谐振器，或者接外部的时钟源，频率范围为4MHz~16MHz。</li>
<li><strong>LSI</strong>是低速内部时钟，RC振荡器，频率为40kHz，可用于独立看门狗IWDG、实时时钟RTC。</li>
<li><strong>LSE</strong>是低速外部时钟，接频率为32.768kHz的石英晶体。</li>
<li><strong>PLL</strong>是锁相环倍频器，可以将HSI或HSE时钟倍频后输出，最大输出频率为72MHz。</li>
</ol>
<h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><p><strong>大小端</strong>是指在多字节数据的存储时，高字节和低字节的存储顺序。在<strong>小端模式</strong>下，低字节存储在低地址，高字节存储在高地址；在<strong>大端模式</strong>下，高字节存储在低地址，低字节存储在高地址。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LittleEndtoBigEnd</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)&amp;a;</span><br><span class="line">    <span class="keyword">return</span> ((p[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (p[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (p[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | p[<span class="number">3</span>]);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)&amp;a;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">0x78</span>)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Little Endian"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Big Endian"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="built_in">LittleEndtoBigEnd</span>(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><p><strong>UART</strong>全称是通用<strong>异步收发传输器</strong>（Universal Asynchronous Receiver/Transmitter)，它通常称作UART，是一种异步收发传输器, 是设备间进行异步通信的关键模块。UART负责处理数据总线和串行口之间的串/并、并/串转换，并规定了帧格式；通信双方只要采用相同的帧格式和波特率，就能在未共享时钟信号的情况下，仅用<strong>两根信号线（RX 和TX）就可以完成通信过程，因此也称为异步串行通信</strong>。</p>
<img src="/51d11c96/image-20240910210746279.png" class="" title="UART帧格式">

<p><strong>起始位：</strong>先发出一个逻辑”0”信号，表示传输字符的开始；</p>
<p><strong>数据位：</strong>可以是5~8位逻辑”0”或”1”；如ASCII码（7位），扩展BCD码（8位）；小端传输，即LSB先发，MSB后发；</p>
<p><strong>校验位：</strong>数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)；</p>
<p><strong>停止位：</strong>它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平（用于双方同步，<strong>停止位时间间隔越长，容错能力越强</strong>）；</p>
<p><strong>空闲位：</strong>处于逻辑“1”状态，表示当前线路上没有数据传送；</p>
<h1 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h1><p><strong>IIC</strong>（Inter-Integrated Circuit）也称I2C，中文叫<strong>集成电路总线</strong>。是一个<strong>多主从</strong>的<strong>串行</strong>总线，由飞利浦公司发明的通讯总线，属于<strong>半双工</strong>同步<strong>传输类总线，</strong>仅由两条线就能完成多机通讯<strong>，一条</strong>SCL时钟线<strong>，另外一条</strong>双向数据线<strong>SDA</strong>，IIC总线要求每个设备SCL/SDA线都是漏极开路模式，因此必须带上拉电阻才能正常工作。I2C协议占用引脚少，硬件实现简单，可扩展性强，I2C数据传输速率有标准模式(100kbps)、快速模式(400kbps)和高速模式(3.4Mbps)。</p>
<img src="/51d11c96/image-20240911201001466.png" class="" title="I2C常用连接方式">

<h2 id="起始位"><a href="#起始位" class="headerlink" title="起始位"></a>起始位</h2><p>   SCL处于高电平，SDA出现下降沿</p>
   <img src="/51d11c96/image-20240911201126943.png" class="" title="I2C起始位">

<h2 id="停止位"><a href="#停止位" class="headerlink" title="停止位"></a>停止位</h2><p>  SCL处于高电平，SDA出现上升沿</p>
   <img src="/51d11c96/image-20240911201220301.png" class="" title="I2C停止位">

<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>  I2C 总线在数据传输的时候要保证在 SCL 高电平期间，SDA 上的数据稳定，因此 SDA 上的数据变化只能在 SCL 低电平期间发生。</p>
   <img src="/51d11c96/image-20240911201320902.png" class="" title="I2C数据传输">

<h2 id="应答信号"><a href="#应答信号" class="headerlink" title="应答信号"></a>应答信号</h2><p>  当 I2C 主机发送完 8 位数据以后会将 SDA 设置为输入状态，等待 I2C 从机应答，也就是等到 I2C 从机告诉主机它接收到数据了。应答信号是由从机发出的，主机需要提供应答信号所需的时钟，主机发送完 8 位数据以后紧跟着的一个时钟信号就是给应答信号使用的。从机通过将 SDA 拉低来表示发出应答信号，表示通信成功，否则表示通信失败。</p>
<h2 id="I2C写时序"><a href="#I2C写时序" class="headerlink" title="I2C写时序"></a>I2C写时序</h2>   <img src="/51d11c96/image-20240911202050048.png" class="" title="I2C写时序">

<h2 id="I2C读时序"><a href="#I2C读时序" class="headerlink" title="I2C读时序"></a>I2C读时序</h2>   <img src="/51d11c96/image-20240911202117761.png" class="" title="I2C读时序">

<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p><strong>SPI是串行外设接口</strong>（Serial Peripheral Interface）的缩写。是美国摩托罗拉公司（Motorola）最先推出的一种同步串行传输规范，也是一种单片机外设芯片串行扩展接口，<strong>是一种高速、全双工、同步通信总线</strong>，所以可以在同一时间发送和接收数据，SPI没有定义速度限制，通常能达到甚至超过10M/bps。</p>
<p>SPI通信原理很简单，需要至少4根线，单向传输时3根线，它们是MISO（主设备数据输入）、MOSI（主设备数据输出）、SCLK（时钟）和CS/SS（片选）。</p>
<ul>
<li><strong>MISO</strong>（ Master Input Slave Output）<strong>简称主入从出信号线</strong>：主设备数据输入，从设备数据输出；</li>
<li><strong>MOSI</strong>（Master Output Slave Input）<strong>简称主出从入信号线</strong>：主设备数据输出，从设备数据输入；</li>
<li><strong>SCLK</strong>（Serial Clock）<strong>串行时钟</strong>：为 SPI 通信提供时钟；时钟信号，由主设备产生；</li>
<li><strong>CS/SS</strong>（Chip Select/Slave Select）为<strong>片选信号线</strong>：为 SPI 通信提供时钟；从设备使能信号，由主设备控制，一主多从时，CS/SS是从芯片是否被主芯片选中的控制信号，只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。</li>
</ul>
<p>SPI只有主模式和从模式之分，没有读和写的说法，<strong>外设的写操作和读操作是同步完成的。</strong>如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。换句话理解就是，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</p>
<img src="/51d11c96/image-20240911203329960.png" class="" title="SPI时序图">

<p><strong>时钟极性和时钟相位</strong></p>
<p><strong>CPOL</strong>控制时钟极性</p>
<ul>
<li>CPOL = 0：时钟空闲IDLE为低电平 0；</li>
<li>CPOL = 1：时钟空闲IDLE为高电平1。</li>
</ul>
<p><strong>CPHA</strong>控制时钟相位</p>
<ul>
<li>CPHA = 0：在时钟信号SCK的第一个跳变沿采样；</li>
<li>CPHA = 1：在时钟信号SCK的第二个跳变沿采样。</li>
</ul>
<h1 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h1><p>MQTT是一种一种基于<strong>客户端-服务端</strong>架构的消息传输协议，所以在 MQTT 协议通信中，有两个最为重要的角色，它们便是服务端和客户端。</p>
<p>MQTT 服务端通常是一台服务器（broker），它是 MQTT 信息传输的枢纽，负责将 MQTT 客户端发送来的信息传递给 MQTT 客户端；MQTT 服务端还负责管理 MQTT 客户端，以确保客户端之间的通讯顺畅，保证 MQTT 信息得以正确接收和准确投递。</p>
<p><strong>MQTT主题</strong></p>
<p>MQTT 通信中，消息的传递是通过主题（topic）来进行的。主题是消息的分类标识，客户端可以订阅（subscribe）一个或多个主题，也可以发布（publish）消息到一个或多个主题。当客户端发布消息到某个主题时，订阅了这个主题的客户端就会收到这个消息。</p>
<h2 id="MQTT客户端连接"><a href="#MQTT客户端连接" class="headerlink" title="MQTT客户端连接"></a>MQTT客户端连接</h2><ol>
<li>客户端向服务端发送 CONNECT 报文，连接到服务端。</li>
<li>服务端向客户端发送 CONNACK 报文，确认连接建立。</li>
</ol>
<p>MQTT 报文组成分为三个部分：固定头（Fixed header）、可变头（Variable header）以及有效载荷（Payload，消息体）。</p>
<p><strong>固定头</strong>：固定头部分包含了报文类型（Connect 报文的报文类型是 1）、标志位（Connect 报文的标志位是 0000 0000）、剩余长度（Remaining Length）。</p>
<p><strong>可变头</strong>：可变头部分包含了协议名（Protocol Name）、协议版本号（Protocol Version Number）、连接标志（Connect Flags）、保持连接时间（Keep Alive）、有效载荷（Payload）。</p>
<p><strong>有效载荷</strong>：有效载荷部分包含了客户端标识符（Client Identifier）、遗嘱主题（Will Topic）、遗嘱消息（Will Message）、用户名（User Name）、密码（Password）。</p>
<h3 id="Connect-报文"><a href="#Connect-报文" class="headerlink" title="Connect 报文"></a>Connect 报文</h3><img src="/51d11c96/image-20240925092855338.png" class="" title="Connect报文">

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">clientId <span class="comment">// 客户端 id</span></span><br><span class="line">keepAlive <span class="comment">// 心跳时间间隔</span></span><br><span class="line"><span class="comment">/* cleanSession=1，当 MQTT 客户端由离线（与服务端断开连接）再次上线时，离线期间发</span></span><br><span class="line"><span class="comment">送给客户端的消息会被清除，客户端不会收到这些消息；cleanSession=0，当 MQTT 客户端由</span></span><br><span class="line"><span class="comment">离线再次上线时，离线期间发送给客户端的消息会被保留，客户端会收到这些消息。 */</span></span><br><span class="line">cleanSession <span class="comment">// 是否清除会话</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="ConnectAck-报文"><a href="#ConnectAck-报文" class="headerlink" title="ConnectAck 报文"></a>ConnectAck 报文</h3><img src="/51d11c96/image-20240925094048800.png" class="" title="CONNACK">

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">returnCode <span class="comment">//连接返回码</span></span><br><span class="line"><span class="comment">/*与CONNECT报文clearSession有关*/</span></span><br><span class="line">sessionPresent <span class="comment">//会话状态</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="MQTT客户端断开连接"><a href="#MQTT客户端断开连接" class="headerlink" title="MQTT客户端断开连接"></a>MQTT客户端断开连接</h2><p>如果客户端想要断开与服务端的连接，此时客户端可以主动向服务端发送一个 DISCONNECT 报文来断开与服务端的连接</p>
<h2 id="发布消息、订阅主题、取消订阅主题"><a href="#发布消息、订阅主题、取消订阅主题" class="headerlink" title="发布消息、订阅主题、取消订阅主题"></a>发布消息、订阅主题、取消订阅主题</h2><p>MQTT 客户端向服务端发布消息其实就是向服务端发送一个 PUBLISH 报文，服务端收到客户端发送过来的 PUBLISH 报文之后，会向发送发回复一个报文。</p>
<img src="/51d11c96/image-20240925094423089.png" class="" title="PUBLISH报文">

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">packetId <span class="comment">// 报文标识符</span></span><br><span class="line">topicName <span class="comment">// 主题名</span></span><br><span class="line">payload <span class="comment">// 消息内容</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">QoS=0，最多一次传输，消息发布者只发布一次消息，不关心消息是否被接收；</span></span><br><span class="line"><span class="comment">QoS=1，至少一次传输，消息发布者至少发布一次消息，确保消息至少被接收一次；</span></span><br><span class="line"><span class="comment">QoS=2，恰好一次传输，消息发布者只发布一次消息，确保消息只被接收一次。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">qos <span class="comment">// 服务质量</span></span><br><span class="line">retain <span class="comment">// 保留标志</span></span><br><span class="line"><span class="comment">/*dup 标志指示此消息是否重复。只在 QoS 1 和 QoS 2 级别中使用。*/</span></span><br><span class="line">dup <span class="comment">// 重发标志</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>主题名称要求</strong></p>
<ul>
<li>主题名称必须是 UTF-8 编码的字符串</li>
<li>主题名称可以包含通配符 (+ 和 #)</li>
<li>主题名称可以包含多级目录（eg: a/b/c）</li>
</ul>
<h1 id="OTA升级"><a href="#OTA升级" class="headerlink" title="OTA升级"></a>OTA升级</h1>]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法</title>
    <url>/2cc2fa98.html</url>
    <content><![CDATA[<p>蓝桥杯之前进行的一些算法小总结，本文只写了一些简单的算法，图论，树论，动态规划，排序请看该站算法目录下的…..</p>
<span id="more"></span>


<h1 id="C-小技巧"><a href="#C-小技巧" class="headerlink" title="C++小技巧"></a>C++小技巧</h1><h2 id="重定义比较器"><a href="#重定义比较器" class="headerlink" title="重定义比较器"></a>重定义比较器</h2><ul>
<li><strong>lambda变量</strong><br><strong>[=]捕获变量值</strong><br><strong>[&amp;]捕获变量引用</strong></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> {</span><br><span class="line"> &nbsp; &nbsp;std::string name;</span><br><span class="line"> &nbsp; &nbsp;<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"> &nbsp; &nbsp;<span class="built_in">Person</span>(std::string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) {}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> &nbsp; &nbsp;<span class="function">Person <span class="title">alice</span><span class="params">(<span class="string">"Alice"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"> &nbsp; &nbsp;<span class="function">Person <span class="title">bob</span><span class="params">(<span class="string">"Bob"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> &nbsp; &nbsp;<span class="comment">// 使用 lambda 表达式比较两个 Person 对象的年龄</span></span><br><span class="line"> &nbsp; &nbsp;Person older = std::<span class="built_in">max</span>(alice, bob, [](<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line"> &nbsp;  });</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>比较器</strong></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> {</span><br><span class="line">  std::string name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Person</span>(std::string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较器函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareByAge</span><span class="params">(<span class="type">const</span> Person&amp; a, <span class="type">const</span> Person&amp; b)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="function">Person <span class="title">alice</span><span class="params">(<span class="string">"Alice"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">bob</span><span class="params">(<span class="string">"Bob"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用比较器函数</span></span><br><span class="line">  Person older = std::<span class="built_in">max</span>(alice, bob, compareByAge);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><strong>优先队列（堆）</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{</span><br><span class="line">            <span class="comment">// 注意这里！！！！！</span></span><br><span class="line">    	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 对于类 重写 bool operator&lt;(const Node&amp;) const{}即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> weigh; </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; apples;</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">8</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"> &nbsp; &nbsp;apples.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"> &nbsp; &nbsp; <span class="comment">// output: 1 2 3 4 8 9</span></span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>对于pair&lt;int,int&gt; 优先比较first</strong></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><table>
<thead>
<tr>
<th><strong>常用</strong></th>
<th><strong>map</strong></th>
<th><strong>multiply_map</strong></th>
<th><strong>unordered_map</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>底层原理</strong></td>
<td><strong>红黑树</strong></td>
<td><strong>红黑树</strong></td>
<td><strong>哈希表</strong></td>
</tr>
<tr>
<td><strong>时间复杂度（查找）</strong></td>
<td><strong>O(logn)</strong></td>
<td><strong>O(logn)</strong></td>
<td><strong>O(1)</strong></td>
</tr>
<tr>
<td><strong>是否有序</strong></td>
<td><strong>有序</strong></td>
<td><strong>有序</strong></td>
<td><strong>无序</strong></td>
</tr>
</tbody></table>
<p><strong>一般使用unordere_map</strong></p>
<h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p><strong>去重</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">unique</span>(a, a + n); <span class="comment">// 返回去重后数组的最后一个元素的后一个迭代器</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + k, vec.<span class="built_in">end</span>() <span class="comment">/*, lamda*/</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>将数组中第k + 1大的元素放到vec[k]的位置上</strong></p>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用欧几里得算法计算最大公约数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">while</span> (b != <span class="number">0</span>) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;a %= b;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="built_in">swap</span>(a, b);</span><br><span class="line"> &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><strong>容斥原理</strong>：<ul>
<li>计算小于等于<code>x</code> 的丑数的数量，即可以被 <code>a</code> 或 <code>b</code> 或 <code>c</code> 整除的数的数量。</li>
<li>这可以通过以下公式计算：<br>count= 𝑥 / 𝑎+𝑥 / 𝑏+𝑥 / 𝑐−𝑥 / lcm(𝑎,𝑏)−𝑥 / lcm(𝑎,𝑐)−𝑥 / lcm(𝑏,𝑐)+𝑥 / lcm(𝑎,𝑏,𝑐)</li>
<li>其中，<code>lcm</code> 表示最小公倍数。</li>
</ul>
</li>
</ol>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><a href="https://leetcode.cn/problems/trapping-rain-water/description/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Question:</span></span><br><span class="line"><span class="comment">// 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> &nbsp; &nbsp;<span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;height.<span class="built_in">insert</span>(height.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;height.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()]){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> tmp = st.<span class="built_in">top</span>();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st.<span class="built_in">pop</span>();</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">if</span>(!st.<span class="built_in">empty</span>()){</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> h = <span class="built_in">min</span>(height[st.<span class="built_in">top</span>()], height[i]) - height[tmp];</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans += h * w;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;st.<span class="built_in">push</span>(i);</span><br><span class="line"> &nbsp; &nbsp; &nbsp;  }</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="keyword">return</span> ans;</span><br><span class="line"> &nbsp;  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p><a href="https://www.luogu.com.cn/problem/P1886">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; maxq;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; minq;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> arr[N], min_ans[N], max_ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">	<span class="keyword">while</span>(!maxq.<span class="built_in">empty</span>() &amp;&amp; maxq.<span class="built_in">back</span>() &lt; x){</span><br><span class="line">		maxq.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">    maxq.<span class="built_in">push_back</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!minq.<span class="built_in">empty</span>() &amp;&amp; minq.<span class="built_in">back</span>() &gt; x){</span><br><span class="line">        minq.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">    minq.<span class="built_in">push_back</span>(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(maxq.<span class="built_in">front</span>() == x) maxq.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">if</span>(minq.<span class="built_in">front</span>() == x) minq.<span class="built_in">pop_front</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_min</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> minq.<span class="built_in">front</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> maxq.<span class="built_in">front</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++){</span><br><span class="line">    	<span class="built_in">push</span>(arr[i]);</span><br><span class="line">    }</span><br><span class="line">    min_ans[<span class="number">0</span>] = <span class="built_in">get_min</span>();</span><br><span class="line">    max_ans[<span class="number">0</span>] = <span class="built_in">get_max</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = k;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n){</span><br><span class="line">        <span class="built_in">pop</span>(arr[i++]);</span><br><span class="line">        <span class="built_in">push</span>(arr[j++]);</span><br><span class="line">        min_ans[i] = <span class="built_in">get_min</span>();</span><br><span class="line">        max_ans[i] = <span class="built_in">get_max</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - k; i++){</span><br><span class="line">    	cout &lt;&lt; min_ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - k; i++){</span><br><span class="line">    	cout &lt;&lt; max_ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h1><p><a href="https://www.luogu.com.cn/problem/P2249">二分查找模板</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2678">二分答案模板</a></p>
<p><strong>upper_bound 找到首个大于的迭代器</strong></p>
<p><strong>lower_bound 找到首个不小于的迭代器</strong></p>
<p><strong>最小的….的最大….一般想到用二分答案</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right){</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">judge</span>(mid)){</span><br><span class="line">        ans = mid;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p><a href="https://www.luogu.com.cn/problem/P8218">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 保证数组第一个元素为0，即arr[0] = 0, prefix[0] = 0</span></span><br><span class="line">arr[<span class="number">10000</span>]; <span class="comment">//数据</span></span><br><span class="line">prefix[<span class="number">10000</span>]; <span class="comment">//前缀和</span></span><br><span class="line">prefix[i] = prefix[i - <span class="number">1</span>] + arr[i]; <span class="comment">// 初始化前缀和数组</span></span><br><span class="line"><span class="comment">// l - r的前缀和即为</span></span><br><span class="line">ans = prefix[r] - prefix[l - <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure>

<h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><p><a href="https://www.luogu.com.cn/problem/P2367">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>.....</span><br><span class="line">	d[i] = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 假设a - b段arr加1</span></span><br><span class="line">d[a]++; <span class="comment">// a后面所有都受到了影响...</span></span><br><span class="line">d[b+<span class="number">1</span>]--; <span class="comment">// 终止b+1后面受到的影响...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将加1使用到arr上</span></span><br><span class="line"><span class="keyword">for</span>.....</span><br><span class="line">	arr[i] = d[i] + arr[i - <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure>

<p><strong>扩展(二维模式)</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 可以画一个图看一下</span></span><br><span class="line"><span class="comment">// (x1, y1) - (x2, y2)进行了操作</span></span><br><span class="line">d[x][y1]++; <span class="comment">// x从x1到x2</span></span><br><span class="line">d[x][y2 + <span class="number">1</span>]--; <span class="comment">// x上同</span></span><br><span class="line"></span><br><span class="line">mmap[x][y] = mmap[x][y - <span class="number">1</span>] + d[x][y]; <span class="comment">//按行扫描 </span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p><strong>应用范围: 数组空间无限大，只关注相对距离的问题</strong></p>
<p><strong>template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 范围为1 ~ 10^9，但只用到了10^5个数</span></span><br><span class="line">a[<span class="number">10005</span>]; <span class="comment">// 存储下标</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(a, a + n) - a; <span class="comment">//去重并获得新的去重数组的长度</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p><a href="https://www.luogu.com.cn/problem/P3375">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">string s1, s2;</span><br><span class="line"><span class="type">int</span> nxt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nxt</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s2.<span class="built_in">size</span>(); i++){</span><br><span class="line">		<span class="keyword">while</span>(s2[j] != s2[i] &amp;&amp; j &gt; <span class="number">0</span>){</span><br><span class="line">			j = nxt[j - <span class="number">1</span>];</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(s2[i] == s2[j]) j++;</span><br><span class="line">		nxt[i] = j;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">	<span class="built_in">get_nxt</span>();</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++){</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s1[i] != s2[j]){</span><br><span class="line">            j = nxt[j - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(s1[i] == s2[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == s2.<span class="built_in">size</span>()){</span><br><span class="line">            cout &lt;&lt; i - s2.<span class="built_in">size</span>() + <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            j = nxt[j - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s2.<span class="built_in">size</span>(); i++){</span><br><span class="line">		cout &lt;&lt; nxt[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h1><p>汉诺塔问题是一个经典的递归问题，将n个盘子从A柱子移动到C柱子，可以分解为以下三个步骤：</p>
<ol>
<li>将n-1个盘子从A柱子移动到B柱子；</li>
<li>将第n个盘子从A柱子移动到C柱子；</li>
<li>将n-1个盘子从B柱子移动到C柱子。</li>
</ol>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C)</span> </span>{</span><br><span class="line"> &nbsp; &nbsp;<span class="keyword">if</span> (n == <span class="number">1</span>) {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;cout &lt;&lt; <span class="string">"Move disk "</span> &lt;&lt; n &lt;&lt; <span class="string">" from "</span> &lt;&lt; A &lt;&lt; <span class="string">" to "</span> &lt;&lt; C &lt;&lt; endl;</span><br><span class="line"> &nbsp;  } <span class="keyword">else</span> {</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="built_in">hanoi</span>(n - <span class="number">1</span>, A, C, B);</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;cout &lt;&lt; <span class="string">"Move disk "</span> &lt;&lt; n &lt;&lt; <span class="string">" from "</span> &lt;&lt; A &lt;&lt; <span class="string">" to "</span> &lt;&lt; C &lt;&lt; endl;</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="built_in">hanoi</span>(n - <span class="number">1</span>, B, A, C);</span><br><span class="line"> &nbsp;  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/a444b428.html</url>
    <content><![CDATA[<p>排序算法中的一些思想可以用于解决一些题目，例如逆序对等….</p>
<span id="more"></span>

<p>以下所有数组下标都从0开始，并且排序从小到大</p>
<table>
<thead>
<tr>
<th>算法种类</th>
<th align="center">最好时间复杂度</th>
<th align="center">最坏时间复杂度</th>
<th align="center">平均时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">是否稳定</th>
</tr>
</thead>
<tbody><tr>
<td>插入排序</td>
<td align="center">O(N)</td>
<td align="center">O(N²)</td>
<td align="center">O(N²)</td>
<td align="center">O(1)</td>
<td align="center">是</td>
</tr>
<tr>
<td>希尔排序</td>
<td align="center">Nan</td>
<td align="center">Nan</td>
<td align="center">Nan</td>
<td align="center">O(1)</td>
<td align="center">否</td>
</tr>
<tr>
<td>冒泡排序</td>
<td align="center">O(N)</td>
<td align="center">O(N²)</td>
<td align="center">O(N²)</td>
<td align="center">O(1)</td>
<td align="center">是</td>
</tr>
<tr>
<td>选择排序</td>
<td align="center">O(N²)</td>
<td align="center">O(N²)</td>
<td align="center">O(N²)</td>
<td align="center">O(1)</td>
<td align="center">否</td>
</tr>
<tr>
<td>快速排序</td>
<td align="center">O(NlogN)</td>
<td align="center">O(N²)</td>
<td align="center">O(NlogN)</td>
<td align="center">O(NlogN)</td>
<td align="center">否</td>
</tr>
<tr>
<td>堆排序</td>
<td align="center">O(NlogN)</td>
<td align="center">O(NlogN)</td>
<td align="center">O(NlogN)</td>
<td align="center">O(1)</td>
<td align="center">否</td>
</tr>
<tr>
<td>归并排序</td>
<td align="center">O(NlogN)</td>
<td align="center">O(NlogN)</td>
<td align="center">O(NlogN)</td>
<td align="center">O(N)</td>
<td align="center">是</td>
</tr>
<tr>
<td>计数排序</td>
<td align="center">O(d(n + r))</td>
<td align="center">O(d(n + r))</td>
<td align="center">O(d(n + r))</td>
<td align="center">O(r)</td>
<td align="center">是</td>
</tr>
</tbody></table>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; i++){</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; tmp; j--){</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        }</span><br><span class="line">        arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> dk = len / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk /= <span class="number">2</span>){</span><br><span class="line">        <span class="keyword">for</span>(i = dk; i &lt; len; i++){</span><br><span class="line">            <span class="type">int</span> tmp = arr[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i - dk; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; tmp; j -= dk){</span><br><span class="line">                arr[j + dk] = arr[j];</span><br><span class="line">            }</span><br><span class="line">            arr[j + dk] = tmp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++){</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = len - <span class="number">1</span>; j &gt; i; j--){</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j - <span class="number">1</span>]){</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++){</span><br><span class="line">        <span class="type">int</span> minIdx = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; len; j++){</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIdx]) minIdx = j;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">swap</span>(arr[minIdx], arr[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> pivot = arr[l];</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r){</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[r] &gt;= pivot) r--;</span><br><span class="line">        <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt;= pivot) l++;</span><br><span class="line">        <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">    }</span><br><span class="line">    arr[l] = pivot;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivotIdx = <span class="built_in">partition</span>(arr, l, r);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr[i], l, pivotIdx - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr[i], pivotIdx + <span class="number">1</span>, r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len, <span class="type">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> tmp = arr[idx], child = idx, i;</span><br><span class="line">    <span class="keyword">for</span>(i = idx; <span class="number">2</span> * i + <span class="number">1</span> &lt; len; i = child){</span><br><span class="line">        child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt; len &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) child++;</span><br><span class="line">        <span class="keyword">if</span>(tmp &gt; arr[child]) <span class="keyword">break</span>;</span><br><span class="line">        arr[i] = arr[child];</span><br><span class="line">    }</span><br><span class="line">    arr[i] = tmp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--){</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(arr, len, i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">BuildHeap</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--){</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">BuildHeap</span>(arr, i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><a href="https://www.luogu.com.cn/problem/P1908">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n1 = mid - l + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = r - mid;</span><br><span class="line">    <span class="type">int</span> arr1[n1], arr2[n2];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++) arr1[i] = arr[l + i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++) arr2[i] = arr[mid + <span class="number">1</span> + i];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = l;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2){</span><br><span class="line">        <span class="keyword">if</span>(arr1[i] &lt; arr2[j]) arr[k++] = arr1[i++];</span><br><span class="line">        <span class="keyword">else</span> arr[k++] = arr2[j++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n1) arr[k++] = arr1[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n2) arr[k++] = arr2[j++];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, l, mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">Merge</span>(arr, l, mid, r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用设计模式</title>
    <url>/1e80ad29.html</url>
    <content><![CDATA[<p>设计模式提供了经过验证的解决方案，可以帮助开发者写出更优雅、可维护性更高的代码。它们能够减少代码中的重复、增强代码的灵活性和可扩展性。设计模式总共有23种，本文只介绍常用的几种</p>
<span id="more"></span>

<p>设计模式六大原则</p>
<ol>
<li><strong>单一职责原则：</strong>一个类只提供一种功能和仅有一个引起它变化的因素。</li>
<li><strong>开放封闭原则：</strong>对一个类来说，对它的内部修改是封闭的，对它的扩展是开放的。</li>
<li><strong>依赖倒置原则：</strong>就是程序依赖于抽象，而不依赖于实现。</li>
<li><strong>里氏替换原则：</strong>基类出现的地方，通过它的子类也完全可以实现这个功能</li>
<li><strong>接口隔离原则：</strong>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</li>
<li><strong>合成复用原则：</strong>多用组合设计类，少用继承。</li>
</ol>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>只允许创建一个活动的对象（实例），提供了对唯一实例的受控访问。</p>
<p>单线程</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleInstance</span>() {}</span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance&amp; other) {}</span><br><span class="line">    SingleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance&amp; other) {<span class="keyword">return</span> *<span class="keyword">this</span>;}</span><br><span class="line">    <span class="type">static</span> SingleInstance* instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleInstance* <span class="title">globalInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>){</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>线程安全（懒汉式）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleInstance</span>() {}</span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance&amp; other) {}</span><br><span class="line">    SingleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance&amp; other) {<span class="keyword">return</span> *<span class="keyword">this</span>;}</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="type">static</span> SingleInstance* instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 还是会出现一定的问题，具体表现为reorder, 可以通过原子操作+内存屏障实现</span></span><br><span class="line">    <span class="function">SingleInstance* <span class="title">globalInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>){</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">nullptr</span>){</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>线程安全（饿汉式）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleInstance</span>() {}</span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance&amp; other) {}</span><br><span class="line">    SingleInstance&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance&amp; other) {<span class="keyword">return</span> *<span class="keyword">this</span>;}</span><br><span class="line">    <span class="type">static</span> SingleInstance instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SingleInstance* <span class="title">globalInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">SingleInstance* SingleInstance::instance = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br></pre></td></tr></tbody></table></figure>

<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。</p>
<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品类（抽象类，不能实例化）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Product</span>(){};</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>=<span class="number">0</span>;  <span class="comment">//纯虚函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">productA</span>:<span class="keyword">public</span> Product{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">productA</span>(){};</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>{ cout &lt;&lt; <span class="string">"product A create!"</span> &lt;&lt; endl; };</span><br><span class="line">    ~<span class="built_in">productA</span>(){};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">productB</span>:<span class="keyword">public</span> Product{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">productB</span>(){};</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>{ cout &lt;&lt; <span class="string">"product B create!"</span> &lt;&lt; endl; };</span><br><span class="line">    ~<span class="built_in">productB</span>(){};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simpleFactory</span>{ <span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Product* m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">simpleFactory</span>(){};</span><br><span class="line">    <span class="function">Product* <span class="title">product</span><span class="params">(<span class="type">const</span> string str)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">"productA"</span>) m = <span class="keyword">new</span> <span class="built_in">productA</span>();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">"productB"</span>) m = <span class="keyword">new</span> <span class="built_in">productB</span>();</span><br><span class="line">        <span class="comment">//... 不符合开放封闭原则，抽象工厂类解决</span></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//产品类（抽象类，不能实例化）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Product</span>(){}</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>=<span class="number">0</span>;  <span class="comment">//纯虚函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span>:<span class="keyword">public</span> Product{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductA</span>(){}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>{ cout&lt;&lt;<span class="string">"product A create!"</span>&lt;&lt;endl; };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span>:<span class="keyword">public</span> Product{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductB</span>(){}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>{ cout&lt;&lt;<span class="string">"product B create!"</span>&lt;&lt;endl; };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>{<span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">CreateProduct</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactorA</span>:<span class="keyword">public</span> Factory{<span class="comment">//工厂类A，只生产A产品</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">CreateProduct</span><span class="params">()</span></span>{</span><br><span class="line">        Product* _Product = <span class="literal">nullptr</span>;</span><br><span class="line">        _Product = <span class="keyword">new</span> <span class="built_in">ProductA</span>();</span><br><span class="line">        <span class="keyword">return</span> _Product;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactorB</span>:<span class="keyword">public</span> Factory{<span class="comment">//工厂类B，只生产B产品</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">CreateProduct</span><span class="params">()</span></span>{</span><br><span class="line">        Product* _Product = <span class="literal">nullptr</span>;</span><br><span class="line">        _Product = <span class="keyword">new</span> <span class="built_in">ProductB</span>();</span><br><span class="line">        <span class="keyword">return</span> _Product;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。（例如：进度条）</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IProgress</span> <span class="comment">// 进度条基类</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoProgress</span><span class="params">(<span class="type">float</span> value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IProgress</span>() {}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSplitter</span></span><br><span class="line">{</span><br><span class="line">    string m_filePath;</span><br><span class="line">    <span class="type">int</span> m_fileNumber;</span><br><span class="line">    List&lt;IProgress *&gt; m_iprogressList; <span class="comment">//抽象通知机制，观察者的核心</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileSplitter</span>(<span class="type">const</span> string &amp;filePath, <span class="type">int</span> fileNumber) : <span class="built_in">m_filePath</span>(filePath),</span><br><span class="line">                                                           <span class="built_in">m_fileNumber</span>(fileNumber)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="type">float</span> progressValue = m_fileNumber;</span><br><span class="line">            progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line">            <span class="built_in">onProgress</span>(progressValue); <span class="comment">//更新进度</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addIProgress</span><span class="params">(IProgress *iprogress)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_iprogressList.<span class="built_in">push_back</span>(iprogress);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeIProgress</span><span class="params">(IProgress *iprogress)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        m_iprogressList.<span class="built_in">remove</span>(iprogress);</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onProgress</span><span class="params">(<span class="type">float</span> value)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        List&lt;IProgress *&gt;::iterator itor = m_iprogressList.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (itor != m_iprogressList.<span class="built_in">end</span>())</span><br><span class="line">        {</span><br><span class="line">            (*itor)-&gt;<span class="built_in">DoProgress</span>(value); <span class="comment">//更新所有的进度条</span></span><br><span class="line">            itor++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。该模式使得算法可独立于使用它的客户而变化。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// The abstract strategy</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>{ <span class="comment">// 策略抽象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span>{</span><br><span class="line">          cout&lt;&lt;<span class="string">"I am from ConcreteStrategyA."</span>&lt;&lt;endl;</span><br><span class="line">     }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> Strategy{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span>{</span><br><span class="line">          cout&lt;&lt;<span class="string">"I am from ConcreteStrategyB."</span>&lt;&lt;endl;</span><br><span class="line">     }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyC</span> : <span class="keyword">public</span> Strategy{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span>{</span><br><span class="line">          cout&lt;&lt;<span class="string">"I am from ConcreteStrategyC."</span>&lt;&lt;endl;</span><br><span class="line">     }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Context</span>(Strategy *pStrategyArg) : <span class="built_in">pStrategy</span>(pStrategyArg){};</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">ContextInterface</span><span class="params">()</span></span>{</span><br><span class="line">          pStrategy-&gt;<span class="built_in">AlgorithmInterface</span>();</span><br><span class="line">     }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     Strategy *pStrategy;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，<strong>同时又不改变其结构</strong>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stream</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">char</span> data)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>() {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileStream</span> : <span class="keyword">public</span> Stream</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">char</span> data)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorStream</span> : <span class="keyword">public</span> Stream <span class="comment">//装饰器基类</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Stream *stream; <span class="comment">//组合代替继承</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">DecoratorStream</span>(Stream *stm) : <span class="built_in">stream</span>(stm)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CryptoStream</span> : <span class="keyword">public</span> DecoratorStream</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream *stm) : <span class="built_in">DecoratorStream</span>(stm)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number); <span class="comment">//读文件流</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(<span class="type">int</span> position)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Seek</span>(position); <span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Write</span>(data); <span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedStream</span> : <span class="keyword">public</span> DecoratorStream</span><br><span class="line">{</span><br><span class="line">    Stream *stream; <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferedStream</span>(Stream *stm) : <span class="built_in">DecoratorStream</span>(stm)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream *s1 = <span class="keyword">new</span> <span class="built_in">FileStream</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目标抽象类Robot（机器人接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="comment">//适配者类Douya（Douya类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Douya</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"豆芽吃饭"</span> &lt;&lt; endl;    </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"豆芽睡觉"</span> &lt;&lt; endl;    </span><br><span class="line">    }</span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器类DouyaAdapter（DouyaAdapter类） </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DouyaAdapter</span> : <span class="keyword">public</span> Robot, <span class="keyword">public</span> Douya{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"机器人模仿："</span> ;</span><br><span class="line">        Douya::<span class="built_in">eat</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"机器人模仿："</span> ;</span><br><span class="line">        Douya::<span class="built_in">sleep</span>(); </span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端测试类Client </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>{</span><br><span class="line">    Robot *robot = (Robot*)<span class="keyword">new</span> <span class="built_in">DouyaAdapter</span>();</span><br><span class="line">    robot-&gt;<span class="built_in">eat</span>(); <span class="comment">// 机器人模仿：豆芽吃饭</span></span><br><span class="line">    robot-&gt;<span class="built_in">sleep</span>(); <span class="comment">// 机器人模仿：豆芽睡觉</span></span><br><span class="line">    <span class="keyword">delete</span> robot;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/b2626942.html</url>
    <content><![CDATA[<p>背包九讲经典问题！！！</p>
<span id="more"></span>

<p><strong>DP做题顺序</strong></p>
<ol>
<li><strong>确定dp数组（dp table）以及下标的含义</strong></li>
<li><strong>确定递推公式</strong></li>
<li><strong>dp数组如何初始化</strong></li>
<li><strong>确定遍历顺序</strong></li>
<li><strong>举例推导dp数组</strong></li>
</ol>
<blockquote>
<p><strong>以下背包均用一维数组来完成</strong></p>
<p><strong>多少种方法</strong> <code>dp[j] += dp[j - num[i]]</code></p>
</blockquote>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h2><p><a href="https://www.acwing.com/problem/content/2/">模板</a></p>
<p><strong>二维数组推算公式</strong> <code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动数组法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">int</span> w[<span class="number">10000</span>], v[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10000</span>]; <span class="comment">// 0 - n</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 先遍历物品，再遍历容量，容量要倒序遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= w[i]; --j){</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p><a href="https://www.acwing.com/problem/content/3/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line">ll w[<span class="number">10000</span>], v[<span class="number">10000</span>];</span><br><span class="line">ll dp[<span class="number">10000</span>]; <span class="comment">// 0 - n</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 与01背包问题不同，容量按照正序遍历</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = w[i]; j &lt;= n; ++j){</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p><a href="https://www.luogu.com.cn/problem/P1776">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, MAXW = <span class="number">4e4</span> + <span class="number">5</span>; <span class="comment">// 开大一点建议....</span></span><br><span class="line"><span class="type">int</span> n, W;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[MAXW];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; W;</span><br><span class="line">	<span class="type">int</span> v_val, w_val, m_val;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; v_val &gt;&gt; w_val &gt;&gt; m_val;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m_val; k &lt;&lt;= <span class="number">1</span>){</span><br><span class="line">            <span class="comment">// 二进制优化</span></span><br><span class="line">			v[++cnt] = k * v_val;</span><br><span class="line">			w[cnt] = k * w_val;</span><br><span class="line">			m_val -= k;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(m_val &gt; <span class="number">0</span>){</span><br><span class="line">			v[++cnt] = m_val * v_val;</span><br><span class="line">			w[cnt] = m_val * w_val;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = W; j &gt;= w[i]; j--){</span><br><span class="line">				dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[W];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h2 id="有依赖背包问题"><a href="#有依赖背包问题" class="headerlink" title="有依赖背包问题"></a>有依赖背包问题</h2><p><a href="https://www.luogu.com.cn/problem/P1064">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3.2e4</span> + <span class="number">5</span>, M = <span class="number">65</span>;</span><br><span class="line"><span class="type">int</span> cost[M], val[M], king[M], fans[M];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; follow;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	follow.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> v, belong;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++){</span><br><span class="line">		cin &gt;&gt; cost[i] &gt;&gt; v &gt;&gt; belong;</span><br><span class="line">		val[i] = v * cost[i];</span><br><span class="line">		<span class="keyword">if</span>(belong == <span class="number">0</span>) king[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			fans[belong]++;</span><br><span class="line">			follow[belong].<span class="built_in">push_back</span>(i);</span><br><span class="line">		} </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, fan1, fan2; i &lt;= m; i++){</span><br><span class="line">		<span class="keyword">if</span>(king[i]){</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= cost[i]; j--){</span><br><span class="line">					dp[j] = <span class="built_in">max</span>(dp[j - cost[i]] + val[i], dp[j]);</span><br><span class="line">					fan1 = fans[i] &gt;= <span class="number">1</span>? follow[i][<span class="number">0</span>]: <span class="number">-1</span>;</span><br><span class="line">					fan2 = fans[i] &gt;= <span class="number">2</span>? follow[i][<span class="number">1</span>]: <span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">if</span>(fan1 != <span class="number">-1</span> &amp;&amp; j &gt;= cost[i] + cost[fan1]){</span><br><span class="line">						dp[j] = <span class="built_in">max</span>(dp[j - cost[i] - cost[fan1]] + val[i] + val[fan1], dp[j]);</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">if</span>(fan1 != <span class="number">-1</span> &amp;&amp; j &gt;= cost[i] + cost[fan2]){</span><br><span class="line">						dp[j] = <span class="built_in">max</span>(dp[j - cost[i] - cost[fan2]] + val[i] + val[fan2], dp[j]);</span><br><span class="line">					}</span><br><span class="line">					<span class="keyword">if</span>(fan1 != <span class="number">-1</span> &amp;&amp; fan2 != <span class="number">-1</span> &amp;&amp; j &gt;= cost[i] + cost[fan1] + cost[fan2]){</span><br><span class="line">						dp[j] = <span class="built_in">max</span>(dp[j - cost[i] - cost[fan1] - cost[fan2]] + val[i] + val[fan1] + val[fan2], dp[j]);</span><br><span class="line">					}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><p><a href="https://www.luogu.com.cn/problem/P1757">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, M = <span class="number">1005</span>;</span><br><span class="line">ll dp[M];</span><br><span class="line"><span class="type">int</span> w[N], v[N], t[N]; <span class="comment">// t--&gt;分组 </span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; t[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> start = <span class="number">1</span>, end = <span class="number">2</span>; start &lt;= n; ){</span><br><span class="line">		<span class="keyword">while</span>(t[end] == t[end - <span class="number">1</span>] &amp;&amp; end &lt;= n){</span><br><span class="line">			end++;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--){</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = start; k &lt; end; k++){</span><br><span class="line">				<span class="keyword">if</span>(j - w[k] &gt;= <span class="number">0</span>) dp[j] = <span class="built_in">max</span>(dp[j - w[k]] + v[k], dp[j]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		start = end++;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; dp[m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><p><a href="https://www.acwing.com/problem/content/7/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, V = <span class="number">1e5</span> + <span class="number">5</span>; <span class="comment">//要开大一点.....</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[V];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="type">int</span> a, b, s;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span>(s == <span class="number">-1</span>) s = <span class="number">1</span>; <span class="comment">// 01转换为多重</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="number">0</span>) s = m / a; <span class="comment">// 完全转换为多重...</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k *= <span class="number">2</span>){</span><br><span class="line">			v[++cnt] = k * a;</span><br><span class="line">			w[cnt] = k * b;</span><br><span class="line">			s -= k;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(s &gt; <span class="number">0</span>){</span><br><span class="line">			v[++cnt] = s * a;</span><br><span class="line">			w[cnt] = s * b;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--){</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; dp[m];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><p><a href="https://www.acwing.com/problem/content/8/">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, V = <span class="number">105</span>, M = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> v[N], m[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[V][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> a, b, c;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++){</span><br><span class="line">		cin &gt;&gt; v[i] &gt;&gt; m[i] &gt;&gt; w[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++){</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = b; j &gt;= v[i]; j--){</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = c; k &gt;= m[i]; k--){</span><br><span class="line">				dp[j][k] = <span class="built_in">max</span>(dp[j][k], dp[j - v[i]][k - m[i]] + w[i]);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; dp[b][c];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树论</title>
    <url>/b8c50a86.html</url>
    <content><![CDATA[<p>最难的一集…..</p>
<span id="more"></span>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p><a href="https://www.luogu.com.cn/problem/P3374">模板1</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3368">模板2</a></p>
<p><strong>对于单点改变的题目，求动态区间和</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int n, m, tree[N];</span><br><span class="line"></span><br><span class="line">int lowbit(int x){</span><br><span class="line">	return x &amp; (-x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void update(int loc, int k){</span><br><span class="line">	while(loc &lt;= n){</span><br><span class="line">		tree[loc] += k;</span><br><span class="line">		loc += lowbit(loc);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int query(int loc){</span><br><span class="line">	int ans = 0;</span><br><span class="line">	while(loc){</span><br><span class="line">		ans += tree[loc];</span><br><span class="line">		loc -= lowbit(loc);</span><br><span class="line">	}</span><br><span class="line">	return ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>实现差分数组</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for(int i = 1; i &lt;= n; i++){</span><br><span class="line">		cin &gt;&gt; arr[i];</span><br><span class="line">	}</span><br><span class="line">	for(int i = 1; i &lt;= m; i++){</span><br><span class="line">		int a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		if(a == 1){</span><br><span class="line">			int x, y, k;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">			update(x, k);</span><br><span class="line">			update(y + 1, -k);</span><br><span class="line">		}</span><br><span class="line">		if(a == 2){</span><br><span class="line">			int x;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			cout &lt;&lt; arr[x] + query(x) &lt;&lt; '\n';</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><p><a href="https://www.luogu.com.cn/problem/P3379">模板</a></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 5e5 + 5;</span><br><span class="line">int n, m, s;</span><br><span class="line"></span><br><span class="line">int dep[N];</span><br><span class="line">int jump[N][20];</span><br><span class="line">vector&lt;int&gt; G[N];</span><br><span class="line">void dfs(int x, int fa)</span><br><span class="line">{</span><br><span class="line">	jump[x][0] = fa;</span><br><span class="line">	dep[x] = dep[fa] + 1;</span><br><span class="line">	for(int i = 1; i &lt; 20; i++){</span><br><span class="line">		jump[x][i] = jump[jump[x][i - 1]][i - 1];</span><br><span class="line">	}</span><br><span class="line">	for(int i = 0; i &lt; G[x].size(); i++){</span><br><span class="line">		int y = G[x][i];</span><br><span class="line">		if(y != fa){</span><br><span class="line">			dfs(y, x);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">int LCA(int x, int y){</span><br><span class="line">	if(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">	while(dep[x] &gt; dep[y]){</span><br><span class="line">		x = jump[x][(int)log2(dep[x] - dep[y])];</span><br><span class="line">	}</span><br><span class="line">	if(x == y) return x;</span><br><span class="line">	for(int i = log2(dep[x]); i &gt;= 0; i--){</span><br><span class="line">		if(jump[x][i] != jump[y][i]){</span><br><span class="line">			x = jump[x][i];</span><br><span class="line">			y = jump[y][i];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	return jump[x][0];</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">	int x, y;</span><br><span class="line">	for(int i = 0; i &lt; n - 1; i++){</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		G[x].push_back(y);</span><br><span class="line">		G[y].push_back(x);</span><br><span class="line">	}</span><br><span class="line">	dfs(s, 0);</span><br><span class="line">	for(int i = 0; i &lt; m; i++){</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		int ans = LCA(x, y);</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; '\n';</span><br><span class="line">	}</span><br><span class="line">	return 0;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p><strong>两次dfs，但是好像还是有点问题，待更正……</strong></p>
<p><strong>Template</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2e5 + 5;</span><br><span class="line">struct Edge{</span><br><span class="line">	int v, w, next;</span><br><span class="line">}edge[N];</span><br><span class="line"></span><br><span class="line">// 链式前向星 </span><br><span class="line">int head[N];</span><br><span class="line">int cnt;</span><br><span class="line">void add_edge(int u, int v, int w){</span><br><span class="line">	edge[++cnt].v = v;</span><br><span class="line">	edge[cnt].w = w;</span><br><span class="line">	edge[cnt].next = head[u];</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int n, vis[N], fa[N];</span><br><span class="line">ll dis[N];</span><br><span class="line">void dfs(int x, int d, int&amp; fnode){</span><br><span class="line">	vis[x] = 1;</span><br><span class="line">	dis[x] = d;</span><br><span class="line">	for(int i = head[x]; i; i = edge[i].next){</span><br><span class="line">		int y = edge[i].v;</span><br><span class="line">		int w = edge[i].w;</span><br><span class="line">		if(!vis[y]){</span><br><span class="line">			fa[y] = x;</span><br><span class="line">			dfs(y, d + w, fnode);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	if(d &gt; dis[fnode]){</span><br><span class="line">		fnode = x;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	int u, v, w;</span><br><span class="line">	for(int i = 1; i &lt;= n - 1; i++){</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		add_edge(u, v, w);</span><br><span class="line">		add_edge(v, u, w);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	int fnode = 1;</span><br><span class="line">	dfs(1, 0, fnode);</span><br><span class="line"></span><br><span class="line">	int o_fnode = fnode;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	dfs(fnode, 0, o_fnode);</span><br><span class="line"></span><br><span class="line">	ll diameter = dis[o_fnode];</span><br><span class="line">	cout &lt;&lt; diameter &lt;&lt; '\n';</span><br><span class="line"></span><br><span class="line">	// 记录路径上的边</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    int node = o_fnode;</span><br><span class="line">    while (node != fnode) {</span><br><span class="line">        node = fa[node];</span><br><span class="line">        cnt++;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; cnt - 1;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>update….</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频基础</title>
    <url>/df0b37af.html</url>
    <content><![CDATA[<p>本文介绍常用的音视频基础知识，为后续音视频开发，流媒体传输做准备。</p>
<span id="more"></span>

<h1 id="音视频录制播放原理"><a href="#音视频录制播放原理" class="headerlink" title="音视频录制播放原理"></a>音视频录制播放原理</h1><p><strong>录制原理</strong></p>
<img src="/df0b37af/image-20241113214001794.png" class="">

<p><strong>播放原理</strong></p>
<img src="/df0b37af/image-20241113214042761.png" class="">

<h1 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h1><ol>
<li><p>RGB</p>
<p>R表示红色，G表示绿色，B表示蓝色</p>
</li>
<li><p><strong>YUV</strong></p>
<p>Y表示亮度，U和V表示色度。只有Y是可以直接显示的，U和V是不能直接显示的，需要通过Y来计算出RGB来显示。</p>
<p><strong>YUV格式</strong></p>
<p>针对排列方式分为：Planar格式、Packed格式</p>
<img src="/df0b37af/image-20241113214811102.png" class="">

<p>针对采样方式分为：4:4:4、4:2:2、4:2:0</p>
<img src="/df0b37af/image-20241113215044550.png" class="">

<p>（空心表示UV分量，实心表示Y分量）</p>
<p>4:4:4一个像素大小为3个字节，4:2:2一个像素大小为2个字节（(1 + 2 + 1) / 2），4:2:0一个像素大小为1.5个字节((2 + 4) / 4)</p>
</li>
</ol>
<p>RGB到YUV主要转换标准是 BT601 和 BT709。</p>
<p>BT601 TV Range转换公式：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// yuv -&gt; rgb</span></span><br><span class="line">y = <span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b;</span><br><span class="line">u = <span class="number">-0.169</span> * r - <span class="number">0.331</span> * g + <span class="number">0.5</span> * b + <span class="number">128</span>;</span><br><span class="line">v = <span class="number">0.5</span> * r - <span class="number">0.419</span> * g - <span class="number">0.081</span> * b + <span class="number">128</span>;</span><br><span class="line"><span class="comment">// rgb -&gt; yuv</span></span><br><span class="line">r = y + <span class="number">1.4075</span> * (v - <span class="number">128</span>);</span><br><span class="line">g = y - <span class="number">0.3455</span> * (u - <span class="number">128</span>) - <span class="number">0.7169</span> * (v - <span class="number">128</span>);</span><br><span class="line">b = y + <span class="number">1.779</span> * (u - <span class="number">128</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>(解码失败出现绿屏：y, u, v分量都填为0值，导致只有g分量有值)</p>
<h2 id="YUV-Stride问题"><a href="#YUV-Stride问题" class="headerlink" title="YUV Stride问题"></a>YUV Stride问题</h2><p>比如分辨率638x480的YUV420P图像，我们在内存处理的时候如果要以16字节对齐，则638不能被16整除，我们需要在每行尾部填充2个字节。就是640。此时该图片的Y stride为640字节。</p>
<h1 id="视频基础知识"><a href="#视频基础知识" class="headerlink" title="视频基础知识"></a>视频基础知识</h1><p>视频码率：kb/s，是指视频文件在单位时间内使用的数据流量，也叫码流率。码率越大，说明单位时间内取样率越大，数据流精度就越高。</p>
<p>视频帧率：fps，通常说一个视频的25帧，指的就是这个视频帧率，即1秒中会显示25帧。帧率越高，给人的视觉就越流畅。</p>
<p>视频分辨率：分辨率就是我们常说的640x480分辨率、1920x1080分辨率，分辨率影响视频图像的大小。</p>
<h2 id="I、P、B帧"><a href="#I、P、B帧" class="headerlink" title="I、P、B帧"></a>I、P、B帧</h2><p>I 帧（Intra coded frames）：I帧不需要参考其他画面而生成,解码时仅靠自己就重构完整图像;I帧所占数据的信息量比较大;</p>
<p>P帧（Predictive coded frames）：P帧是通过前面的I帧或P帧预测生成的，P帧只保存与前一帧的差异信息;</p>
<p>B帧（Bidirectional predicted frames）：B帧是通过前面的I帧或P帧和后面的P帧预测生成的，B帧保存前后帧的差异信息。</p>
<img src="/df0b37af/63f12708954f930777da6d4101600488.png" class="">

<p>常用视频压缩算法：</p>
<ol>
<li>MPEG2	MPEG阵营</li>
<li>H264	    MPEG阵营</li>
<li>H265	    MPEG阵营</li>
<li>AVS        中国</li>
</ol>
<h1 id="音频基础知识"><a href="#音频基础知识" class="headerlink" title="音频基础知识"></a>音频基础知识</h1><ol>
<li><p><strong>采样频率：</strong>采样频率是指每秒钟采集的样本数，单位是Hz。采样频率越高，声音的还原就越真实。常用的采样频率有：</p>
<p>22000（22kHz）：	无线广播。</p>
<p>44100（44.1kHz）：CD音质。</p>
<p>48000（48kHz）：	数字电视。</p>
</li>
<li><p><strong>采样精度（采样深度）：</strong>每个“样本点”的大小，常用的大小为8bit， 16bit，24bit。</p>
</li>
<li><p><strong>通道数：</strong>单声道，双声道，四声道。</p>
</li>
<li><p><strong>比特率：</strong>每秒传输的bit数，单位为：bps（Bit Per Second）	间接衡量声音质量的一个标准。没有压缩的音频数据的比特率 = 采样频率 * 采样精度 * 通道数。</p>
</li>
<li><p><strong>码率：</strong> 压缩后的音频数据的比特率。</p>
<p>常见的码率：	</p>
<p>96kbps：		FM质量	</p>
<p>128-160kbps：一般质量音频。	</p>
<p>192kbps：		CD质量。	</p>
<p>256-320Kbps：高质量音频		</p>
<p>码率越大，压缩效率越低，音质越好，压缩后数据越大。	码率 = 音频文件大小/时长。</p>
</li>
<li><p><strong>帧：</strong>每次编码的采样单元数，比如MP3通常是1152个采样点作为一个编码单元，AAC通常是1024个采样点作为一个编码单元。</p>
</li>
<li><p><strong>帧长：</strong>可以指每帧播放持续的时间：每帧持续时间(秒) = 每帧采样点数 / 采样频率（HZ）	比如：MP3 48k, 1152个采样点,每帧则为 24毫秒	1152/48000= 0.024 秒 = 24毫秒；</p>
</li>
</ol>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><ol>
<li>交错方式：LRLRLRLR</li>
<li>非交错方式：LLLLRRRR</li>
</ol>
<p>数字音频压缩编码在保证信号在听觉方面不产生失真的前提下，对音频数据信号进行尽可能大的压缩，降低数据量。数字音频压缩编码采取去除声音信号中冗余成分的方法来实现。所谓冗余成分指的是音频中不能被人耳感知到的信号，它们对确定声音的音色，音调等信息没有任何的帮助。</p>
<p>此外，根据人耳听觉的生理和心理声学现象，当一个强音信号与一个弱音信号同时存在时，弱音信号将被强音信号所掩蔽而听不见，这样弱音信号就可以视为冗余信号而不用传送。这就是人耳听觉的掩蔽效应，主要表现在频谱掩蔽效应和时域掩蔽效应。</p>
<img src="/df0b37af/01aff35e61f9ad42d9fd21d31809072f.png" class="" title="频谱掩蔽效应">

<img src="/df0b37af/image-20241114130255095.png" class="" title="时域掩蔽效应">

<p><strong>音频编码-压缩编码方法</strong></p>
<img src="/df0b37af/image-20241114130136164.png" class="">

<h1 id="音视频同步"><a href="#音视频同步" class="headerlink" title="音视频同步"></a>音视频同步</h1><p><strong>封装格式：</strong>已经编码压缩好的视频流、音频流及字幕按照一定的方案放到一个文件中，便于播放软件播放。</p>
<p>常见的封装格式：AVI、MP4、MKV、FLV、MOV、RMVB、TS、WMV、RM、WEBM、MPEG、ASF、3GP、VOB、OGM、DIVX、XVID、M2TS、MTS、M4V、F4V、DAT、ISO、NSV、MPG、MPEG、M2V、M1V、M2P、M2T、M2TS、M3U8、M3U、M4A、M4B、M4P、M4R、M4V、MKA、MKV、MOV、MP2、MP2V、MP3、MP4。</p>
<p><strong>音视频同步概念：</strong></p>
<ol>
<li><p>DTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。</p>
</li>
<li><p>PTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。</p>
</li>
</ol>
<p><strong>音视频同步方式：</strong></p>
<ol>
<li><p>Audio Master：同步视频到音频</p>
</li>
<li><p>Video Master：同步音频到视频</p>
</li>
<li><p>External Clock Master：同步音频和视频到外部时钟</p>
</li>
</ol>
]]></content>
      <categories>
        <category>音视频开发</category>
      </categories>
      <tags>
        <tag>-音视频</tag>
      </tags>
  </entry>
</search>
